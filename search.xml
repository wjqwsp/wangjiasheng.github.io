<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[LeetCode 237 Delete Node in a LinkedList 题解]]></title>
      <url>http://wjqwsp.github.io/2016/09/24/LeetCode-237-Delete-Node-in-a-LinkedList-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　　Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>　　Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.<br><a id="more"></a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　　单链表要删除，必须知道要删除结点的前一个结点。但此题困难在于只给了要删除结点的引用，而无法获知该g结点的前一个结点，因此按传统方法无法删除。</p>
<p>　　但这题其实非常简单，换种思路，我们把删除该结点改为删除该结点的下一个结点，但在删除之前把下一个结点的值覆盖此结点的值。因此，虽然物理上删除的是下一个结点，但实际上该结点的值已经被删除了，而下一个结点的值仍然保留下来。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> ListNode first;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</div><div class="line">        node.val = node.next.val;</div><div class="line">        node.next = node.next.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java异常处理总结]]></title>
      <url>http://wjqwsp.github.io/2016/09/22/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　这一讲抽取Java异常处理的核心内容与基本思想，作一个总结，既作为个人笔记，也可供读者参考。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li>降低错误处理代码的复杂度，让程序实际的逻辑实现与错误处理相分离，使代码的阅读，编写和调试工作更加井井有条。</li>
<li>在能处理时捕捉异常，不能处理时则将异常传给其他地方处理。</li>
<li>将异常分类，用异常类的名字或携带的信息标识异常类别与详细信息，一般只用名字标识即可。在处理时不针对异常抛出点处理，只对异常类型处理，简化了异常处理的代码。<a id="more"></a>
</li>
</ul>
<h3 id="异常对象的类型"><a href="#异常对象的类型" class="headerlink" title="异常对象的类型"></a>异常对象的类型</h3><h4 id="必检异常与非必检异常"><a href="#必检异常与非必检异常" class="headerlink" title="必检异常与非必检异常"></a>必检异常与非必检异常</h4><p>　　我们指的异常类都是Exception类型或者继承了Exception类型的子类。这些异常类可以分为两大部分，一部分是必检异常，另一类是非必检异常。只有RuntimeException及其子类是非必检异常，其余都是必检异常。</p>
<p>　　非必检异常对象由Java虚拟机自行管理，当异常发生时，会自动在堆中new一个异常对象。如果非必检异常始终不捕捉，则会沿着方法调用栈一直往上冒泡，直到控制台，并且自动调用prinStackTrace()方法输出异常信息。而必检异常必须手动在堆中创建，然后用关键字throw抛出，且必须在程序的某一处进行捕捉处理。如果不处理，则需在main方法里声明抛出异常，将异常抛给控制台，让异常信息在控制台输出。</p>
<h4 id="RuntimeException的使用场景"><a href="#RuntimeException的使用场景" class="headerlink" title="RuntimeException的使用场景"></a>RuntimeException的使用场景</h4><p>　　我的理解是，必检异常都是用户在当前环境下直接产生的异常。而RuntimeException及其子类则代表编程错误。所谓编程错误，有两种含义：</p>
<ol>
<li>在程序员编程时应该进行检查的低级错误，如数组越界异常ArrayIndexOutOfBoundsException，空指针异常NullPointerException等，它们都是RuntimeException的子类。</li>
<li>某些间接的或者不是由方法调用者所能掌控的错误。例如别的地方传来的空指针引用，或者与该方法本身无直接关联的错误。</li>
</ol>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>　　所有继承了Exception或其子类的类，都是自定义异常类。我们可以根据自己的业务需要创建新的异常类。</p>
<h3 id="异常对象的处理方式"><a href="#异常对象的处理方式" class="headerlink" title="异常对象的处理方式"></a>异常对象的处理方式</h3><h4 id="抛出"><a href="#抛出" class="headerlink" title="抛出"></a>抛出</h4><p>　　如果方法里获得了一个异常对象，但不知道怎么处理，或者在该方法的作用域内没有办法处理，则必须将异常对象往方法调用栈的上一级抛出，让别的地方处理。</p>
<p>　　我们在设计方法的时候，必须声明该方法可能会抛出什么异常，在方法名的后面跟throws再加上可能抛出的异常类表示。所有可能抛出的必检异常都必须声明，且调用该方法时候要么在调用该方法的方法签名上再进行抛出声明，要么用try…catch语句捕捉处理异常。否则产生编译错误。</p>
<h4 id="捕捉"><a href="#捕捉" class="headerlink" title="捕捉"></a>捕捉</h4><p>　　catch作用域就是异常处理程序代码所在地，对捕捉到的异常进行处理。如果同时捕捉多个异常，且这些异常存在继承关系，则必须将继承链里相对最后的子类异常放在前面，并按继承链的顺序由子类到父类依次排列。这是因为异常捕捉只要捕捉到相应类型的异常则终止，后面的捕捉块都不会起作用。而Java里支持多态，所以如果父类异常放前面，则子类异常永远不会被捕捉到。</p>
<h3 id="无法处理的异常"><a href="#无法处理的异常" class="headerlink" title="无法处理的异常"></a>无法处理的异常</h3><p>　　无法处理的异常需要抛出，但如果我们一直不知道如何处理该异常，那应该怎么办呢？特别对于必检异常，强制我们进行捕获或继续上抛，如果始终不捕捉，那么异常对象会怎么样呢？</p>
<h4 id="空处理"><a href="#空处理" class="headerlink" title="空处理"></a>空处理</h4><p>　　千万不能为了应付编译，捕捉了异常，而进行空处理。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    <span class="comment">//do nothing</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这样的话，即便发生了异常，我们也无从得知程序有错，因为异常信息被吞没了。</p>
<h4 id="输出异常信息"><a href="#输出异常信息" class="headerlink" title="输出异常信息"></a>输出异常信息</h4><p>　　即便为了应付编译，我们也得输出异常信息，这样我们可以定位错误，以便在需要的时候修改异常处理的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　Exception类继承自Throwable类，Throwable类有3个关于异常输出的方法：</p>
<ul>
<li>printStackTrace()</li>
<li>printStackTrace(PrintStream)</li>
<li>printStackTrace(java.io.PrintWriter)</li>
</ul>
<p>　　printStackTrace()会把异常抛出点往上的所有方法调用栈信息输出到标准错误流。除了输出到标准错误流，也可以指定参数，指定输出到由PrintStream流或者PrintWriter包装的一个流。</p>
<h4 id="只能部分处理异常"><a href="#只能部分处理异常" class="headerlink" title="只能部分处理异常"></a>只能部分处理异常</h4><p>　　对于某些异常，可能在当前方法内捕捉可以处理一部分问题，但还有其他问题需要由其他方法继续处理。这种情况，我们可以先捕捉，进行处理，然后重新在catch代码块里抛出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    <span class="keyword">throw</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　但重新抛出产生了一个问题，即重新抛出的异常仍然保留的是原来调用栈的信息，在别的地方再进行捕捉时，printStackTrace()方法打印的仍然是第一次抛出时的方法调用栈。如果需要更新调用栈信息，则需要用fillInStackTrace()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    <span class="keyword">throw</span> (Exception)e.fillInStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　fillInStackTrace()方法会返回一个更新了调用栈信息的Throwable类型对象。</p>
<h4 id="main方法抛出异常"><a href="#main方法抛出异常" class="headerlink" title="main方法抛出异常"></a>main方法抛出异常</h4><p>　　如果异常一直抛出到main方法仍然无法处理，那么可以声明main方法抛出异常，异常会直接传给控制台输出调用栈信息。</p>
<h4 id="将必检异常转换为非必检异常"><a href="#将必检异常转换为非必检异常" class="headerlink" title="将必检异常转换为非必检异常"></a>将必检异常转换为非必检异常</h4><p>　　我们可以用e.printStackTrace()的形式，在不知道怎么处理异常时捕捉异常并单纯输出异常信息。然而，捕捉就意味着处理，如果我们不处理只捕捉，则违背了异常处理的初衷。对于无法处理的异常，我们应始终抛出。而RuntimeException及其子类，都是非必检异常，可以自动沿调用链抛出直至控制台。我们可以利用这种特性，让必检异常转换为非必检异常，让它们抛出到控制台而始终不捕捉。等以后知道怎么处理之后，再修改代码。</p>
<h5 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h5><p>　　要了解异常类型转换，必须先介绍异常链。</p>
<p>　　异常链的产生也是源自重新抛出。要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，就被称为异常链。构造异常链，我们需要在堆里new一个新的异常对象，并且把原始异常对象传入该新的对象里。对于Error,Exception,RuntimeException，其构造函数就接收一个异常对象。但对于其他类型的异常，必须用initCause(Exception)方法传入异常对象。</p>
<p>　　其后，我们可以捕捉新的异常对象，原始异常对象的信息也会保存在里面。</p>
<h5 id="转换为RuntimeException"><a href="#转换为RuntimeException" class="headerlink" title="转换为RuntimeException"></a>转换为RuntimeException</h5><p>　　了解了异常链，这种转换就非常简单了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　以IOException为例，它是必检异常，通过传入RuntimeException的构造函数，就可以转换为非必检异常抛出了。</p>
<p>　　我觉得对于暂时不知道怎么处理的异常，这种处理方式是最佳的方式。</p>
<h3 id="资源清理"><a href="#资源清理" class="headerlink" title="资源清理"></a>资源清理</h3><p>　　Java只负责内存清理，所有与内存无关的清理工作，都需要手动清理，例如一些IO资源，数据库连接资源等。</p>
<p>　　资源清理一般在finally代码块里实现。</p>
<p>　　对于某些资源，如果在创建对象时就失败，就不需要清理了。可以用嵌套的try…catch语句实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"Cleanup.java"</span>));</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            in.close();</div><div class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　建议在所有创建资源对象的语句前后加上嵌套的try…catch语句。</p>
<p>　　当然，我们也可以不用这种嵌套，但必须在每次清理之前判断资源对象是否为null。</p>
<p>　　Java7还引入了一个新特性：try-with-resource。所有实现了java.lang.AutoCloseable的对象，都被视为资源。如果这些资源在try块内，则会在块结束之后自动被清理，不需要finally块，也不用显式地调用释放语句。</p>
<h3 id="使用finally的问题"><a href="#使用finally的问题" class="headerlink" title="使用finally的问题"></a>使用finally的问题</h3><ul>
<li>使用finally容易造成异常丢失。如果在catch前出现了finally语句，且finally语句内又抛出了异常，那么原try块内的异常会被取代，不会被捕捉。前一个异常还未处理，又抛出新异常，原异常会丢失。</li>
<li>如果在抛出异常时，finally内有return，则异常也会丢失。</li>
</ul>
<h3 id="异常处理的限制"><a href="#异常处理的限制" class="headerlink" title="异常处理的限制"></a>异常处理的限制</h3><ul>
<li>子类覆写的方法，抛出的异常必须在基类方法声明抛出的异常的范围内。</li>
<li>子类的构造器方法声明抛出的异常，必须含有父类构造器方法声明的异常。因为子类构造器必然会调用父类的某个构造器，无论是显式还是隐式。</li>
</ul>
<p>　　这种限制，也是源于Java的多态机制。因为子类对象会被向上转型为基类对象，必须保证在使用基类时能捕获子类所有的异常。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　要把异常处理好，需要很丰富的经验。以上只是异常处理的最基本知识。</p>
<p>　　</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从面向对象看JavaScript（五）—— 继承]]></title>
      <url>http://wjqwsp.github.io/2016/09/14/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BJavaScript%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94-%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h3 id="继承的本质"><a href="#继承的本质" class="headerlink" title="继承的本质"></a>继承的本质</h3><p>　　继承的初衷是复用。即已经有一个原始的类，希望在保留原始类的所有属性和方法的前提下，进行扩展或修改，以最大限度地降低开发成本。JavaScript实现继承，也是源自这个思想，即想办法让新的引用类型能够访问别的引用类型的所有属性和函数。<br><a id="more"></a></p>
<h3 id="原型链实现继承"><a href="#原型链实现继承" class="headerlink" title="原型链实现继承"></a>原型链实现继承</h3><p>　　回顾一下原型对象。原型对象与普通对象本质上没有任何区别，只是可以被对应实例对象的[[prototype]]指针指向，从而让所有实例对象都可以访问原型对象的属性和函数。而正是这一个特点，与继承的本质完全一致。换一个角度看，我们可以认为，实例对象继承了原型对象，所以可以访问它的所有属性和函数。</p>
<p>　　所以，我们甚至可以说，对象与对象的原型关系，就是继承关系。</p>
<p>　　那么，怎么让某一个新定义的引用类型继承另一个已经定义好的引用类型呢？很简单，只需要让他们建立原型关系。下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue());</div></pre></td></tr></table></figure>
<p>　　当调用SubType构造函数以后，会创建一个SubType实例对象，它存有SubType原型对象的指针，该原型对象默认是一个不含属性和函数的空对象。现在我们手动修改SubType构造函数的prototype指针，让它指向一个创建好的SuperType实例对象，从而通过SubType构造函数创建的实例对象的原型对象都是一个SuperType的实例对象，因此所有SubType实例对象都可以访问同一个SuperType实例对象的实例属性和方法，以及SuperType实例对象的原型对象的属性和方法。SubType原型对象的原型，就是SuperType的原型。继承就是这样实现的。</p>
<p>　　之前我们说过，所有引用类型都继承Object类型，JavaScript原生又是怎么实现这个继承关系的呢？跟上面的继承方式一样。在创建函数的时候，都会创建一个原型对象，这个原型对象初始是空白的，没有任何属性和函数，但是它却有[[prototype]]这个内部属性，指向同一个Object对象。所以，所有原型对象默认的原型都是Object。</p>
<p>　　这种原型的原型，就构成了原型链。通过不断延伸原型链，我们便可以实现多重继承。只要能够沿着原型链找到的引用类型，都可以通过instanceof操作符返回true，从而判断对象的类型。</p>
<h3 id="分离实例属性与原型属性"><a href="#分离实例属性与原型属性" class="headerlink" title="分离实例属性与原型属性"></a>分离实例属性与原型属性</h3><p>　　继承实际上是让原型对象的[[prototype]]指向下一个原型对象。回到前面几讲，我们希望让所有公共的属性与函数，都放在原型上，让所有各不相同的属性都定义在实例上。在进行原型链的构造时，为了满足这个需求，我们需要对实例属性和原型属性进行分离。下面给出继承的一般方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype  = object(superType.prototype);</div><div class="line">    prototype.constructor = subType;</div><div class="line">    subType.prototype = prototype;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.color = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">inheritPrototype(SubType,SuperType);</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　我们构造一个对象让它继承SuperType.prototype,然后让这个对象作为SubType的原型，从而构造了一条原型链。而让原来在SuperType实例上定义的所有属性都定义在SubType的实例上，而方法则全部定义在原型上，从而实现了实例属性与原型属性的分离。</p>
<h3 id="再看垃圾回收机制的标志清除策略"><a href="#再看垃圾回收机制的标志清除策略" class="headerlink" title="再看垃圾回收机制的标志清除策略"></a>再看垃圾回收机制的标志清除策略</h3><p>　　我们介绍了两条链，一条作用域链，一条原型链。回顾标志清除策略，其实搜索对象就是分别沿着这两条链寻找。通过作用域链，找到执行环境中的所有变量与函数。而通过原型链，则找到执行环境中的变量引用的所有变量与函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　实现继承，关键在于让被继承的引用类型的原型对象插入到原型链中。继承关系，实质上就是一个原型对象到另一个原型对象通过[[prototype]]指针的连接关系。</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从面向对象看JavaScript（四）—— 内存管理]]></title>
      <url>http://wjqwsp.github.io/2016/09/14/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BJavaScript%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　与java类似，JavaScript也有两种垃圾回收方式，分别是标记清除和引用计数。目前基本上都是使用标记清除的方式，引用计数存在循环引用的问题，实际中很少使用，但IE中的BOM和DOM对象却是用引用计数方式来做垃圾回收，非常容易造成内存泄漏。<br><a id="more"></a></p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>　　垃圾回收器会给所有存储在内存中的变量都打上标记，然后去掉所有在执行环境中的变量，以及被环境中的变量所引用的变量的标记。剩下还有标记的变量就是垃圾回收器将会回收的变量。</p>
<p>　　对比java中的标记清除策略，java会从堆栈和静态存储区开始，遍历所有引用，对每一个引用，再追踪它引用的每个对象，然后对每个对象再追踪它引用的下一层对象。如此层层深入，最终能遍历所有“活”的对象，其余对象则在下一次垃圾回收器工作时被回收。</p>
<p>　　不难看出，这两种语言的标记清除策略是一回事。JavaScript执行环境中的变量就相当于java堆栈和静态存储区的变量。</p>
<p>　　如果采用这种回收策略，我们基本不用担心内存泄漏的问题。因为只要函数作用域结束了，自然会退出执行环境。只要变量不在执行环境中，即便存在循环引用，也会被垃圾回收器回收。只有全局环境下的变量和函数在程序运行的整个周期都不会被回收，如果不用的话，需要手动设为null。另外，闭包由于会保留其上级函数的变量对象，使得垃圾回收器无法清除相关的变量和函数，因此会占用较多的内存，所以使用闭包时要注意。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>　　对内存中的每一个对象都记录其引用数，只要其引用数为0，则会被垃圾回收。但是如果存在循环引用，则会造成内存泄漏：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    <span class="keyword">var</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    objectA.someOtherObject = objectB;</div><div class="line">    objectB.anotherObject = objectA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　我们记problem函数里定义的两个对象为对象A和对象B。如果调用problem函数，则在函数结束前，对象A和对象B的引用数均为2。在执行结束后，objectA和objectB这两个引用由于存在堆栈里，会马上被释放。但对象A仍然被对象B的anotherObject属性引用；对象B也仍然被对象A的someOtherObject属性引用。所以这两个对象将永远不会被释放。</p>
<p>　　如果大量调用problem函数，那么将会导致大量内存不能被回收。</p>
<p>　　值得开心的事，这种引用计数方式已经基本不被采用。但IE的BOM和DOM对象仍然是用这种策略来进行垃圾回收的。因此使用BOM和DOM对象时要加倍小心，防止循环引用的发生。下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</div><div class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">myObject.element = element;</div><div class="line">element.someObject = myObject;</div></pre></td></tr></table></figure>
<p>　　element是DOM元素，它和myObject存在循环引用问题。在使用完毕DOM或BOM对象后，要记住将它们的引用设为null。</p>
<h3 id="闭包的循环引用问题"><a href="#闭包的循环引用问题" class="headerlink" title="闭包的循环引用问题"></a>闭包的循环引用问题</h3><p>　　如果同时使用闭包和DOM或BOM对象，那么更加要留心循环引用的问题了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</div><div class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(element.id);</div><div class="line">    &#125;；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　元素的点击事件函数的内存属性[[scope]]指向的作用域链里保存了assignHandler的活动对象，该活动对象里存在element的引用。同时。element的onclick属性也引用了点击事件函数。不难看出，闭包的循环引用往往是由其作用域链产生的。</p>
<p>　　我们可以这样修改代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</div><div class="line">    <span class="keyword">var</span> id = element.id;</div><div class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(id);</div><div class="line">    &#125;；</div><div class="line">    element = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　谨记及时将DOM或BOM的引用手动设为null。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　关于JavaScript的内存管理，只需要掌握两种垃圾回收策略即可。特别要注意闭包和DOM,BOM对象，注意循环引用。及时手动切断引用与DOM,BOM对象，全局环境下的对象的联系。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从面向对象看JavaScript（三）—— 属性权限管理]]></title>
      <url>http://wjqwsp.github.io/2016/09/14/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BJavaScript%EF%BC%88%E4%B8%89%E2%80%94%EF%BC%89%E2%80%94%E2%80%94-%E5%B1%9E%E6%80%A7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="对象的私有成员"><a href="#对象的私有成员" class="headerlink" title="对象的私有成员"></a>对象的私有成员</h3><p>　　原文再续，书接上一回。第一讲里我们提到怎么定义类，怎么创建对象。但在这些对象上创建的属性与方法，都是能被直接访问的，JavaScript并没有提供private,public,protected等属性的权限管理机制。但是，利用闭包我们完全可以实现对象属性和方法的私有化管理。<br><a id="more"></a></p>
<h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>　　在讲私有化管理之前，我们必须再讲一下作用域有关的知识。JavaScript只有全局作用域与函数作用域，而没有块级作用域。但我们可以用匿名函数来模仿块级作用域。</p>
<p>　　在任意作用域中，我们可以用以下代码实现一个短暂的函数作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>　　只要闭包不作为返回值返回，它的变量对象，执行环境与作用域链就会在执行后销毁。而匿名函数也没有被任何标识符引用，因此在退出执行环境后函数对象也会被垃圾回收。上面的代码在定义了匿名函数的同时马上执行，就能够模拟块级作用域的效果。</p>
<p>　　这种技术经常用在全局作用域中，避免向全局作用域添加过多的变量和函数。</p>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>　　由第二讲知道，某个执行环境中不能访问其作用域链以外的变量和函数。根据这个特点，我们可以把变量放在一个只能由公共接口函数访问的作用域中，这些变量便自然只能被特定的公共接口访问，而不能被直接访问，从而实现了私有化。看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        privateVariable++;</div><div class="line">        <span class="keyword">return</span> privateFunction();</div><div class="line">    &#125;;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　publicMethod函数作为闭包，可以访问privateVarialbe以及privateFunction，但其他函数和变量由于无法看到MyObject这个作用域，所以只能通过publicMethod间接访问，由此实现了私有变量，私有函数以及公共接口。但由于publicMethod是定义在实例上而不是在原型上，因此每创建一个实例都会创建一个publicMethod方法。</p>
<h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><p>　　通过将公共接口定义在原型上，可以实现静态私有变量，让所有实例都共享同一个私有变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">""</span>;</div><div class="line">    Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>　　也是利用了闭包的作用域链的特点，实现静态私有变量，只不过是把公共接口定义在原型对象上。但这样的话私有变量必须被所有实例对象共享，还是要根据需求来选择定义私有变量或者静态私有变量。</p>
<h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>　　以上说的都是自定义类型的私有变量和公共方法。但有时候我们不想定义新的类型，在整个系统中只需要对象的一个实例。那么我们可以用模块模式来定义单例对象的私有变量和公共方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</div><div class="line">    object.publicProperty = <span class="literal">true</span>;</div><div class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        privateVariable++;</div><div class="line">        <span class="keyword">return</span> privateFunction();</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>　　也是通过一个模仿块级作用域里定义的私有变量，私有方法以及闭包来实现的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　闭包是实现对象私有变量和私有函数的最重要的技术。关键在于把要保护的变量和函数放在一个特定的作用域内，而这个作用域只存在于公共接口函数的作用域链中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从面向对象看JavaScript（二）]]></title>
      <url>http://wjqwsp.github.io/2016/09/13/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BJavaScript%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h3><p>　　原文再续，书接上一回。话说讲到JavaScript对象里拥有属性与函数，上一讲介绍了属性，这一讲重点讲一讲函数。JavaScript的函数与Java的方法还是有很多不一样的地方，最主要的一点是，JavaScript的函数也是对象。它也可以拥有自己的属性与方法，它可以作为值像一般属性一样传递，成为其他函数的参数或者返回值。<br><a id="more"></a></p>
<h3 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a>函数的定义方式</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　相当于创建了一个函数对象，名字为sum的引用作为指针指向这个函数对象。与后面函数表达式的定义方式表示的意义完全等同。</p>
<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>　　这种方式定义有一个缺点。如果用函数声明定义函数，那么JavaScript解释器会进行函数声明提升，即在代码开始执行前，把所有函数声明提到所有代码的前面，因此，即便函数调用在函数声明之前，也能正确执行，不会出错。但采用函数表达式定义函数，则没有提升的效果。</p>
<h4 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h4><p>　　在JavaScript里，函数是一种原生对象类型，Function类型。可以用上一讲我们介绍的构造函数方式创建对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>,<span class="string">"num2"</span>,<span class="string">"return num1 + num2"</span>);</div></pre></td></tr></table></figure>
<p>　　最后一个参数是函数体，前面的全部作为函数的传入参数。不推荐用这种方式定义函数，因为会导致两次解析代码，影响性能。第一次解析常规的JavaScript代码，第二次解析字符串。</p>
<h3 id="函数传递与函数调用"><a href="#函数传递与函数调用" class="headerlink" title="函数传递与函数调用"></a>函数传递与函数调用</h3><p>　　如果在函数名后面加上()，则代表调用这个函数。如果没有这个括号，则表明将函数作为对象值传递，可以作为其他函数的参数值传入其他函数，也可以作为其他函数的返回值返回函数。</p>
<p>　　当函数作为值时，与其他对象属性没有任何区别，可以赋值给其他引用，也可以将函数引用设为null，提示内存的垃圾回收系统将其清理。</p>
<h3 id="两种函数对象"><a href="#两种函数对象" class="headerlink" title="两种函数对象"></a>两种函数对象</h3><p>　　定义的函数对象，与被调用后的函数对象，在JavaScript里是两个概念，是两个不同的对象。我们一般说的函数对象，是指用上面方法定义的函数。但是，当我们调用函数时，还会另外产生一个对象，通常称为变量对象，当其正被调用时，也称为活动对象。下面，我将分两大部分，分别介绍这两种对象。</p>
<h4 id="定义好的函数对象"><a href="#定义好的函数对象" class="headerlink" title="定义好的函数对象"></a>定义好的函数对象</h4><p>　　这种函数对象，就是一般我们能访问的函数对象，拥有与其他普通对象一样的特性，可以有自己的属性与函数，并且能够直接访问这些属性和函数。</p>
<h5 id="常用的属性"><a href="#常用的属性" class="headerlink" title="常用的属性"></a>常用的属性</h5><h6 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h6><p>　　类数组对象，每个函数都有这个对象，函数被定义后，初始值为null。当函数被调用时，传入函数的参数全部推入这个arguments对象里，可以按数组的索引方式访问所有传入参数。当函数调用结束后，arguments又被设为null。</p>
<p>　　可以用arguments.length得到传入参数的个数。</p>
<p>　　在定义函数时，我们往往会指定一些参数的名字，我们称为命名参数。命名参数只是arguments相应位置的参数的别名。因此，命名参数的个数与实际调用时可以传递的参数数目完全无关，只是方便引用传入参数而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　仍以sum函数为例。num1,num2是两个命名参数，但实际调用时，我们可以传入任意数量的参数，也可以不传入参数。我们可以用arguments[0]代替num1,用arguments[1]代替num2，也可以用arguments[3],argument[4]等引用更多传入的参数。</p>
<p>　　正是由于这个特性，JavaScript不存在函数重载，因为命名参数根本不能起到标识函数的作用。如果试图进行重载，那么只有最后一个函数才生效，其余都被覆盖。这是因为函数也是对象，相当于将同一个函数引用先后指向多个对象，显然只有最后一次赋值才是最终的值。</p>
<p>　　arguments.callee指向拥有该arguments对象的函数。如果是递归调用函数的话，可以用arguments.callee代替函数名，达到函数的执行与函数名解耦合的效果。但在严格模式下，访问arguments.callee会出错。</p>
<h6 id="length"><a href="#length" class="headerlink" title="length"></a>length</h6><p>　　length属性表示函数的命名参数的个数。</p>
<h6 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h6><p>　　原型属性，每一个函数都有的一个属性，指向其原型对象。</p>
<h6 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h6><p>　　保存着调用当前函数的函数的引用。如果在全局环境中调用函数，则为null。caller初始值为null，调用后也为null，只有在调用时才有值。</p>
<h6 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h6><p>　　则是函数对象的两个方法，当调用这两个方法时，函数会被调用，并且把this设置为指定的值，这个指定的值是在这两个方法的传入参数里指定的。这两个方法的具体用法就不详细说明了，非常简单，有兴趣可以另外查阅资料。this也是一个函数属性，但是是变量对象里的属性，不是定义好的函数属性。这我放在后面再介绍。</p>
<h6 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h6><p>　　不同函数可能会自己定义一些方法，例如上一讲提到的Object.defineProperty，Object.getOwnPropertyDescriptor等，都是在Object构造函数上定义的函数。</p>
<h4 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h4><p>　　当执行调用函数指令之后，内存里会产生一个变量对象，相当于从定义好的函数对象中激活出来一个新的特殊的函数对象。需要说明的是，变量对象并不都是函数对象，例如全局环境的window对象等，后面会再稍微提及一下。但变量对象的确主要是函数对象。要认识变量对象，先得从作用域链说起。</p>
<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>　　JavaScript只有全局作用域和函数作用域，没有块作用域。每个作用域都由一个变量对象表示。作用域链就相当于函数的调用栈。下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> tempColor = anotherColor;</div><div class="line">        anotherColor = color;</div><div class="line">        color = tempColor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    swapColor();</div><div class="line">&#125;</div><div class="line"></div><div class="line">changeColor();</div></pre></td></tr></table></figure>
<p>　　每个定义好的函数都有一个[[scope]]的内部属性，用来保存该函数调用前的作用域链。作用域链保存的就是变量对象。每个变量对象都维护一个作用域。</p>
<p>　　changeColor()调用前，它本身的变量对象还没有创建，没有被加入它的作用域链中，[[scope]]里只包含全局变量对象window。</p>
<p><img src="/img/scope1.jpg" alt="scope"></p>
<p>　　当调用changeColor后，调用swapColor前，会为changeColor创建一个执行环境，并复制changeColor的[[scope]]属性，赋值给该执行环境的作用域链，并在作用域链的前端插入由changeColor激活的一个变量对象。同时定义好的swapColor函数对象的[[scope]]内部属性，也会创建一个新的作用域链，包含全局作用域以及changeColor函数作用域。</p>
<p><img src="/img/scope2.jpg" alt="scope"></p>
<p>　　我们看到，在changeColor函数里定义的所有变量和函数都作为变量对象的属性和函数保存。changeColor的执行环境里可以直接访问changeColor变量对象的所有属性和方法，而不用以“changeColor变量对象.属性”或“changeColor变量对象.函数”的方式访问。实际上，除了window对象以外，JavaScript也不允许我们访问变量对象，只有解析器能够在后台访问它。由于changeColor的作用域中也包含全局变量对象，因此可以直接访问全局对象的所有属性和方法，而不用显式地用window.属性或window.函数来访问。</p>
<p>　　changeColor的变量对象也包含arguments对象，由于changeColor是window对象的函数，因此this指向window对象。这里再回顾一下上面提到的call和apply方法，调用定义好的函数的这两个方法，可以在创建变量对象时让this指向特定的对象，而不是默认地指向该函数所属的对象。如此，可以让方法与对象完全解耦合。</p>
<p>　　当swapColor函数调用之后，它也会从swapColor的内部属性[[scope]]中复制作用域链，并且创建一个变量对象，插入到作用域链的前端。swapColor函数内可以直接访问其本身的变量对象，changeColor变量对象以及全局变量对象的所有属性与方法。</p>
<p><img src="/img/scope3.jpg" alt="scope"></p>
<p>　　需要说明一点，swapColor的this指向的是window对象，它本身是changeColor变量对象的函数，但除window以外的变量对象是不能被访问的，它又不属于其他普通对象，因此仍被视为由window调用。</p>
<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>　　一般函数调用结束后，它的执行环境和作用域链都会被销毁，它的变量对象也会被销毁。但闭包是一个例外。</p>
<p>　　在JavaScript中，闭包是指有权访问另一个函数作用域中的变量的函数。通俗来说，就是在函数里面定义的函数。当闭包作为值被函数返回到再上一级的作用域时，由于它的[[scope]]仍然引用着上一级函数的变量对象，因此这个变量对象不会被销毁。下面修改一下上面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> tempColor = anotherColor;</div><div class="line">        anotherColor = color;</div><div class="line">        color = tempColor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    swapColor();</div><div class="line">    <span class="keyword">return</span> swapColor;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> swap = changeColor();</div></pre></td></tr></table></figure>
<p>　　本来，当changeColor执行结束以后，它的变量对象会被销毁。但由于swapColor的[[scope]]指向的作用域链引用了changeColor的变量对象，而swapColor还被window对象的swap属性引用了，因此不会被销毁，而只销毁changeColor本身的作用域链以及执行环境。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　这一讲主要介绍了函数对象，并重点分析了函数变量对象，以及引申出的作用域链以及闭包等知识点。下一讲将继续总结闭包的知识，总结一下怎么利用闭包与函数作用域来实现对象属性与方法的私有化，从而达到像java或c++的private权限控制的效果。欲知后事如何，请看下回分解。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从面向对象看JavaScript（一）]]></title>
      <url>http://wjqwsp.github.io/2016/09/13/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BJavaScript%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　JavaScript作为一种脚本语言，语法简单（求其），易上手，适合开发；同时，作为当今前端编程方面占据垄断地位，甚至逐步向后端发展的强势语言，它的前景十分美好，功能足够强大。既然是脚本语言，自然没有c,c++,Java等传统语言的严谨，但是利用它仍然可以基本覆盖其他语言能做到的高级功能。</p>
<p>　　下面我就从面向对象的角度，整合JavaScript里函数，对象，引用类型，原型，闭包，作用域链等知识点，去探讨JavaScript是如何定义对象，构造类，设置属性和函数的私有公有权限，实现继承，利用作用域以及管理内存的。下面的代码例子基本都出自《JavaScript高级程序设计》。<br><a id="more"></a></p>
<h3 id="创建单个对象"><a href="#创建单个对象" class="headerlink" title="创建单个对象"></a>创建单个对象</h3><p>　　与Java类似，JavaScript的所有对象都继承自Object类，我们可以在Object类的基础上扩展对象的属性与函数，从而创建出一个新的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"Nicholas"</span>;</div><div class="line">person.age = <span class="number">29</span>;</div><div class="line">person.job = <span class="string">"Software Engineer"</span>;</div><div class="line"></div><div class="line">person.sayName() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>　　对象包含属性与函数，可以直接在Object类对象上扩展。</p>
<p>　　用对象字面量的方式，可以更简单地定义对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    name: <span class="string">"Nicholas"</span>,</div><div class="line">    age: <span class="number">29</span>,</div><div class="line">    job: <span class="string">"Software Engineer"</span></div><div class="line"></div><div class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4><p>　　对象包含属性与函数，其中函数在JavaScript里也可以视为一种特殊的属性，会在下一节重点讲述。这里先总结一下属性，属性可以分为数据属性与构造器属性。</p>
<h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>　　JavaScript里的每一个属性都有一些特征，相当于是属性的属性，用于JavaScript底层维护属性。数据属性有4个特性，分别是Configurable,Enumerable,Writable与Value，规范里记为[[Configurable],[[Enumerable]],[[Writable]],[[Value]]。这些特性是不能直接访问的。</p>
<ul>
<li>[[Configurable]]：能否通过delete删除属性，能否修改属性特性，能否把属性修改为访问器属性。如果像上面直接在对象上创建属性，则默认为true。</li>
<li>[[Enumerable]]：能否通过for-in语法循环返回属性，默认为true。</li>
<li>[[Writable]]：能否修改属性的值，默认为true。</li>
<li>[[Value]]：属性的数据值，默认为undefined，像上面创建属性后就保存属性的值。</li>
</ul>
<p>　　除了直接在对象上创建属性以外，还可以通过Object.defineProperty()方法创建属性。这个方法接收3个参数，分别是属性所在对象，属性的名字，以及一个描述符对象。描述符对象的属性必须是configurable,enmuerable,writable和value。通过这个描述符对象，则可以定义属性的一或多个特性。在这种情况下，configurable,enumerable和writable默认为false。</p>
<p>　　这里要注意一点是，当把configurable设置为false，则不能再设置属性的特性，包括不能将configuralble重新设为true。</p>
<h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>　　访问器属性也具有[[Configurable]]和[[Enumerable]]特性，但没有[[Writable]]和[[Value]]，而替换为[[Get]],[[Set]]。[[Get]]和[[Set]]保存相应的函数，默认为undefined。当用一般的JavaSript读写该属性时，则会分别调用[[Get]]和[[Set]]里保存的函数，从而返回或写入相应的值。这就相当于Java里的getter和setter方法。只定义getter则不能写，只定义setter则不能读。访问器属性只能通过Object.defineProperty方法定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    _year: <span class="number">2004</span>,</div><div class="line">    edition: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>)&#123;</div><div class="line">            <span class="keyword">this</span>._year = newValue;</div><div class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.year);</div></pre></td></tr></table></figure>
<p>　　第一次访问book.year是写数据，调用setter方法，第二次访问book.year是读数据，调用getter方法。在Java里，getter和setter往往是针对私有属性的，用于向外界提供访问私有属性的一个公共接口，但访问器属性我觉得并不是为了这个目的而产生的。访问器属性，往往与一个数据属性相关联，例如这里的_year。这里_year前面的下划线是一种规范，用于表示与某个访问器属性相关联的数据属性。访问器属性是用于在设置一个属性的同时，导致其他属性的变化，这是它的最主要作用。至于私有公有属性的权限设定，则是由另外的技术实现的，这我也将会在后面几讲阐述。</p>
<h5 id="同时定义多个属性"><a href="#同时定义多个属性" class="headerlink" title="同时定义多个属性"></a>同时定义多个属性</h5><p>　　可以用Object.defineProperties()方法，这个方法接收两个对象参数，一个是要添加和修改其属性的对象，另一个对象包含多个对象属性，每个属性与要添加或修改的属性一一对应，这些对象属性里的属性则是要定义的属性特性。</p>
<h5 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h5><p>　　用Object.getOwnPropertyDescriptor()方法可以获取给定属性的描述符，这个描述符对象的属性则是相应属性的特性。这个方法接收两个参数，分别是属性所在的对象和其描述符的属性名称。</p>
<p>　　这个描述符对象的属性便是原对象对应属性的特性。
　　</p>
<h3 id="构造类"><a href="#构造类" class="headerlink" title="构造类"></a>构造类</h3><h4 id="简易生产对象——工厂模式"><a href="#简易生产对象——工厂模式" class="headerlink" title="简易生产对象——工厂模式"></a>简易生产对象——工厂模式</h4><p>　　如果按照上面创建对象的方法，那么每次创建具有相同属性和方法的对象，都需要手动写一遍重复的代码。我们希望像其他面向对象语言一样，有“类”的概念，可以通过一个封装好的方法，批量地生成同一类型的对象。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>　　creatPerson就是一个工厂方法，封装了创建对象的代码，使得批量生产对象变得十分简单。</p>
<p>　　但是，工厂模式存在两个主要的问题。第一个是虽然能够封装创建对象的代码，但是仍然不能将这个对象称为“类”，无法识别这些具有相同属性类型和方法的对象是属于同一个类的；第二个是，一般的面向对象语言，属于同一类的对象共享同一套方法，但属性则各有不同。具体到内存里，以java为例，它的类里的实例方法都是存储在代码区的，同一类的不同对象是共享代码区的相同方法的，而属性则存储在堆栈或堆里，各个对象不同。</p>
<p>　　JavaScript作为成熟的面向对象语言，这两个问题当然是可以解决的。下面我们分别来分析一下。</p>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>　　构造函数本身与普通函数是没有区别的。按照惯例，构造函数一般以大写字母开头，普通函数则以小写字母开头。如果不用new操作符，则调用构造函数与调用普通函数没有任何区别。如果调用了new操作符，且构造函数内部没有return，则会经历以下四个步骤：</p>
<ol>
<li>创建一个新对象。</li>
<li>将构造函数的作用域赋给新对象。（this指向新对象）</li>
<li>执行构造函数中的代码。</li>
<li>返回新对象</li>
</ol>
<p>　　<br>　　利用构造函数生成的对象，都有一个constructor属性，指向Person函数。我们可以用这个属性来作为类判别的依据。但更可靠的做法是用instanceof操作符，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></div><div class="line">alert(person1 <span class="keyword">instanceof</span> Person);  <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>　　由于Person类继承自Object类，因此person1既可以说是Object类的对象，也可以说是Person类的对象。</p>
<h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>　　每当创建一个新函数，该函数都自动获得一个prototype属性，该属性指向函数的原型对象。这个原型对象本身与普通的实例对象没有任何区别。通过构造函数创建的对象，都会含有一个内部属性[[prototype]]，这个内部属性不能直接访问，其指向构造函数的原型对象。显然，所有通过该构造函数创建的对象，都有这么一个指针指向同一个原型对象。我们访问实例对象的属性和方法，会先看看实例对象有没有相应的属性或方法，没有的话再从原型对象上找。因此，我们可以把类里的实例方法以及共有的属性都定义在原型对象上，而把每个实例对象都不同的属性定义在实例上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</div><div class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<p>　　sayName方法定义在原型对象上，其他属性则直接定义在实例对象上。为了更好地封装代码，动态原型模式把原型的属性和方法定义都包含在构造函数里，而没有放在构造函数外面进行。但这样存在一个问题，就是每创建一个实例，都会定义一个新的函数，因此我们需要通过一个判断语句，来判断sayName函数是否已被初始化。如果有多个函数定义在原型对象上，我们也只需要判断一个函数有没有被初始化就可以了，因为初始化都是一起进行的，一个函数初始化了说明其他函数也被初始化。</p>
<p>　　原型对象，实例对象，构造函数的关系：</p>
<p><img src="/img/prototype.jpg" alt="prototype"></p>
<p>　　由于访问对象的方法和属性时，是按照先实例对象再原型对象进行的，因此在实例对象上创建的同名属性或方法可以覆盖原型对象上的属性或方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　面向对象语言的最基本特点就是有对象，有类，类里面定义了属性和方法。这一讲简单地介绍了怎么创建对象，怎么构造类，以及引入了原型的概念，总结了怎么利用原型与构造函数来定义实例属性，实例方法和共享属性。关于JavaScript的面向对象设计部分，还有很多内容，欲知后事如何，请看下回分解。
　　
　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PostgreSQL MVCC机制浅析]]></title>
      <url>http://wjqwsp.github.io/2016/09/05/PostgreSQL-MVCC%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="从丢失更新说起"><a href="#从丢失更新说起" class="headerlink" title="从丢失更新说起"></a>从丢失更新说起</h3><p>　　上一讲提到了数据并发在数据库中的四大问题，其中一个便是丢失更新。丢失更新的产生是当两个事务同时读某一记录时，A事务先修改该记录，B事务再修改的时候把A的修改覆盖掉，导致A事务的更新丢失了。更具体的例子可以参考上一讲。数据库处理丢失更新有两种方法，分别是悲观锁方法与乐观锁方法。</p>
<h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p>　　对于某一特定的业务需求，如果实现该需求需要并发地更新数据库的同一记录，就有可能发生冲突。解决这种冲突可以选择两种办法，分别是悲观锁与乐观锁。<br><a id="more"></a></p>
<ol>
<li>悲观锁：悲观锁认为更新冲突是经常发生的，因此通过传统加锁的办法，让事务分别独占某一记录，解决并发的冲突。具体到丢失更新这一问题，悲观锁的解决方法有两个，第一是用select for update，手动加上排它锁，在整个事务周期内便不可能再允许其他事务修改或读取这一记录；第二是用Repeatable Read的事务隔离级别，让共享锁与排它锁的持有时间都是整个事务周期，便自然杜绝了并发更新的发生。</li>
<li>乐观锁：乐观锁认为更新冲突是几乎不会发生的，当发生冲突时便会阻碍，返回错误信息，让用户决定重新开启事务还是放弃。乐观锁的实现一般是应用程序级别的，数据库里很少提供这种实现。具体的方法是在所有元组后面都加上版本号属性，每次修改记录都会更新版本号。用户在读取记录的时候把版本号一同读出，在修改时候再判断版本号是否与原来的一致，一致则继续更新，否则说明有其他事务更新了该记录，返回错误。</li>
</ol>
<h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>　　MVCC，即多版本并发控制，是一种与传统锁机制有区别的一种控制并发的方法。从上一讲看到，事务隔离等级从低到高就是锁的不断增多的过程，必然导致性能的逐渐下降。而MVCC，则做到了读与读不冲突，读与写不冲突，只有写与写才需要锁去控制冲突。不同的读操作根据事务版本的不同，看到的视图是不一样的。因此即使事务A修改某一记录，事务B读到的记录是处于另一版本视图下的，与事务A的写操作自然隔离了，并不需要锁的控制。这种多版本控制读操作视图的方法，在PostgreSQL里实际上是采用了乐观锁来实现的。下面我将先阐述PostgreSQL里MVCC是如何与事务隔离等级结合起来的，然后再仔细分析MVCC的实现原理，由表到里地分析PostgreSQL里的MVCC机制。</p>
<h3 id="PostgreSQL-MVCC与事务隔离等级"><a href="#PostgreSQL-MVCC与事务隔离等级" class="headerlink" title="PostgreSQL MVCC与事务隔离等级"></a>PostgreSQL MVCC与事务隔离等级</h3><p>　　上一讲我们讲到了数据库的事务隔离等级要求，但这只是最低的要求，实际上具体数据库的实现可以更加严格，每个数据库的实现机制与锁控制方式也大相径庭。下面我们先来看看PostgreSQL的事务隔离等级是怎么样的：</p>
<table>
<thead>
<tr>
<th>Isolation Level</th>
<th>Dirty Read</th>
<th>Nonrepeatable Read</th>
<th>Phantom Read</th>
<th>Serialization Anomaly</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read uncommitted</td>
<td>Allowed, but not in PG</td>
<td>Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>Read committed</td>
<td>Not possible</td>
<td>Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>Repeatable read</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Allowed, but not in PG</td>
<td>Possible</td>
</tr>
<tr>
<td>Serializable</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Not possible</td>
</tr>
</tbody>
</table>
<p>　　从上表可以看到,PostgreSQL的事务隔离等级更加严格。它实际上只有3个隔离等级。如果选择了Read uncommited，相当于选择了Read commited，因为Read uncommited也是不允许脏读的。而Repeatable read级别在postgreSQL里也不存在幻读。除此以外，这里还引入了一个新的数据冲突问题：序列化异常。Serializable与Repeatable read在postgreSQL里是基本一样的，除了Serializable不允许序列化异常。关于不同事物隔离等级的具体细节，下面将一一介绍。</p>
<h4 id="Read-commited"><a href="#Read-commited" class="headerlink" title="Read commited"></a>Read commited</h4><p>　　主要看看Read commited是怎么解决脏读的。当事务处于这一隔离等级时，每次读写操作前都会对目前数据库拍一个快照，这个快照就是在当前读写操作发生前，所有已提交的事务对数据库做出的所有更改的结果。因此，在读操作进行时其他事务发生的更改都不会影响这个快照。而由于这个快照包含的是所有已提交的更改结果，因此其他未提交的事务作出的所有更改都不会被当前读操作看到，从而避免了脏读的发生。这就让读与写彻底分离开来，因为读写操作看到的数据库是不一样的。要注意的是，当前事务对数据库作出的修改会影响快照，可以被当前事务的读操作读到修改后的元组。</p>
<p>　　那么写与写冲突怎么办呢？</p>
<p>　　实际上，对某一记录的写操作在postgreSQL里仍然是加锁的，只是这个锁只阻塞写，不阻塞读。当事务A更改了某记录而未提交，事务B又要更改该记录时，事务B便会阻塞，直到事务A提交或回滚。如果事务A回滚，说明该记录的更新没有生效，则事务B继续正常更新该记录；如果事务A正常提交，事务B便需要判断原更新条件是否仍然生效，如果仍生效则继续B的更新，否则直接忽略B的更新。</p>
<p>　　然而对于某些较为复杂的查询，Read commited的级别是会产生一些问题的。下面我就分析一下官方文档给出的错误例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BEGIN</span>;</div><div class="line"><span class="keyword">UPDATE</span> website <span class="keyword">SET</span> hits = hits + <span class="number">1</span>;</div><div class="line"><span class="comment">-- run from another session:  DELETE FROM website WHERE hits = 10;</span></div><div class="line"><span class="keyword">COMMIT</span>;</div></pre></td></tr></table></figure>
<p>　　假设现在数据库有一个website表，该表有一个hit属性。目前数据库里该表只有两条记录，分别是hit=9与hit=10。现在又有两个事务，事务A进行update操作，事务B进行delete操作，如上面代码所示。update操作前会对数据库拍一个快照，此时快照里分别是hit=9和hit=10的两条记录，我们记为记录x与记录y，操作后记录x的hit=10，记录y的hit=11。delete操作前也会对数据库拍一个快照，因为快照仅包含已提交的事务产生的结果，因此此时快照里只有记录y（此时记录x的hit=9，记录y的hit=10）。由于存在并发更新，因此事务B的delete会阻塞。当事务A提交后，记录y的hit=11，已经不满足事务B的delete的条件，因此事务B的delete操作失败。而实际上，我们更希望事务B能把记录x（由于事务A的更新此时记录x的hit为10）删除，但由于事务B的快照里不包含记录x，因此会被忽略。</p>
<h4 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h4><p>　　postgreSQL的Repeatable read解决了重复读与幻读的问题。当事务处于这一隔离等级下时，每次事务开启后进行的第一个读写操作前拍摄快照，此后在整个事务周期沿用这个快照，而不是在每一条读写操作前拍摄快照。因此，当事务A开启后，即便事务B对事务A读取的记录作出更改并提交，也不会影响事务A的快照。事务A由始至终读取的结果都是一样的。这个过程完全不需要锁的控制，两个事务都是并发进行的，并且互不影响，因为两个事务都是对自己拍摄的数据库快照操作。与Read commited一样，当前事务作出的修改会影响快照。</p>
<p>　　写与写的冲突仍和Read commited一样，通过加锁阻塞控制的。Repeatable read对于并发更新冲突更加严格，仍以事务A与事务B为例，当事务A更改了某记录而未提交，事务B又要更改该记录时，事务B便会阻塞，直到事务A提交或回滚。如果事务A回滚，说明该记录的更新没有生效，则事务B继续正常更新该记录；如果事务A正常提交，无论事务B的更新条件是否仍然生效，都会直接抛出下面的异常：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR:  could not serialize access due to concurrent <span class="keyword">update</span></div></pre></td></tr></table></figure>
<p>　　用户捕捉到这种异常，可以自行选择是重新开启事务B还是放弃该事务操作。显然，这个就是典型的乐观锁控制并发的方法。</p>
<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>　　在postgreSQL里，这一隔离级别是伪串行化，并不是如上一讲所说的最强封锁协议，即什么都加锁，什么都真正串行处理。但是，postgreSQL这一隔离等级下它的功能表现得与真正的串行化别无二致，用户可以直接认为所有事务都是串行化执行。实际上它的隔离机制与Repeatable read相差无几，无论是快照拍摄的时机还是并发更新冲突的处理都是一样的。唯一的区别便在于前面提到的Serialization Anomaly这一问题。</p>
<p>　　我们知道Repeatable read在事务开启后的第一个读写操作前拍摄快照，因此在该事务操作里其他事务的结果对当前事务都是毫无影响的。然而，有些业务场景下，事务与事务之间有可能存在依赖关系，我们需要所有事务都是串行化执行的。下面就以官方文档的例子为例，分析一下Serializable在postgreSQL里究竟有何神奇之处：</p>
<p>　　假设数据库里有一个mytab表：</p>
<p><img src="/img/mytab.png" alt="mytab"></p>
<p>　　事务A：</p>
<p><img src="/img/transactionA.jpg" alt="transactionA"></p>
<p>　　事务B：</p>
<p><img src="/img/transactionB.jpg" alt="transactionB"></p>
<p>　　事务A提交：</p>
<p><img src="/img/transactionA-commit.jpg" alt="transactionA commit"></p>
<p>　　Serializable力图在众多并发事务中寻求一条串行关系，即虽然这些事务是并发执行的，但在所有事务提交以后，如果存在读写依赖关系，可以将它们按先后顺序排序，使得它们表现得宛如串行执行一般。如果这种先后顺序因为并发事务而变得自相矛盾，则会抛出异常。在上面的例子里，事务A对所有class=1的元组的value属性求和，得出30，并将其作为value=30,class=2的元组插入表中；此时，另一个并发事务B对所有class=2的元组的value属性求和，因为两个事务使用的是不同的快照，事务A的修改不会被事务B看到，因此得出300而不是330。这时候，数据库实际上作出了一个假设：即事务B发生在事务A之前，因为事务B读出的值表现得如同是事务A插入数据以前发生的，也即发生了写读依赖。然而，事务B后面再插入了一个value=300,class=1的元组并提交以后，问题就发生了。由于在事务A中对所有class=1的元组的value属性求和时，并没有看到事务B插入的元组，因此数据库作出了另一个假设：即事务B发生在事务A之后，因为事务A读出的值表现得如同是事务B插入数据以前发生，这又是一个写读依赖。</p>
<p>　　这两个前后的假设显然是矛盾的，所以事务A与事务B违反了串行化要求，所以后提交的事务会抛出异常，此时用户可以选择重启事务或者放弃该事务操作。</p>
<h4 id="MVCC在何处体现"><a href="#MVCC在何处体现" class="headerlink" title="MVCC在何处体现"></a>MVCC在何处体现</h4><p>　　看完上面postgreSQL里三个事务隔离等级的介绍，相信读者大致了解其特点与原理。那么，所谓的MVCC，即多版本并发控制，又是在何处体现呢？显然，就是前面说的“快照”。快照，其实就是相应的版本视图，不同的事务根据事务版本的不同，看到数据库的不同侧面，从而实现读写分离。postgreSQL里快照的抽取十分简单，关键在于两个系统属性：xmin和xmax。下面我将简单分析一下postgreSQL的MVCC实现机制。</p>
<h3 id="MVCC实现机制"><a href="#MVCC实现机制" class="headerlink" title="MVCC实现机制"></a>MVCC实现机制</h3><p>　　在PostgreSQL里，每一个表都默认附加上两个只读的系统属性，xmin和xmax，这两个属性的值共同成为多版本控制的判断条件，所谓快照，实际上就是xmin和xmax满足一定条件的元组集合。</p>
<h4 id="xmin"><a href="#xmin" class="headerlink" title="xmin"></a>xmin</h4><p>　　如果显示地声明了事务，那么每个事务会自动生成一个事务ID作为标识，即txid；如果没有显示声明，那么每一条独立的语句将生成一个事务ID。当进行insert操作时，插入表新增的元组会额外生成一个xmin属性，其值等于当前的事务ID。换言之，元组的xmin属性的值永远等于其插入表时的事务ID。</p>
<h4 id="xmax"><a href="#xmax" class="headerlink" title="xmax"></a>xmax</h4><p>　　当插入元组时，xmax属性默认为0，表示未定义。当对该元组进行update或delete操作时，当前事务ID的值会被赋给xmax。PostgreSQL删除元组不会真的从表里删除数据，而是用xmax&gt;0来标识该元组被删除。而更新元组也不会直接在原来的元组上进行修改，而分为两步进行：第一步是修改原元组的xmax为当前事务ID；第二步是插入一条新的元组，其所有属性值等于原来元组修改过后的值，xmin为当前事务ID，xmax初始化为0。</p>
<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>　　快照就是某时刻下数据库所有元组的xmin和xmax满足一定条件的值的集合。三个事务隔离等级拍摄快照的时机不同，但其判断条件都是一样的。</p>
<p>　　总结一下判断条件：</p>
<ol>
<li>若xmin等于当前事务ID，则包含所有xmax=0（未被删除）的元组。</li>
<li>若与xmin相等的事务ID对应的事务已经被提交，则包含所有xmax=0或xmax为当前事务ID的元组。</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>　　为了帮助读者理解，更好地阐述MVCC的机制，这里设计了一个实例。</p>
<h5 id="初始化准备"><a href="#初始化准备" class="headerlink" title="初始化准备"></a>初始化准备</h5><p>　　建立test表，插入几条数据，如图示：</p>
<p><img src="/img/test-init.png" alt="test init"></p>
<p>　　表中插入了两条数据，我们可以读出xmin与xmax的值，由于这两条记录是同一个事务插入的，所以xmin相等，等于该事务ID 332919，xmax为0，表示未定义。</p>
<h5 id="Read-commited事务隔离等级下测试"><a href="#Read-commited事务隔离等级下测试" class="headerlink" title="Read commited事务隔离等级下测试"></a>Read commited事务隔离等级下测试</h5><p>　　分别开启事务A，B，事务隔离等级取默认的Read commit。事务A向test表插入一条记录，事务A和事务B再分别读取test表，两事务均不提交。</p>
<p>　　事务A：</p>
<p><img src="/img/test-a-2-insert.jpg" alt="test A"></p>
<p>　　事务B：</p>
<p><img src="/img/test-b-2-insert.jpg" alt="test B"></p>
<p>　　事务A插入元组后，可以看到test表多了一条xmin为332919，xmax为0的新元组。事务B不能看到事务A插入的新元组。</p>
<p>　　事务A修改id=1的元组，事务A和B分别读取test表，两事务均不提交。</p>
<p>　　事务A：</p>
<p><img src="/img/test-a-2-update.jpg" alt="test A"></p>
<p>　　事务B：</p>
<p><img src="/img/test-b-2-update.jpg" alt="test B"></p>
<p>　　事务A可以看到id为1的元组被修改了，此时它的xmin已经不是332919而是332920；而事务B仍然只能看到id=1的元组的value为aaa，没有改变，只是xmax设为332920。说明事务A看到update操作后新增的那条元组，而看不到原来的那条元组；事务B只看到原来的那条元组，而看不到新增的那条元组。</p>
<p>　　由此可见，Read commited事务隔离等级下不存在脏读。</p>
<p>　　事务A提交，事务B再读取test表。</p>
<p>　　事务A：</p>
<p><img src="/img/test-a-2-commit.jpg" alt="test A"></p>
<p>　　事务B：</p>
<p><img src="/img/test-b-2-commit.jpg" alt="test B"></p>
<p>　　事务A提交以后，事务B读到了事务A新增以及修改的元组。由此可见，Read commited事务隔离等级下存在不可重复读。</p>
<h5 id="Repeatable-read事务隔离等级下测试"><a href="#Repeatable-read事务隔离等级下测试" class="headerlink" title="Repeatable read事务隔离等级下测试"></a>Repeatable read事务隔离等级下测试</h5><p>　　将事务A与事务B提交，重新开启两个事务，其事务隔离等级设为Repeatable read，记为事务C与事务D，分别读取test表。</p>
<p>　　事务C：</p>
<p><img src="/img/transaction-cd-begin.jpg" alt="test C"></p>
<p>　　事务D：</p>
<p><img src="/img/transaction-cd-begin.jpg" alt="test D"></p>
<p>　　事务C修改test表id=2的元组并提交。事务D读取test表。</p>
<p>　　事务C：</p>
<p><img src="/img/test-c.jpg" alt="test C"></p>
<p>　　事务D：</p>
<p><img src="/img/test-d.jpg" alt="test D"></p>
<p>　　即便事务C提交了，事务D仍然只看到原来未修改前的元组，只是其xmax由0变成332921，即事务C的ID。可见Repeatable read事务隔离等级下不存在不可重复读。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　PostgreSQL的MVCC的多版本并发控制技术，用无锁技术控制并发，很好地解决了并发与性能的矛盾，使系统既能够控制并发冲突，又不会因为频繁加锁导致性能恶化。它的快照技术，仅仅通过xmin与xmax两个系统属性简单的判断便可实现，快照的拍摄完全没有时间与空间的消耗。事务的回滚非常方便，仅仅需要修改xmin和xmax属性即可。</p>
<p>　　但是，这种机制仍然有它的缺点。由于删除并不会真的在表里删除记录，更新操作也是通过插入新记录实现，那么表里会存在许多废旧的记录，占据存储空间，影响查找性能。PostgreSQL里有垃圾清除策略，会维护一个进程专门定期地清理过期的记录，但这个清理周期是不确定的，因此无用的废旧记录仍然会影响数据库的性能。</p>
<p>　　以上只是PostgeSQL并发控制的一部分知识，关于PostgreSQL的锁机制还有相当多的内容，其MVCC机制里除了xmin与xmax还有cmin与cmax两个系统属性没有涉及。由于篇幅所限，我对这部分理解也不是很足，这里就先不介绍了。以后有机会，我再另外写文章进行讲述。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库事务隔离级别与锁机制实现（转载）]]></title>
      <url>http://wjqwsp.github.io/2016/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>　　数据库并发处理是一个非常重要的问题，其实现本质上同应用程序一级的并发控制原理是一致的，也是通过加锁解决。而事务隔离级别相当于一段独立的代码块，具有原子性、一致性、隔离性、持久性4个特征。本来想自己写一篇总结，但看到有一篇文章总结得非常好，就直接转载过来。</p>
<p>　　以下内容转载自：<a href="http://www.songjie.info/" title="宋杰的站点" target="_blank" rel="external">宋杰的站点</a> » <a href="http://www.songjie.info/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" title="【转载】数据库事务隔离级别和锁实现机制" target="_blank" rel="external">【转载】数据库事务隔离级别和锁实现机制</a></p>
<p>　　原文的版式我修改了一下，有些跟核心内容无关的我删去了，某一两处内容我觉得不对的在后面加了备注。<br><a id="more"></a></p>
<h3 id="数据库事务处理中出现的数据不一致的情况"><a href="#数据库事务处理中出现的数据不一致的情况" class="headerlink" title="数据库事务处理中出现的数据不一致的情况"></a>数据库事务处理中出现的数据不一致的情况</h3><p>在多个事务并发做数据库操作的时候，如果没有有效的避免机制，就会出现种种问题。大体上有四种问题，归结如下：</p>
<h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><p>如果两个事务都要更新数据库一个字段x，x=100</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取X＝100</td>
<td>读取X＝100</td>
</tr>
<tr>
<td>写入x＝X+100</td>
<td>写入x＝X+200</td>
</tr>
<tr>
<td>事务结束x=200</td>
<td>事务结束x=300</td>
</tr>
<tr>
<td></td>
<td>最后x=300</td>
</tr>
</tbody>
</table>
<p>最后x=300</p>
<p>两个不同事务同时获得相同数据，然后在各自事务中同时修改了该数据，那么先提交的事务更新会被后提交事务的更新给覆盖掉，这种情况事务A的更新就被覆盖掉了、丢失了。</p>
<h4 id="脏读（未提交读）"><a href="#脏读（未提交读）" class="headerlink" title="脏读（未提交读）"></a>脏读（未提交读）</h4><p>防止一个事务读到另一个事务还没有提交的记录。 如：</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>写入x＝X+100（x=200）</td>
</tr>
<tr>
<td>读取X＝200（读取了事务B未提交的数据）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>事务回滚x=100</td>
</tr>
<tr>
<td></td>
<td>事务结束x=100</td>
</tr>
<tr>
<td>事务结束</td>
</tr>
</tbody>
</table>
<p>事务读取了未提交的数据，事务B的回滚，导致了事务A的数据不一致，导致了事务A的脏读 ！</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次的结果应该是一致的；如果不一致，就说明为不可重复读。</p>
<p>还是用上面的例子</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取X＝100</td>
<td>读取X＝100</td>
</tr>
<tr>
<td>读取X＝100</td>
<td>写入x＝X+100</td>
</tr>
<tr>
<td></td>
<td>事务结束，x=200</td>
</tr>
<tr>
<td>读取X＝200（此时，在同一个事务A中，读取的X值发生了变化！）</td>
<td></td>
</tr>
<tr>
<td>事务结束</td>
</tr>
</tbody>
</table>
<p>这种情况事务A多次读取x的结果出现了不一致，即为不可重复读 。</p>
<h4 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h4><p>事务A读的时候读出了15条记录，事务B在事务A执行的过程中 增加 了1条，事务A再读的时候就变成了 16 条，这种情况就叫做幻影读。</p>
<p>不可重复读说明了做数据库读操作的时候可能会出现的问题。</p>
<h3 id="事务隔离级别通过锁的实现机制"><a href="#事务隔离级别通过锁的实现机制" class="headerlink" title="事务隔离级别通过锁的实现机制"></a>事务隔离级别通过锁的实现机制</h3><h4 id="两个锁："><a href="#两个锁：" class="headerlink" title="两个锁："></a>两个锁：</h4><ol>
<li>排他锁 被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其他锁，也不能读取和修改该对象</li>
<li>共享锁 被加锁的对象可以被持锁事务读取，但是不能被修改，其他事务也可以在上面再加共享锁。</li>
</ol>
<p>特别的，对共享锁： 如果两个事务对同一个资源上了共享锁，事务A 想更新该数据，那么它必须等待 事务B 释放其共享锁。</p>
<p>在运用 排他锁 和 共享锁 对数据对象加锁时，还需要约定一些规则，例如何时申请 排他锁 或 共享锁、持锁时间、何时释放等。称这些规则为封锁协议（Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p>
<h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><h5 id="一级封锁协议-对应-read-uncommited"><a href="#一级封锁协议-对应-read-uncommited" class="headerlink" title="一级封锁协议 (对应 read uncommited)"></a>一级封锁协议 (对应 read uncommited)</h5><p>一级封锁协议是：事务 在对需要修改的数据上面（就是在发生修改的瞬间） 对其加共享锁（其他事务不能更改，但是可以读取-导致“脏读”），直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</p>
<p>一级封锁协议不能避免 丢失更新，脏读，不可重复读，幻读！</p>
<h5 id="二级封锁协议-（对应read-commited"><a href="#二级封锁协议-（对应read-commited" class="headerlink" title="二级封锁协议 （对应read commited)"></a>二级封锁协议 （对应read commited)</h5><p>二级封锁协议是：1）事务 在对需要更新的数据 上（就是发生更新的瞬间） 加 排他锁 （直到事务结束） ， 防止其他事务读取未提交的数据，这样，也就避免了 “脏读” 的情况。2）事务 对当前被读取的数据 上面加共享锁（当读到时加上共享锁），一旦读完该行，立即 释放该 该行的共享锁 – 从数据库的底层实现更深入的来理解，既是，数据库会对游标当前的数据上加共享锁 ， 但是当游标离开当前行的时候，立即释放该行的共享锁。<br>二级封锁协议除防止了“脏读”数据，但是不能避免 丢失更新，不可重复读，幻读 。</p>
<p>但在二级封锁协议中，由于读完数据后立即 释放共享锁，所以它不能避免可重复读 ，同时它也不能避免 丢失更新 ，如果事务A、B同时获取资源X，然后事务A先发起更新记录X，那么 事务B 将等待事务 A 执行完成，然后获得记录X 的排他锁，进行更改。这样事务 A 的更新将会被丢失。 具体情况如下：</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取X=100（同时上共享锁）</td>
<td>读取X=100（同时上共享锁）</td>
</tr>
<tr>
<td>读取成功（释放共享锁）</td>
<td>读取成功（释放共享锁）</td>
</tr>
<tr>
<td>UPDATE X=X+100 （上排他锁）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>UPDATING A（等待事务A释放对X的排他锁）</td>
</tr>
<tr>
<td>事务成功（释放排他锁）X=200</td>
<td></td>
</tr>
<tr>
<td></td>
<td>UPDATE X=X+200（成功上排他锁）</td>
</tr>
<tr>
<td></td>
<td>事务成功（释放排他锁）X=300</td>
</tr>
</tbody>
</table>
<p>由此可以看到，事务A的提交被事务B覆盖了，所以不能防止 丢失更新。</p>
<p>如果要避免 丢失更新，我们需要额外的操作， 对凡是读到的数据加 共享锁 和排他锁 ，这个往往需要程序员自己编程实现，比如在Oracle 中，需要加 SELECT FOR UPDATE 语句，表明，凡是该事务读到的数据，额外的加上排他锁，防止其他数据同一时间获取相同数据，这样就防止了 丢失更新 ！</p>
<h5 id="三级封锁协议-（对应reapetable-read-）"><a href="#三级封锁协议-（对应reapetable-read-）" class="headerlink" title="三级封锁协议 （对应reapetable read ）"></a>三级封锁协议 （对应reapetable read ）</h5><p>三级封锁协议是：二级封锁协议加上事务 在读取数据的瞬间 必须先对其加 共享锁 ，但是 直到事务结束才释放 ，这样保证了可重复读（既是其他的事务职能读取该数据，但是不能更新该数据）。</p>
<p>三级封锁协议除防止了“脏”数据，不可重复读和丢失更新。但是这种情况不能避免 幻读。由于该封锁协议只是对某行数据加锁，因此在事务 A 没有完成之前，事务 B 可以新增数据（因为不是对锁住的这一行操作），那么 当事务 A 再次读取的时候，事务B 新增的数据会被读取到，这样，在该封锁协议下，幻读 就产生了。</p>
<p>注：原文说该封锁协议不能避免丢失更新，但我认为是可以避免的。因为无论共享锁还是排它锁，在该事务隔离等级下，其持有时间都是整个事务周期，所以无论读还是写某一行记录都是独占的，不可能存在事务A和B并发读取数据的情况，同时只有一个事务能读取并修改数据。因此应该不会造成丢失更新。</p>
<p>进阶：repeatable read 导致死锁的情况（即便是 不同的资源在相同的顺序下获取）。 比如 事务1 读取 A，同时 事务2 也读取 A，那么事务1和事务2 同时对 A 上了共享锁，然后事务1 要UPDATE A，而此时 事务2 也要 UPDATE A，这个时候 事务1 等待 事务2 释放其在 A 上的共享锁，然后 事务2 要等待 事务1 释放其在 A 上的共享锁，这样，事务1 和 事务2 相互等待，产生死锁！（SQL Server/DB2 里面有 UPDATE LOCK 可以解决这种情况，具体的思路是，在 repeatable read 的情况下，将读取的数据 上的 UPDATE 锁，介于 共享锁 和 排他锁之间的一种锁，该锁的作用是 当出现上面这种情况后，事务1 和 事务2 对 A 上的是 UPDATE 锁，那么谁先 要修改 A，那么该事务就会将 UPDATE 锁可以顺利升级为 排他锁对该数据进行修改！）</p>
<h5 id="最强封锁协议（对应Serialization"><a href="#最强封锁协议（对应Serialization" class="headerlink" title="最强封锁协议（对应Serialization)"></a>最强封锁协议（对应Serialization)</h5><p>四级封锁协议是对三级封锁协议的增强，其实现机制也最为简单，直接对 事务中 所 读取 或者 更改的数据所在的表加表锁，也就是说，其他事务不能 读写 该表中的任何数据。这样所有的 脏读，不可重复读，幻读 ，都得以避免！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从压力测试看数据库连接池配置]]></title>
      <url>http://wjqwsp.github.io/2016/08/31/%E4%BB%8E%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h3><p>　　写过后台的都知道，在操作数据库之前，先要获得数据库连接，然后用数据库连接去进行数据库的增删改查等操作。建立连接和销毁连接都是一笔很大的性能开销，因此产生了连接池的技术。连接池与线程池一样，都是一种资源池，专门用于处理共享资源的。它可以维护一定数量的连接不销毁，当有连接申请时，从池中取出供客户使用；使用完毕则释放归还池中；当池中连接的数量不足时，还可以创建一部分连接。</p>
<h3 id="使用连接池的优点"><a href="#使用连接池的优点" class="headerlink" title="使用连接池的优点"></a>使用连接池的优点</h3><ol>
<li>减少建立连接与销毁连接的性能开销，避免频繁进行连接的建立与销毁，提升系统性能。</li>
<li>限制客户端向数据库发起的数据库访问，避免系统宕机，也避免过多的连接被直接拒绝。</li>
</ol>
<h3 id="数据库连接池的配置"><a href="#数据库连接池的配置" class="headerlink" title="数据库连接池的配置"></a>数据库连接池的配置</h3><p>　　目前有很多连接池框架，使用这些框架非常简单，最主要就是对一些参数进行配置。这些参数包括最大连接数，最小连接数等，参数取值不同，对应用的性能与稳定性会造成不同的影响。下面我就以Tomcat自带的DHCP数据库连接池为例，通过对一个微博Web系统的同一条微博进行并发的疯狂评论操作作压力测试，去看看数据库连接池的参数配置对系统会产生什么样的影响。相信通过下面的压力测试分析，读者们可以体会到上述使用连接池的优点，同时也可以结合上一讲对压力测试的介绍，加深对压力测试的理解，了解到压力测试在系统优化中起到什么样的作用。<br><a id="more"></a></p>
<h3 id="测试前的配置与代码准备"><a href="#测试前的配置与代码准备" class="headerlink" title="测试前的配置与代码准备"></a>测试前的配置与代码准备</h3><h4 id="Tomcat的DHCP配置文件"><a href="#Tomcat的DHCP配置文件" class="headerlink" title="Tomcat的DHCP配置文件"></a>Tomcat的DHCP配置文件</h4><p>　　如果Web应用是部署在Tomcat上的，其参数配置全在context.xml文件里。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version='1.0' encoding='utf-8'?&gt;</div><div class="line"><span class="comment">&lt;!--</span></div><div class="line">  Licensed to the Apache Software Foundation (ASF) under one or more</div><div class="line">  contributor license agreements.  See the NOTICE file distributed with</div><div class="line">  this work for additional information regarding copyright ownership.</div><div class="line">  The ASF licenses this file to You under the Apache License, Version 2.0</div><div class="line">  (the "License"); you may not use this file except in compliance with</div><div class="line">  the License.  You may obtain a copy of the License at</div><div class="line"></div><div class="line">      http://www.apache.org/licenses/LICENSE-2.0</div><div class="line"></div><div class="line">  Unless required by applicable law or agreed to in writing, software</div><div class="line">  distributed under the License is distributed on an "AS IS" BASIS,</div><div class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div class="line">  See the License for the specific language governing permissions and</div><div class="line">  limitations under the License.</div><div class="line">--&gt;</div><div class="line"><span class="comment">&lt;!-- The contents of this file will be loaded for each web application --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Context</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Resource</span></span></div><div class="line">      <span class="attr">name</span>=<span class="string">"jdbc/drp"</span></div><div class="line">      <span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span></div><div class="line">      <span class="attr">driverClassName</span>=<span class="string">"org.postgresql.Driver"</span></div><div class="line">      <span class="attr">maxIdle</span>=<span class="string">"100"</span></div><div class="line">	  <span class="attr">minIdle</span>=<span class="string">"100"</span></div><div class="line">      <span class="attr">maxWait</span>=<span class="string">"-1"</span></div><div class="line">      <span class="attr">username</span>=<span class="string">"postgres"</span></div><div class="line">      <span class="attr">password</span>=<span class="string">"gdzqzxwjs95"</span></div><div class="line">      <span class="attr">url</span>=<span class="string">"jdbc:postgresql://localhost:5432/weibo"</span></div><div class="line">      <span class="attr">maxActive</span>=<span class="string">"100"</span>/&gt;</div><div class="line">    <span class="comment">&lt;!-- Default set of monitored resources --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">WatchedResource</span>&gt;</span>WEB-INF/web.xml<span class="tag">&lt;/<span class="name">WatchedResource</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- Uncomment this to disable session persistence across Tomcat restarts --&gt;</span></div><div class="line">    <span class="comment">&lt;!--</span></div><div class="line">    &lt;Manager pathname="" /&gt;</div><div class="line">    --&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- Uncomment this to enable Comet connection tacking (provides events</span></div><div class="line">         on session expiration as well as webapp lifecycle) --&gt;</div><div class="line">    <span class="comment">&lt;!--</span></div><div class="line">    &lt;Valve className="org.apache.catalina.valves.CometConnectionManagerValve" /&gt;</div><div class="line">    --&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>name是连接池的名称，后台调用数据库连接是需要引用这个名称。</li>
<li>type数据源类型，因为后台用java搭建，这里用java的数据源类。</li>
<li>driverClassName是数据库的驱动，这里用的是postgresql数据库。</li>
<li>maxIdle代表最大空闲连接数，0代表没有限制。</li>
<li>minIdle代表最小空闲连接数。</li>
<li>maxWait代表最大等待时间，-1代表没有限制。</li>
<li>username是数据库的用户名。</li>
<li>password是数据库的密码。</li>
<li>url用于定位数据库。</li>
<li>maxActive代表最大连接数，0代表没有限制。</li>
</ul>
<p>　　下面的测试，我们主要围绕maxIdle,minIdle,maxWait和maxAcitve展开。</p>
<p>　　minIdle是数据库能维持的最小的空闲连接，当Web应用启动时，会自动创建连接到minIdle这个数目，此后minIdle便没有意义。</p>
<p>　　maxIdle代表数据库能维持的最大空闲连接，当minIdle数目的连接不够用时，连接池会继续创建连接。当总连接没有超过maxIdle时，新创建的连接如果被释放不会被销毁，仍然归还池中；当总连接数超过maxIdle时，如果有连接被释放那么这些连接会被销毁，直到使连接池的连接数量达到maxIdle。此后，数据库的总连接数不会少于maxIdle。</p>
<p>　　maxActive代表数据库能维持的最大连接数。当maxIdle数目的数据库连接仍然不够用时，连接池会继续创建连接，直到连接数达到maxActive。这些新创建的连接被释放时直接销毁，不归还池中。如果数据库连接池的总连接数达到maxAcitve，但仍然有连接申请，则这些连接会等待。一般maxIdle与maxAcitve的值应尽量接近，可以取maxIdle=maxActive。这样可以避免高负荷系统频繁创建与销毁连接。</p>
<p>　　maxWait是最大等待时间。前面说过，当数据库连接数达到maxActive,其余的连接申请会等待，而等待的最大时间就是maxWait。当等待时间超过maxWait，但仍然没有连接被释放时，则这些等待中的连接会被拒绝。</p>
<h4 id="后台获取和释放数据库连接代码"><a href="#后台获取和释放数据库连接代码" class="headerlink" title="后台获取和释放数据库连接代码"></a>后台获取和释放数据库连接代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Context ctx=<span class="keyword">new</span> InitialContext();</div><div class="line">DataSource ds=(DataSource)ctx.lookup(<span class="string">"java:comp/env/jdbc/drp"</span>);</div><div class="line">Connection conn = ds.getConnection();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</div><div class="line">                    conn.close();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception err1)&#123;</div><div class="line">                err1.printStackTrace();</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>　　代码很简单，连接释放还是直接用close方法，底层会由连接池实现连接归还而不销毁。</p>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><h4 id="测试任务"><a href="#测试任务" class="headerlink" title="测试任务"></a>测试任务</h4><p>　　利用JMeter作测试工具，对同一条微博作高并发的疯狂评论，对数据库而言就是对评论表作高并发的插入操作，同时并发更新微博表同一条记录的评论数属性。</p>
<h4 id="不用连接池"><a href="#不用连接池" class="headerlink" title="不用连接池"></a>不用连接池</h4><h5 id="1秒内启100个线程"><a href="#1秒内启100个线程" class="headerlink" title="1秒内启100个线程"></a>1秒内启100个线程</h5><p><img src="/img/压力测试1秒100.png" alt="压力测试1秒100"></p>
<h5 id="1秒内启200个线程"><a href="#1秒内启200个线程" class="headerlink" title="1秒内启200个线程"></a>1秒内启200个线程</h5><p><img src="/img/压力测试1秒200.png" alt="压力测试1秒200"></p>
<h5 id="1秒内启250个线程"><a href="#1秒内启250个线程" class="headerlink" title="1秒内启250个线程"></a>1秒内启250个线程</h5><p><img src="/img/压力测试1秒250.png" alt="压力测试1秒250"></p>
<h5 id="1秒内启300个线程"><a href="#1秒内启300个线程" class="headerlink" title="1秒内启300个线程"></a>1秒内启300个线程</h5><p><img src="/img/压力测试1秒300.png" alt="压力测试1秒300"></p>
<h5 id="错误及分析"><a href="#错误及分析" class="headerlink" title="错误及分析"></a>错误及分析</h5><p><img src="/img/连接拒绝异常.png" alt="连接拒绝异常"></p>
<p>　　以上测试从1秒启100个线程开始，不断增加测试的线程数，直到1秒内启动250个线程的时候开始出错。且启动线程的密集程度越高，错误率越高。此时后台抛出连接拒绝异常。</p>
<p>　　产生此异常，是因为数据库允许的连接数往往是有限的。以postgresql数据库为例，默认的数据库最大允许连接数为100，当同时占用的连接数超过100个时，便会把超过的连接直接拒绝掉，同时抛出连接拒绝异常。之所以1秒产生250个线程才出错，是因为如果机器运行足够快，前面启动的一部分线程已经运行完了可以被释放，以供后续产生的线程使用。总之，只要同时占用的连接数不超过100个，就不会拒绝连接；反之多余的连接会被拒绝。</p>
<h4 id="使用连接池，且maxActive超过100"><a href="#使用连接池，且maxActive超过100" class="headerlink" title="使用连接池，且maxActive超过100"></a>使用连接池，且maxActive超过100</h4><h5 id="配置maxActive-maxIdle-200，maxWait-1，1秒内启200个线程。"><a href="#配置maxActive-maxIdle-200，maxWait-1，1秒内启200个线程。" class="headerlink" title="配置maxActive = maxIdle = 200，maxWait = -1，1秒内启200个线程。"></a>配置maxActive = maxIdle = 200，maxWait = -1，1秒内启200个线程。</h5><p> <img src="/img/压力测试1秒200-too-many.png" alt="压力测试1秒200_too_many"></p>
<h5 id="错误及分析-1"><a href="#错误及分析-1" class="headerlink" title="错误及分析"></a>错误及分析</h5><p> <img src="/img/too-many-clients.png" alt="too_many_clients"></p>
<p>　　postgresql里默认的最大连接数是100，如果连接池数目超过数据库的连接数限制，则会抛出上述异常。因此maxActive参数不能超过数据库的连接数限制。特别注意的是，即便maxActive设为100，但如果除了此程序还有其他程序访问同一数据库，那么其他程序也会占用数据库连接数，使数据库可用连接小于100，从而使此程序抛出上述异常！因此，准确来说，连接池的maxActive参数应该是不能大于数据库最大的可用连接数！</p>
<h4 id="使用连接池，maxActive-100，maxWait设为5秒"><a href="#使用连接池，maxActive-100，maxWait设为5秒" class="headerlink" title="使用连接池，maxActive=100，maxWait设为5秒"></a>使用连接池，maxActive=100，maxWait设为5秒</h4><h5 id="设置maxIdle-maxActive-100-maxWait-5000，1秒内启250个线程"><a href="#设置maxIdle-maxActive-100-maxWait-5000，1秒内启250个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启250个线程"></a>设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启250个线程</h5><p><img src="/img/压力测试1秒250-pool.png" alt="压力测试1秒250_pool"></p>
<h5 id="设置maxIdle-maxActive-100-maxWait-5000，1秒内启300个线程"><a href="#设置maxIdle-maxActive-100-maxWait-5000，1秒内启300个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启300个线程"></a>设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启300个线程</h5><p><img src="/img/压力测试1秒300-pool.png" alt="压力测试1秒300_pool"></p>
<h5 id="设置maxIdle-maxActive-100-maxWait-5000，1秒内启400个线程"><a href="#设置maxIdle-maxActive-100-maxWait-5000，1秒内启400个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启400个线程"></a>设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启400个线程</h5><p><img src="/img/压力测试1秒400-pool.png" alt="压力测试1秒400_pool"></p>
<h5 id="设置maxIdle-maxActive-100-maxWait-5000，1秒内启450个线程"><a href="#设置maxIdle-maxActive-100-maxWait-5000，1秒内启450个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启450个线程"></a>设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启450个线程</h5><p><img src="/img/压力测试1秒450-pool.png" alt="压力测试1秒450_pool"></p>
<h5 id="错误及分析-2"><a href="#错误及分析-2" class="headerlink" title="错误及分析"></a>错误及分析</h5><p><img src="/img/timeout-wating-for-idle.png" alt="timeout_wating_for_idle"></p>
<p>　　当1秒启400个线程以上时，后台会抛出上述异常。</p>
<p>　　因为上面的测试maxWait设为5秒，当请求的连接数大于maxActive时，连接池不会再创建新的连接，而是等待已有的连接变为空闲。当等待的时间超过maxWait设定的时间，则会抛出上述异常。</p>
<h4 id="maxWait无限制"><a href="#maxWait无限制" class="headerlink" title="maxWait无限制"></a>maxWait无限制</h4><h5 id="设置maxIdle-maxActive-100，maxWait-1，1秒内启400个线程"><a href="#设置maxIdle-maxActive-100，maxWait-1，1秒内启400个线程" class="headerlink" title="设置maxIdle = maxActive = 100，maxWait = -1，1秒内启400个线程"></a>设置maxIdle = maxActive = 100，maxWait = -1，1秒内启400个线程</h5><p><img src="/img/1秒启400.png" alt="1秒启400"></p>
<h5 id="设置maxIdle-maxActive-100，maxWait-1，1秒内启500个线程"><a href="#设置maxIdle-maxActive-100，maxWait-1，1秒内启500个线程" class="headerlink" title="设置maxIdle = maxActive = 100，maxWait = -1，1秒内启500个线程"></a>设置maxIdle = maxActive = 100，maxWait = -1，1秒内启500个线程</h5><p><img src="/img/1秒启500.png" alt="1秒启500"></p>
<h5 id="设置maxIdle-maxActive-100-maxWait-1，1秒内启700个线程"><a href="#设置maxIdle-maxActive-100-maxWait-1，1秒内启700个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = -1，1秒内启700个线程"></a>设置maxIdle = maxActive = 100,maxWait = -1，1秒内启700个线程</h5><p><img src="/img/1秒启700.png" alt="1秒启700"></p>
<h5 id="设置maxIdle-maxActive-100-maxWait-1，1秒内启1000个线程"><a href="#设置maxIdle-maxActive-100-maxWait-1，1秒内启1000个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = -1，1秒内启1000个线程"></a>设置maxIdle = maxActive = 100,maxWait = -1，1秒内启1000个线程</h5><p><img src="/img/1秒启1000.png" alt="1秒启1000"></p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>　　只要maxWait不加限制，且连接池设置的最大连接数不超过数据库允许的最大连接数，无论有多少的连接请求，都不会抛出异常，不会有错误。但是由于内存的限制，过多的请求必然导致响应时间变长，用户体验变差。为了测试方便，上面的压力测试我是没有用Duration Assertion的，只通过Response Assertion对http response的返回内容作断言判断是否正确返回。下面，我就对压力测试加上Duration Assertion，对登录响应限制为5秒，对评论微博的响应限制为10秒，继续进行测试。</p>
<h4 id="设置Duration-Assertion"><a href="#设置Duration-Assertion" class="headerlink" title="设置Duration Assertion"></a>设置Duration Assertion</h4><h5 id="设置maxIdle-maxActive-100，maxWait-1，1秒内启150个线程"><a href="#设置maxIdle-maxActive-100，maxWait-1，1秒内启150个线程" class="headerlink" title="设置maxIdle = maxActive = 100，maxWait = -1，1秒内启150个线程"></a>设置maxIdle = maxActive = 100，maxWait = -1，1秒内启150个线程</h5><p><img src="/img/1秒150-time.png" alt="1秒150_time"></p>
<h5 id="设置maxIdle-maxActive-100，maxWait-1，1秒内启200个线程"><a href="#设置maxIdle-maxActive-100，maxWait-1，1秒内启200个线程" class="headerlink" title="设置maxIdle = maxActive = 100，maxWait = -1，1秒内启200个线程"></a>设置maxIdle = maxActive = 100，maxWait = -1，1秒内启200个线程</h5><p><img src="/img/1秒200-time.png" alt="1秒200_time"></p>
<h5 id="设置maxIdle-maxActive-100，maxWait-1，1秒内启250个线程"><a href="#设置maxIdle-maxActive-100，maxWait-1，1秒内启250个线程" class="headerlink" title="设置maxIdle = maxActive = 100，maxWait = -1，1秒内启250个线程"></a>设置maxIdle = maxActive = 100，maxWait = -1，1秒内启250个线程</h5><p><img src="/img/1秒250-time.png" alt="1秒250_time"></p>
<h5 id="错误及分析-3"><a href="#错误及分析-3" class="headerlink" title="错误及分析"></a>错误及分析</h5><p>　　综上，只要将连接池的最大等待时间不加限制，无论有多大的并发访问都不会因为异常而使数据库操作失败，从而导致错误。主要的性能瓶颈来自于机器内存，过多的请求会使响应时间急剧恶化，严重降低用户体验。这也是根据压力测试的结果能作出的软件上的最大优化。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　建议所有后台的数据库连接都采用连接池技术。上面的压力测试暴露的问题全是出自数据库连接上，其实像疯狂评论这样的并发操作，特别容易产生数据库死锁或者序列化并发更新异常等更难解决的错误。后面我还会再对数据库的锁机制做一些总结，分析一下为什么上面的压力测试不会出现死锁等更严重的错误，以及这些错误是怎么产生的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMeter压力测试基础]]></title>
      <url>http://wjqwsp.github.io/2016/08/29/jmeter%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h3 id="什么是压力测试"><a href="#什么是压力测试" class="headerlink" title="什么是压力测试"></a>什么是压力测试</h3><p>　　当我们开发完一个Web系统，实现了需求中的所有功能，此时还不能马上将其上线。我们必须对这个系统进行充分的，全面的测试，最大程度地确保它不会出错。压力测试就是这些测试的一种。压力测试的目的是为系统模拟一个现实的访问场景，建立一堆线程去并发地访问系统，了解这个Web系统能支持多大的并发量，或者说支持多少用户同时在线而不会崩溃。我们通过调整并发的线程数，访问时间等参数，去了解在一定的硬件配置下，我们的系统能支持多少线程在多少时间内同时访问。在确定了这些测试数据以后，我们便对这个Web系统的性能有一个比较客观全面的了解，从而可以更好地寻求优化的方案。</p>
<h3 id="关于JMeter"><a href="#关于JMeter" class="headerlink" title="关于JMeter"></a>关于JMeter</h3><p>　　JMeter是用java实现的开源的压力测试工具，功能强大，使用简单，在压力测试中占据极其重要的地位。这一讲就以JMeter对一个简单的微博系统进行压力测试的实例入手，介绍一下JMeter最基本的一些知识，看看JMeter是怎么对HTTP request进行测试的。虽然是以实例的形式去介绍，但涉及的都是JMeter最基本的内容，更深入的学习还需不断参考JMeter官方文档。<br><a id="more"></a></p>
<h3 id="微博系统测试任务"><a href="#微博系统测试任务" class="headerlink" title="微博系统测试任务"></a>微博系统测试任务</h3><ol>
<li>登录</li>
<li>对某用户进行关注</li>
<li>对某用户取消关注</li>
<li>发一条微博</li>
<li>查找自己的微博列表</li>
<li>对刚刚发的微博添加一条评论</li>
<li>查找该微博的评论列表</li>
<li>删除刚刚添加的评论</li>
<li>删除刚刚发的微博</li>
<li>登出</li>
</ol>
<p>　　以上测试基本涵盖了我们这个微博系统的所有功能。我们这个微博系统是已经实现好的，后台采用简单的servlet实现。我们只需要根据这个微博系统不同servlet的输入参数和返回内容进行测试即可。其他任何Web系统的压力测试也可以套用或者参考。</p>
<h3 id="建立线程组"><a href="#建立线程组" class="headerlink" title="建立线程组"></a>建立线程组</h3><p>　　在官网上下载了JMeter以后，便可以运行jmeter.sh，打开JMeter的图形操作界面。此时，我们只看到一个空白的Test Plan，可以修改Test Plan的名字。</p>
<p><img src="/img/Test-Plan.jpg" alt="Test Plan"></p>
<p>　　右键点击左边栏的Test Plan，可以新建线程组。线程组就是我们配置线程，模拟并发访问的地方。</p>
<p><img src="/img/Thread-Group.jpg" alt="Thread Group"></p>
<ul>
<li>Number of Threads是一共要启的线程数。</li>
<li>Ramp-up Period是用多少时间启动线程组。假如Number of Threads我们填了10，Ramp-up Period填了100，那么每10秒会启动一个线程，100秒会启动完所有线程。</li>
<li>Loop Count是循环运行线程组的次数，默认运行一次，不循环。</li>
</ul>
<p>　　在测试过程中，我们要不断修改上面这3个参数，尤其是前两个。我们需要试出合适的参数，启动线程的频率不能太快也不能太慢，太慢往往所有线程都运行成功，且最后一个线程启动时前面的线程有些已经结束，达不到测试的效果，太快则产生一堆错误。使得系统刚好出错的参数配置，就是性能的临界点。</p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="HTTP-Request-Defaults"><a href="#HTTP-Request-Defaults" class="headerlink" title="HTTP Request Defaults"></a>HTTP Request Defaults</h4><p>　　在线程组下建立HTTP Request Defaults这个配置元素。由于我们需要测试的微博系统其域名或IP地址是固定的，访问的端口号也是固定的。我们进行的所有HTTP Request测试都要填写相同的IP和端口号，十分麻烦，修改也要全部修改。HTTP Request Defaults就是让我们在一个地方填写好基本配置信息，在同一作用域下的所有HTTP Request测试都能应用这个配置。假设我们的微博系统是建立在本机的，端口号采用Tomcat默认的8080,则配置如下：</p>
<p><img src="/img/http-request-defaults.jpg" alt="Http Request Defaults"></p>
<h4 id="HTTP-Cookie-Manager"><a href="#HTTP-Cookie-Manager" class="headerlink" title="HTTP Cookie Manager"></a>HTTP Cookie Manager</h4><p>　　很多网站需要用cookie记录用户的登录信息，在用户登录以后，之后的Http Request便带有登录过的cookie信息，进而访问网站资源。没有携带这些cookie数据的需要重新登录。在进行压力测试，模拟并发访问时，登录后的后续测试都需要携带相应的cookie才能正常进行测试。HTTP Cookie Manager便可以让我们的所有Http Request都共用同样的cookie。</p>
<p><img src="/img/http-cookie-manager.jpg" alt="Http Cookie Manager"></p>
<h4 id="Constant-Timer"><a href="#Constant-Timer" class="headerlink" title="Constant Timer"></a>Constant Timer</h4><p>　　用户在实际访问网站时，每一个操作之间往往有一定的时间间隔，不可能不间断地进行。为了真实地模拟用户行为，我们需要一个延时的功能，让每个线程启动之间有一定的时延。这个需求Constant Timer可以满足。</p>
<p><img src="/img/constant-timer.jpg" alt="Constant Timer"></p>
<p>　　如图所示，Thread Delay便是以毫秒为单位的固定时延数。除了固定时延，还有其他的计时器可以实现时延效果。</p>
<h3 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h3><p>　　我们可以用多种形式来呈现测试结果。下面介绍比较常用的两种，结果树和聚合报告。</p>
<h4 id="结果树"><a href="#结果树" class="headerlink" title="结果树"></a>结果树</h4><p>　　结果树能顺序地把每一个线程的每个测试的结果列出来，绿色代表成功，红色代表失败，并且可以查看每个测试的具体信息，例如request和response的具体内容，可以知道哪里出错。</p>
<p><img src="/img/view-results-tree.jpg" alt="View Results Tree"></p>
<h4 id="聚合报告"><a href="#聚合报告" class="headerlink" title="聚合报告"></a>聚合报告</h4><p>　　结果树能看到具体的测试信息，但缺乏整体的概览。我们希望知道进行了多少测试，失败率多少，平均耗时是多少，聚合报告便能很清晰地提供给我们这些信息。</p>
<p><img src="/img/aggregate-report.jpg" alt="Aggregate Report"></p>
<p>　　我们可以把结果树和聚合报告都添加进线程组内，结合两个测试报告去分析我们的结果。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>　　<br>　　断言用于定义一些判断测试请求是否正确的规则。</p>
<p>　　默认情况下，如果http response的状态码是200就表示测试正确。但实际情况要复杂很多，response返回200只能表示正常访问到资源，很有可能相应的业务逻辑不正确。下面介绍两种比较常用的判断请求是否正确的手段，都是用断言实现的，分别是Response Assertion和Duration Assertion。</p>
<h4 id="Response-Assertion"><a href="#Response-Assertion" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p>　　一般情况下，对于每一个http request，相同的输入参数应该会让http response返回相同的内容。这些内容可能是html页面，也可能是一些返回数据。通过添加Response Assertion到相应的测试Sampler上，如果response的返回包含某些内容就说明正确，不包含就说明失败。</p>
<p><img src="/img/login-response.jpg" alt="Response Assertion"></p>
<p>　　如果response返回含有”success”字段，就说明成功；否则失败。</p>
<p>　　下面进行的测试实例，全部使用Response Assertion。</p>
<h4 id="Duration-Assertion"><a href="#Duration-Assertion" class="headerlink" title="Duration Assertion"></a>Duration Assertion</h4><p>　　只是返回结果正确，也不能达到测试效果。在实际业务环境中，页面返回的快慢是影响用户体验的致命因素。当并发量大时，用户在进行页面操作时很容易会有时延。因此，在进行压力测试时，我们有理由定义一个延时范围，当超过这个时间还没有response返回说明失败；在延时范围内返回response说明成功。Duration Assetion就是完成这项工作的。</p>
<p><img src="/img/duration-assertion.jpg" alt="Duration Assertion"></p>
<p>　　上面就定义了延时范围为5000毫秒。超过5000毫秒还没返回http response视为失败；否则为成功。</p>
<p>　　下面进行的测试实例，全部使用Duration Assertion，且Duration in milliseconds全部设为5000毫秒，就不一一列举了，在分析时候只列出Response Assertion设置。</p>
<h3 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h3><h4 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h4><p>　　JMeter里对HTTP Request的测试是用Sampler里的HTTP Request进行的。我们可以在里面添加HTTP Request的Parameter，以及URI。</p>
<p>　　登录一般需要用户名和密码。为了测试方便，我预先在微博系统对应的数据库里添加好一定量的用户，他们的用户名与id相同，密码统一为gdzq。id按加一自增长的策略产生。下面是登录测试的配置：</p>
<p><img src="/img/login-test.jpg" alt="Login Test"></p>
<p>　　我们的登录功能是用LoginServlet这个serlvet实现的，它接收两个参数，一个是email,相当于用户名；一个是pwd，是密码。这些输入参数是有具体的Web系统确定的，我这个微博系统就是需要这两个。</p>
<p>　　由于要模拟多用户登录的场景，需要让每个线程的登录用户的不一样。按照上面的数据库里的测试用户的特点，在HTTP Request的参数里让密码固定为gdzq，用户名我们这里引入了一个变量User。</p>
<p>　　JMeter有很多途径产生变量，我们这里介绍一种很简单的，Counter。</p>
<p><img src="/img/counter.png" alt="Counter"></p>
<p>　　Start是变量的起始值，Increment是每次增加的值，Maximum是上限值，Reference Name是变量名。我们让User变量从134开始递增，每启动一个线程就会使用一次User变量，并把它增1，从而达到模拟不同用户访问系统的效果。</p>
<h4 id="Response-Assertion-1"><a href="#Response-Assertion-1" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/login-response.jpg" alt="Login Assertion"></p>
<h3 id="关注某个人"><a href="#关注某个人" class="headerlink" title="关注某个人"></a>关注某个人</h3><h4 id="测试配置-1"><a href="#测试配置-1" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/follow.jpg" alt="Follow"></p>
<p>　　两个参数，一个是关注者id，一个是被关注者id。被关注者我们固定为22，关注者按照登录测试的逻辑，用User变量表示，模拟多用户并发关注同一个用户的情景。</p>
<h4 id="Response-Assertion-2"><a href="#Response-Assertion-2" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/follow-response.jpg" alt="Follow Assertion"></p>
<h3 id="取消关注某个人"><a href="#取消关注某个人" class="headerlink" title="取消关注某个人"></a>取消关注某个人</h3><p>　　取消关注操作与关注操作的request参数和response返回都是一样的，就不另行分析了。</p>
<h3 id="发送微博"><a href="#发送微博" class="headerlink" title="发送微博"></a>发送微博</h3><h4 id="测试配置-2"><a href="#测试配置-2" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/send-message.jpg" alt="Send Message"></p>
<p>　　http request需要两个参数，id代表发送微博的用户的id，message代表微博内容。这里我们两个参数都使用User变量，每一个线程都代表不同的用户，不同的用户都发送一条微博，微博内容就是他们的用户id号。</p>
<h4 id="Response-Assertion-3"><a href="#Response-Assertion-3" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/send-message-response.jpg" alt="Send Message Response"></p>
<h3 id="查找微博列表"><a href="#查找微博列表" class="headerlink" title="查找微博列表"></a>查找微博列表</h3><h4 id="测试配置-3"><a href="#测试配置-3" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/search-message.jpg" alt="Search Message"></p>
<p>　　http request接收三个参数，id代表要查找哪个用户的微博列表，这里仍然使用User变量；因为微博可能很多，需要分页，page代表要查找的微博列表的页数，这里固定为第一页；type代表查找类型，我设计的这个微博系统允许三种类型的查找，分别是全部，个人和最热微博。全部就是查找用户自己发表的微博以及用户关注的人发表的所有微博；个人就只是用户自己发表的微博；最热微博则是查找全系统评论数最高的10条微博。这里type固定为”single”代表只查找用户自己发表的微博。由于我数据库用于测试的用户本身并没有微博数据，仅有的微博就是上一个操作发送的那条微博，因此查找结果应该只含一条微博。</p>
<h4 id="Response-Assertion-4"><a href="#Response-Assertion-4" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/search-message-response.jpg" alt="Search Message Response"></p>
<p>　　如果访问正确，应该返回m1id字段。我这个SearchMessageServlet的response返回的是微博列表，格式是json。json里包含着m1id字段，代表是查找出来的微博id。由于测试用户只有一条刚刚测试时发表的微博，所以只有一个m1id字段出现。</p>
<h4 id="Post-Processors中的正则表达式提取器"><a href="#Post-Processors中的正则表达式提取器" class="headerlink" title="Post-Processors中的正则表达式提取器"></a>Post-Processors中的正则表达式提取器</h4><p>　　Post-Processors是Sampler运行完后会触发的一项组件，一般用于提取Sampler返回的一些数据。类似的还有Pre-Processors，是Sampler运行之前会触发的一项组件。正则表达式提取器便是Post-Processors其中一种，用于按正则表达式的语法提取response里包含的一些数据。</p>
<p>　　由于我们的测试后续需要测试往微博添加评论，查找评论，删除评论以及删除微博这些功能，都需要刚刚测试时用户发表的微博的id作为http request的输入参数。因此我们在查找微博的Sampler上添加一个正则表达式提取器，提取查找出来的第一条微博的id。这条微博就是测试时发表的微博。</p>
<p><img src="/img/message-regular.jpg" alt="Message Regular"></p>
<p>　　我们用正则表达式提取器产生引用名为messageid的变量，用于后续测试引用。因为我们的返回是json格式的数据，所以正则表达式为(.<em>“m1id”:(.</em>?),)，提取json的key为m1id的数据。</p>
<p>　　Template代表我们希望提取第几个捕捉项，一般用括号括起来的作为一个捕捉项，上面的正则表达式只有一个。$1$代表提取第一个捕捉项。</p>
<p>　　Match No.代表我们希望提取第几个匹配组。由于我们在response里可能提取到一组满足正则表达式的匹配字符串，我们需要选一个或者几个出来作为我们的输出。0表示随机选择一个，-1表示选择全部。这里我们选1，代表提取第一个匹配到的匹配项。实际上，由于我们的测试用户只有一条微博数据，也只能匹配到一个。</p>
<h3 id="发表评论"><a href="#发表评论" class="headerlink" title="发表评论"></a>发表评论</h3><h4 id="测试配置-4"><a href="#测试配置-4" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/send-comment.jpg" alt="Send Comment"></p>
<p>　　http request接收3个参数，messageId代表发表评论在哪个微博上，这里用之前正则表达式提取器提取的messageid变量作为值；sendId代表发表评论的用户id，这里仍然用User变量；comment代表评论的内容，这里为了方便，直接用User变量作为评论的内容。</p>
<h4 id="Response-Assertion-5"><a href="#Response-Assertion-5" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/send-comment-response.jpg" alt="Send Comment Response"></p>
<h3 id="查找评论列表"><a href="#查找评论列表" class="headerlink" title="查找评论列表"></a>查找评论列表</h3><h4 id="测试配置-5"><a href="#测试配置-5" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/search-comment.jpg" alt="Search Comment"></p>
<p>　　http request接收2个参数，id代表查找哪个微博的评论，这里仍然用messageid变量；page代表页码，因为评论列表也是需要翻页的，这里固定为第一页。</p>
<h4 id="Response-Assertion-6"><a href="#Response-Assertion-6" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/search-comment-response.jpg" alt="Search Comment Response"></p>
<p>　　response会返回json格式的数据，comment_id是json里的key，代表对应的评论的id。通过判断response是否含有comment_id字段，可以判断测试是否正确。</p>
<h4 id="正则表达式提取器"><a href="#正则表达式提取器" class="headerlink" title="正则表达式提取器"></a>正则表达式提取器</h4><p><img src="/img/comment-regular.jpg" alt="Comment Regular"></p>
<p>　　与查找微博列表一样，查找评论列表也需要设置一个正则表达式提取器，提取返回的评论列表的第一条评论的id。由于测试用户只有一条微博一条评论，这条评论id就是刚刚发表的评论的id。这个id继续作为下面删除评论测试的输入参数。</p>
<h3 id="删除评论"><a href="#删除评论" class="headerlink" title="删除评论"></a>删除评论</h3><h4 id="测试配置-6"><a href="#测试配置-6" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/delete-comment.jpg" alt="Delete Comment"></p>
<p>　　http request接收1个参数，commentId就是上面正则表达式提取器产生的变量，代表评论id。只要把评论id作为DeleteCommentServlet的参数，就能实现删除评论的功能。</p>
<h4 id="Response-Assertion-7"><a href="#Response-Assertion-7" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/delete-comment-response.jpg" alt="Delete Comment Response"></p>
<h3 id="删除微博"><a href="#删除微博" class="headerlink" title="删除微博"></a>删除微博</h3><h4 id="测试配置-7"><a href="#测试配置-7" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/delete-message.jpg" alt="Delete Message"></p>
<p>　　http request接收1个参数，messageId就是上面正则表达式提取器产生的变量，代表微博id。只要把微博id作为DeleteMessageServlet的参数，就能实现删除微博的功能。</p>
<h4 id="Response-Assertion-8"><a href="#Response-Assertion-8" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/delete-message-response.jpg" alt="Delete Message Response"></p>
<h3 id="登出测试"><a href="#登出测试" class="headerlink" title="登出测试"></a>登出测试</h3><h4 id="测试配置-8"><a href="#测试配置-8" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/logout.jpg" alt="Logout Test"></p>
<p>　　http request接收一个参数，id代表要登出的用户id，这里用User变量。</p>
<h4 id="Response-Assertion-9"><a href="#Response-Assertion-9" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/logout-response.jpg" alt="Logout Response"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　上面的实例通过具体的微博系统的测试，引出了一些JMeter的一些最基本最常用的组件。学会使用这些组件，就能搭建一个基本的测试系统，完成基本的压力测试任务。上面的具体测试细节可以不用关注，但要关注从这些实例引申出来的Sampler,HTTP Request Defaults,HTTP Cookie Manager,Assertion,测试报告，断言，变量，正则表达式提取器以及Post-Processors和Pre-Processors等概念。</p>
<p>　　在完成了上述配置以后，只要不断地试验、修改启动的线程数，启动时间等参数，便可以得出Web系统在并发访问下的性能临界点，由此作出可行的优化。</p>
<p>　　</p>
<p>　　</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ORM in JaveEE——JPA]]></title>
      <url>http://wjqwsp.github.io/2016/08/26/ORM-in-JaveEE%E2%80%94%E2%80%94JPA/</url>
      <content type="html"><![CDATA[<h3 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h3><p>　　ORM,即Object Relation Mapping，对象关系映射。我们一般用数据库作数据的持久化存储，通过针对表，属性等进行各种sql的操作，来进行增删改查。但作为程序员，在面向对象思想大行其道的今天，我们更倾向于处理对象，而不是直接处理数据库里面的关系表。我们希望在程序的业务逻辑中，一切皆是对象，而不是表与表的关系，表之间的属性。于是一套从表到对象的映射技术，便应运而生。目前，很多框架都可以实现从关系型数据库到对象的映射，例如Hibernate,EclipseLink等。只需要编写一些配置文件，便可以轻松实现。</p>
<h3 id="什么是JPA"><a href="#什么是JPA" class="headerlink" title="什么是JPA"></a>什么是JPA</h3><p>　　由于市面上有很多框架都可以实现ORM，我们使用不同的框架，就需要一套不一样的配置文件，一套不一样的代码。换言之，我们的工程与这些框架是紧耦合的。如果我们想更换这些框架，那么改动就非常大了。JPA就实现了一套统一的接口标准，让我们可以自由选择不同供应商的不同ORM框架，实现与这些第三方框架的解耦合。并且，JPA广泛使用注解，代码简单，开发十分方便。</p>
<h3 id="JPA与RESTful-API"><a href="#JPA与RESTful-API" class="headerlink" title="JPA与RESTful API"></a>JPA与RESTful API</h3><p>　　前面我们提到RESTful API使用JAX-RS实现的。RESTful API与JPA没有直接的关系，但我们知道通过RESTful API我们实际上是把对对象的增删改查映射到HTTP方法上。而JPA相当于是处理下一层的工作，把对数据库表的增删改查映射到对象上。这样，经过JAX-RS到JPA再到数据库这么三层的处理，我们便可以利用RESTful API来实现我们的业务逻辑。<br><a id="more"></a></p>
<h3 id="BCE模型"><a href="#BCE模型" class="headerlink" title="BCE模型"></a>BCE模型</h3><p>  BCE模型，即Boundary-Controll-Entity，是Web应用系统的一种十分常见的结构。Boundary,即系统之间交互的边界，一般指一些涉及对Web应用的数据的输入输出的类，例如RESTful API直接访问的JAX-RS的Resource类。Control，一般是完成一些复杂的计算与业务逻辑的处理，是从Entity到Boundary的中间层。Entity，就是数据库表直接ORM转化的实体对象类。下面就从BCE模型入手，按Entity，Control，Boundary的顺序，围绕实例介绍一下JPA标准以及其与JAX-RS的结合。</p>
<h4 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h4><p>　　先来看看JPA的Entity类是什么样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="meta">@Table</span>(name = <span class="string">"commentary"</span>, catalog = <span class="string">"weibo"</span>, schema = <span class="string">"public"</span>)</div><div class="line"><span class="meta">@XmlRootElement</span></div><div class="line"><span class="meta">@NamedQueries</span>(&#123;</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"Commentary.findAll"</span>, query = <span class="string">"SELECT c FROM Commentary c"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"Commentary.findById"</span>, query = <span class="string">"SELECT c FROM Commentary c WHERE c.id = :id"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"Commentary.findByWord"</span>, query = <span class="string">"SELECT c FROM Commentary c WHERE c.word = :word"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"Commentary.findByCreateDate"</span>, query = <span class="string">"SELECT c FROM Commentary c WHERE c.createDate = :createDate"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"Commentary.findByIsDeleted"</span>, query = <span class="string">"SELECT c FROM Commentary c WHERE c.isDeleted = :isDeleted"</span>)&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Commentary</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</div><div class="line">    <span class="meta">@Basic</span>(optional = <span class="keyword">false</span>)</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="meta">@Basic</span>(optional = <span class="keyword">false</span>)</div><div class="line">    <span class="meta">@NotNull</span></div><div class="line">    <span class="meta">@Size</span>(min = <span class="number">1</span>, max = <span class="number">140</span>)</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"word"</span>)</div><div class="line">    <span class="keyword">private</span> String word;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"create_date"</span>)</div><div class="line">    <span class="meta">@Temporal</span>(TemporalType.TIMESTAMP)</div><div class="line">    <span class="keyword">private</span> Date createDate;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"is_deleted"</span>)</div><div class="line">    <span class="keyword">private</span> Boolean isDeleted;</div><div class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"reply_subscriber_id"</span>, referencedColumnName = <span class="string">"id"</span>)</div><div class="line">    <span class="meta">@ManyToOne</span></div><div class="line">    <span class="keyword">private</span> Subscriber replySubscriberId;</div><div class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"subscriber_id"</span>, referencedColumnName = <span class="string">"id"</span>)</div><div class="line">    <span class="meta">@ManyToOne</span></div><div class="line">    <span class="keyword">private</span> Subscriber subscriberId;</div><div class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"message_id"</span>, referencedColumnName = <span class="string">"id"</span>)</div><div class="line">    <span class="meta">@ManyToOne</span></div><div class="line">    <span class="keyword">private</span> Message messageId;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Commentary</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Commentary</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Commentary</span><span class="params">(Long id, String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.word = word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWord</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWord</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.word = word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getCreateDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> createDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreateDate</span><span class="params">(Date createDate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.createDate = createDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getIsDeleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> isDeleted;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsDeleted</span><span class="params">(Boolean isDeleted)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.isDeleted = isDeleted;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Subscriber <span class="title">getReplySubscriberId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> replySubscriberId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReplySubscriberId</span><span class="params">(Subscriber replySubscriberId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.replySubscriberId = replySubscriberId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Subscriber <span class="title">getSubscriberId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> subscriberId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubscriberId</span><span class="params">(Subscriber subscriberId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subscriberId = subscriberId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">getMessageId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messageId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageId</span><span class="params">(Message messageId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messageId = messageId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</div><div class="line">        hash += (id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> hash;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> Warning - this method won't work in the case the id fields are not set</span></div><div class="line">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Commentary)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Commentary other = (Commentary) object;</div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.id == <span class="keyword">null</span> &amp;&amp; other.id != <span class="keyword">null</span>) || (<span class="keyword">this</span>.id != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.id.equals(other.id))) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"sampleweb.message.entity.Commentary[ id="</span> + id + <span class="string">" ]"</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　简单分析一下，@Entity标注说明该类是JPA的实体类。@Table标注说明了该类对应的数据库，schema以及表名，由此使Entity与数据库的表建立一一对应的关系。</p>
<p>　　@Id标注说明了主键，@Column说明了表的列属性。@Basic(optional = false)与@NotNull都是表示该属性对应到数据库的列不能为空。@Size一般说明字符串类型的长度范围，对应数据库里的char或varchar等类型。@GeneratedValue(strategy = GenerationType.IDENTITY)说明主键的生成策略采用了数据库自身的自增长主键。</p>
<p>　　@ManyToOne和@OneToMany说明了该实体对应的表与实体对应的表的外键引用关系，通过这些关系可以比较方便的实现Entity的连接。类似的还有@OneToOne和@ManyToMany。</p>
<p>　　然后便是对每一个属性的getter和setter方法。Entity类必须含有一个空的构造方法。</p>
<p>　　该类实现了Serializable接口，并且打上了@XmlRootElement标注，表明该实体可以被序列化，直接作为数据进行输入输出。这时候它既属于Entity也属于Boundary，没有经过数据的再封装。只有需要不同的Entity的数据组合，或者需要多次查询多个实体的数据，则需要在Boundary下再定义一个专门用于数据传输的POJO类。</p>
<p>　　我们只要有一个大概的认识，了解一下实体是怎么与数据库的表映射在一起的。这里面广泛使用了注解，代码很少，配置简单。其实Entity类基本不用自己写的，IDE里只要连接了数据库，通常可以直接从数据库一键生成Entity类，根据数据库的结构自动地配置好所有标注与变量，我们只需把重点放在Boundary与Control部分即可。</p>
<p>　　这里有一点需要注意一下，从数据库的表一键生成Entity类时，我们需要指定一个数据库的表，作为Entity的基础，并且会自动把与其相关联的有外键引用关系的表一起生成为其他Entity。但是，其外键的引用关系只能是同一个schema里的，如果是不同schema之间的外键引用，则无法做到ORM。反正我的试验下是这样的，如果有正确的方法实现不同schema之间的ORM，希望不吝赐教~</p>
<h4 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h4><p>　　控制层是JPA的关键与重点，我们的绝大部分业务逻辑都集中在控制层内。下面我们从EJB，EntityManager以及Query API三个方面来介绍一下Control层。</p>
<h5 id="EJB"><a href="#EJB" class="headerlink" title="EJB"></a>EJB</h5><p>　　EJB,即EnterPrise JaveBean，是分离视图层与数据库访问的一层技术，是Control的核心，是数据库接口与业务逻辑的封装体。它有自己的生命周期管理机制，是一套跨application server的独立组件。它可以是有状态和无状态的。无状态的EJB说明其每次调用都是无记忆无状态的，是没有关联的。一般应尽量使用无状态的EJB，其能够具备最好的线程安全性与并发性。而且，我们绝大多数的应用场景用无状态的EJB便能满足，特别是基于http的RESTful API的实现。下面重点介绍一下无状态的EJB，即stateless EJB。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Stateless</span></div><div class="line"><span class="meta">@RolesAllowed</span>(&#123;<span class="string">"operator"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageService</span> </span>&#123;</div><div class="line">    <span class="meta">@PersistenceContext</span>(unitName = <span class="string">"com.hudoumiao_sampleweb_war_1.0-SNAPSHOTPU"</span>)</div><div class="line">    <span class="keyword">private</span> EntityManager em;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> List&lt;Object[]&gt; findDangerousMessages(<span class="keyword">int</span> page,<span class="keyword">int</span> perPage)&#123;</div><div class="line">        String sql = <span class="string">"(select message1.word,message1.comment_count,message1.transmission_count,message1.id,message1.publish_date,"</span> +</div><div class="line">                        <span class="string">"message2.word,message2.comment_count,message2.transmission_count,message2.id,message2.publish_date,"</span> +</div><div class="line">                        <span class="string">"subscriber1.username,subscriber2.username,subscriber1.id,subscriber2.id,manager.dangerous_message.managed_date,"</span> +</div><div class="line">                        <span class="string">"manager.action.action_name,account.auth_user.name from manager.dangerous_message left outer join "</span> +</div><div class="line">                        <span class="string">"message message1 on(manager.dangerous_message.message_id = message1.id) left outer join account.auth_user "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.manager_id = account.auth_user.id) left outer join manager.action "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.action_id = manager.action.id) left outer join message message2 on(message1.reference_id = message2.id)"</span> +</div><div class="line">                        <span class="string">"inner join subscriber subscriber1 on (message1.subscriber_id = subscriber1.id) left outer join subscriber subscriber2 on (message2.subscriber_id = subscriber2.id) "</span> +</div><div class="line">                        <span class="string">"where message1.is_deleted = false and message1.is_blocked = false and message1.is_removed = false)"</span> +                        </div><div class="line">                        <span class="string">"order by 2 desc,5 desc "</span> +</div><div class="line">                        <span class="string">"limit "</span> + perPage + <span class="string">"offset "</span> + (page - <span class="number">1</span>) * <span class="number">10</span>;</div><div class="line">        <span class="keyword">return</span> em.createNativeQuery(sql).getResultList();       </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countDangerousMessage</span><span class="params">()</span></span>&#123;</div><div class="line">        String sql = <span class="string">"select count(manager.dangerous_message.id) from manager.dangerous_message left outer join message "</span></div><div class="line">                + <span class="string">"on(manager.dangerous_message.message_id = message.id) where message.is_deleted = false and "</span></div><div class="line">                + <span class="string">"message.is_blocked = false and message.is_removed = false"</span>;</div><div class="line">        <span class="keyword">return</span> (Long)em.createNativeQuery(sql).getSingleResult();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSolvedMessages</span><span class="params">()</span></span>&#123;</div><div class="line">        String sql = <span class="string">"select count(manager.dangerous_message.id) from manager.dangerous_message left outer join message "</span></div><div class="line">                + <span class="string">"on(manager.dangerous_message.message_id = message.id) where message.is_deleted = false and "</span></div><div class="line">                + <span class="string">"(message.is_blocked = true or message.is_removed = true)"</span>;</div><div class="line">        <span class="keyword">return</span> (Long)em.createNativeQuery(sql).getSingleResult();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> List&lt;Object[]&gt; findSolvedMessages(<span class="keyword">int</span> page,<span class="keyword">int</span> perPage)&#123;</div><div class="line">        String sql = <span class="string">"(select message1.word,message1.comment_count,message1.transmission_count,message1.id,message1.publish_date,"</span> +</div><div class="line">                        <span class="string">"message2.word,message2.comment_count,message2.transmission_count,message2.id,message2.publish_date,"</span> +</div><div class="line">                        <span class="string">"subscriber1.username,subscriber2.username,subscriber1.id,subscriber2.id,message1.is_removed,message1.is_blocked,manager.dangerous_message.managed_date,"</span> +</div><div class="line">                        <span class="string">"manager.action.action_name,account.auth_user.name from manager.dangerous_message left outer join "</span> +</div><div class="line">                        <span class="string">"message message1 on(manager.dangerous_message.message_id = message1.id) left outer join account.auth_user "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.manager_id = account.auth_user.id) left outer join manager.action "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.action_id = manager.action.id) left outer join message message2 on(message1.reference_id = message2.id)"</span> +</div><div class="line">                        <span class="string">"inner join subscriber subscriber1 on (message1.subscriber_id = subscriber1.id) left outer join subscriber subscriber2 on (message2.subscriber_id = subscriber2.id) "</span> +</div><div class="line">                        <span class="string">"where message1.is_removed = true and message1.is_deleted = false)"</span> +  </div><div class="line">                     <span class="string">"union"</span> +</div><div class="line">                     <span class="string">"(select message1.word,message1.comment_count,message1.transmission_count,message1.id,message1.publish_date,"</span> +</div><div class="line">                        <span class="string">"message2.word,message2.comment_count,message2.transmission_count,message2.id,message2.publish_date,"</span> +</div><div class="line">                        <span class="string">"subscriber1.username,subscriber2.username,subscriber1.id,subscriber2.id,message1.is_removed,message1.is_blocked,manager.dangerous_message.managed_date,"</span> +</div><div class="line">                        <span class="string">"manager.action.action_name,account.auth_user.name from manager.dangerous_message left outer join "</span> +</div><div class="line">                        <span class="string">"message message1 on(manager.dangerous_message.message_id = message1.id) left outer join account.auth_user "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.manager_id = account.auth_user.id) left outer join manager.action "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.action_id = manager.action.id) left outer join message message2 on(message1.reference_id = message2.id)"</span> +</div><div class="line">                        <span class="string">"inner join subscriber subscriber1 on (message1.subscriber_id = subscriber1.id) left outer join subscriber subscriber2 on (message2.subscriber_id = subscriber2.id) "</span> +</div><div class="line">                        <span class="string">"where message1.is_blocked = true and message1.is_deleted = false)"</span> +</div><div class="line">                        <span class="string">"order by 2 desc,5 desc "</span> +</div><div class="line">                        <span class="string">"limit "</span> + perPage + <span class="string">"offset "</span> + (page - <span class="number">1</span>) * <span class="number">10</span>;</div><div class="line">        <span class="keyword">return</span> em.createNativeQuery(sql).getResultList();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;SumItem&gt; <span class="title">sumMessage</span><span class="params">()</span></span>&#123;</div><div class="line">        String sql = <span class="string">"select count(to_char(publish_date,'yyyy-mm-dd')),to_char(publish_date,'yyyy-mm-dd') from message "</span> +</div><div class="line">                   <span class="string">"where publish_date &gt; current_date - interval '9 day' "</span> +</div><div class="line">                   <span class="string">"group by to_char(publish_date,'yyyy-mm-dd') order by to_char(publish_date,'yyyy-mm-dd')"</span>;</div><div class="line">        List&lt;Object[]&gt; results = em.createNativeQuery(sql).getResultList();</div><div class="line">        List&lt;SumItem&gt; messageSum = <span class="keyword">new</span> ArrayList();        </div><div class="line">        Calendar cal = Calendar.getInstance();</div><div class="line">        cal.add(Calendar.DAY_OF_MONTH, -<span class="number">9</span>);</div><div class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">        String start = sdf.format(cal.getTime());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;                      </div><div class="line">            SumItem sumItem = <span class="keyword">new</span> SumItem();</div><div class="line">            sumItem.setCount(<span class="number">0</span>);</div><div class="line">            sumItem.setDate(sdf.format(cal.getTime()));</div><div class="line">            messageSum.add(sumItem);</div><div class="line">            cal.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">        &#125;                </div><div class="line">        <span class="keyword">if</span>(!results.isEmpty())&#123;</div><div class="line">            <span class="keyword">for</span>(Object[] result : results)&#123;</div><div class="line">                String end = (String)result[<span class="number">1</span>];</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    <span class="keyword">int</span> interval = (<span class="keyword">int</span>)((sdf.parse(end).getTime() - sdf.parse(start).getTime()) / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>)); </div><div class="line">                    messageSum.get(interval).setCount(((Long)result[<span class="number">0</span>]).intValue());</div><div class="line">                &#125;<span class="keyword">catch</span>(ParseException e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> messageSum;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;SumItem&gt; <span class="title">sumComment</span><span class="params">()</span></span>&#123;</div><div class="line">        String sql = <span class="string">"select count(to_char(create_date,'yyyy-mm-dd')),to_char(create_date,'yyyy-mm-dd') from commentary "</span> +</div><div class="line">                   <span class="string">"where create_date &gt; current_date - interval '9 day' "</span> +</div><div class="line">                   <span class="string">"group by to_char(create_date,'yyyy-mm-dd') order by to_char(create_date,'yyyy-mm-dd')"</span>;</div><div class="line">        List&lt;Object[]&gt; results = em.createNativeQuery(sql).getResultList();</div><div class="line">        List&lt;SumItem&gt; commentSum = <span class="keyword">new</span> ArrayList();</div><div class="line">        Calendar cal = Calendar.getInstance();</div><div class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">        cal.add(Calendar.DAY_OF_MONTH, -<span class="number">9</span>);</div><div class="line">        String start = sdf.format(cal.getTime());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</div><div class="line">            SumItem sumItem = <span class="keyword">new</span> SumItem();</div><div class="line">            sumItem.setCount(<span class="number">0</span>);</div><div class="line">            sumItem.setDate(sdf.format(cal.getTime()));</div><div class="line">            commentSum.add(sumItem);</div><div class="line">            cal.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">if</span>(!results.isEmpty())&#123;</div><div class="line">            <span class="keyword">for</span>(Object[] result : results)&#123;</div><div class="line">                String end = (String)result[<span class="number">1</span>];</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    <span class="keyword">int</span> interval = (<span class="keyword">int</span>)((sdf.parse(end).getTime() - sdf.parse(start).getTime()) / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</div><div class="line">                    commentSum.get(interval).setCount(((Long)result[<span class="number">0</span>]).intValue());</div><div class="line">                &#125;<span class="keyword">catch</span>(ParseException e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> commentSum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Stateless</span></div><div class="line"><span class="meta">@RolesAllowed</span>(&#123;<span class="string">"operator"</span>&#125;)</div><div class="line"><span class="meta">@Path</span>(<span class="string">"message"</span>)</div><div class="line"><span class="meta">@Tracked</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFacadeREST</span> <span class="keyword">extends</span> <span class="title">AbstractFacade</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@PersistenceContext</span>(unitName = <span class="string">"com.hudoumiao_sampleweb_war_1.0-SNAPSHOTPU"</span>)</div><div class="line">    <span class="keyword">private</span> EntityManager em;</div><div class="line">    <span class="meta">@EJB</span></div><div class="line">    MessageService messageService;</div><div class="line">    <span class="meta">@EJB</span></div><div class="line">    CommentService commentService;</div></pre></td></tr></table></figure>
<p>　　第一段代码是EJB的定义类，@stateless标注说明是无状态的EJB。其必须含有无参的构造函数，这里用默认的无参构造函数。我们可以先忽略类里各方法的实现细节，但不难看出，每个方法都是对数据库的操作，以及获取数据后的一些处理。这就是我们的数据库访问与业务逻辑，全部封装在EJB里。</p>
<p>　　第二段代码是注入EJB到类变量里。这里的MessageFacadeRest是JAX-RS的Resource类，我们需要借助EJB来处理业务逻辑，然后返回处理过后的数据到Resource类的相应方法内以供RESTful API访问。@EJB就表示EJB实体对象。</p>
<p>　　我们每调用一次EJB的实体对象，都会经历一次EJB的生命周期，下面简单阐述一下其生命周期的流程。我们所用的application server container，例如GlassFish,Tomcat等，都会维护一个EJB pool，类似数据库连接池或者线程池，都是预先存放好一定数量的EJB实体对象，需要调用的时候从中抽取，调用完毕再由池回收。这整个过程application server container都会帮我们管理。</p>
<ol>
<li>首先，container会根据EJB的无参构造函数创建EJB。</li>
<li>EJB里的资源会根据注解注入，例如第一段代码的@EntityManager，这是数据库连接资源，后面再详细介绍。</li>
<li>建立EJB池，把建立好的EJB放入池中。</li>
<li>如果客户端有请求访问EJB，如果池中有空闲的EJB则会抽取出来给客户端使用，如果没有空闲的EJB，则会创建更多的EJB实体。</li>
<li>执行EJB业务逻辑。</li>
<li>业务逻辑执行完毕后，EJB归还池中。</li>
<li>根据需要移除EJB实体。</li>
</ol>
<p>　　EJB很好的封装了业务逻辑与数据库访问，把数据库与视图分离，且EJB pool很好地处理了线程安全与并发的问题。</p>
<h5 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h5><p>　　JPA关键在于实现ORM,前面我们介绍了Entity，但单靠创建Entity，我们是无法实现ORM的。要实现ORM，我们需要一个Persistence Unit，即持久化单元。我们依靠Persistence Unit去建立数据库连接。通过Persistent Unit，我们可以注入EntityManager，进而实现数据库业务逻辑的增删改查。</p>
<p>　　我们需要现在相应的第三方ORM框架的配置文件persistence.xml里定义Persistence Unit:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">version</span>=<span class="string">"2.1"</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/persistence"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">"com.hudoumiao_sampleweb_war_1.0-SNAPSHOTPU"</span> <span class="attr">transaction-type</span>=<span class="string">"JTA"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">jta-data-source</span>&gt;</span>jdbc/weibo<span class="tag">&lt;/<span class="name">jta-data-source</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">exclude-unlisted-classes</span>&gt;</span>false<span class="tag">&lt;/<span class="name">exclude-unlisted-classes</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></div></pre></td></tr></table></figure>
<p>　　比较重要的是name属性，这个属性是我们在EJB里引用persistence unit所需要的。上面介绍EJB代码里已有相关示例。当我们要把项目部署到application server container里，我们需要使用transaction-type=”JTA”。在这种transaction-type下，我们不需要罗列需要引入的entity class，只需在jta-data-source里指定数据库就行。并且数据库的详细配置我们不需要再persistence.xml里写，只需在application server container的配置文件里配置好就行。例如，如果用GlassFish作为application server container,则配置文件glassfish-resources.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">jdbc-connection-pool</span> <span class="attr">allow-non-component-callers</span>=<span class="string">"false"</span> <span class="attr">associate-with-thread</span>=<span class="string">"false"</span> <span class="attr">connection-creation-retry-attempts</span>=<span class="string">"0"</span> <span class="attr">connection-creation-retry-interval-in-seconds</span>=<span class="string">"10"</span> <span class="attr">connection-leak-reclaim</span>=<span class="string">"false"</span> <span class="attr">connection-leak-timeout-in-seconds</span>=<span class="string">"0"</span> <span class="attr">connection-validation-method</span>=<span class="string">"auto-commit"</span> <span class="attr">datasource-classname</span>=<span class="string">"org.postgresql.ds.PGSimpleDataSource"</span> <span class="attr">fail-all-connections</span>=<span class="string">"false"</span> <span class="attr">idle-timeout-in-seconds</span>=<span class="string">"300"</span> <span class="attr">is-connection-validation-required</span>=<span class="string">"false"</span> <span class="attr">is-isolation-level-guaranteed</span>=<span class="string">"true"</span> <span class="attr">lazy-connection-association</span>=<span class="string">"false"</span> <span class="attr">lazy-connection-enlistment</span>=<span class="string">"false"</span> <span class="attr">match-connections</span>=<span class="string">"false"</span> <span class="attr">max-connection-usage-count</span>=<span class="string">"0"</span> <span class="attr">max-pool-size</span>=<span class="string">"32"</span> <span class="attr">max-wait-time-in-millis</span>=<span class="string">"60000"</span> <span class="attr">name</span>=<span class="string">"post-gre-sql_weibo_postgresPool"</span> <span class="attr">non-transactional-connections</span>=<span class="string">"false"</span> <span class="attr">pool-resize-quantity</span>=<span class="string">"2"</span> <span class="attr">res-type</span>=<span class="string">"javax.sql.DataSource"</span> <span class="attr">statement-timeout-in-seconds</span>=<span class="string">"-1"</span> <span class="attr">steady-pool-size</span>=<span class="string">"8"</span> <span class="attr">validate-atmost-once-period-in-seconds</span>=<span class="string">"0"</span> <span class="attr">wrap-jdbc-objects</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serverName"</span> <span class="attr">value</span>=<span class="string">"localhost"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"portNumber"</span> <span class="attr">value</span>=<span class="string">"5432"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"databaseName"</span> <span class="attr">value</span>=<span class="string">"weibo"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">value</span>=<span class="string">"postgres"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Password"</span> <span class="attr">value</span>=<span class="string">"gdzqzxwjs95"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"URL"</span> <span class="attr">value</span>=<span class="string">"jdbc:postgresql://localhost:5432/weibo"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"org.postgresql.Driver"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">jdbc-connection-pool</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">jdbc-resource</span> <span class="attr">enabled</span>=<span class="string">"true"</span> <span class="attr">jndi-name</span>=<span class="string">"jdbc/weibo"</span> <span class="attr">object-type</span>=<span class="string">"user"</span> <span class="attr">pool-name</span>=<span class="string">"post-gre-sql_weibo_postgresPool"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>　　上面的定义的jndi-name就是persistence.xml引用的数据库凭据。</p>
<p>　　持久化单元(persist unit)就是关于一组Entity的命名配置。持久化单元是一个静态概念。</p>
<p>　　持久化上下文(Persist Context)就是一个受管的Entity实例的集合。每一个持久化上下文都关联一个持久化单元，持久化上下文不可能脱离持久化单元独立存在。持久化上下文是一个动态概念。</p>
<p>　　尽管持久化上下文非常重要，但是开发者不直接与之打交道，持久化上下文在程序中是透明的，我们通过EntityManager间接管理它。</p>
<p>　　利用EntityManager我们便能够完成数据库的增删改查。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFacade</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> Class&lt;T&gt; entityClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractFacade</span><span class="params">(Class&lt;T&gt; entityClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.entityClass = entityClass;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> EntityManager <span class="title">getEntityManager</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(T entity)</span> </span>&#123;</div><div class="line">        getEntityManager().persist(entity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(T entity)</span> </span>&#123;</div><div class="line">        getEntityManager().merge(entity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T entity)</span> </span>&#123;</div><div class="line">        getEntityManager().remove(getEntityManager().merge(entity));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">find</span><span class="params">(Object id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getEntityManager().find(entityClass, id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">        javax.persistence.criteria.CriteriaQuery cq = getEntityManager().getCriteriaBuilder().createQuery();</div><div class="line">        cq.select(cq.from(entityClass));</div><div class="line">        <span class="keyword">return</span> getEntityManager().createQuery(cq).getResultList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">findRange</span><span class="params">(<span class="keyword">int</span>[] range)</span> </span>&#123;</div><div class="line">        javax.persistence.criteria.CriteriaQuery cq = getEntityManager().getCriteriaBuilder().createQuery();</div><div class="line">        cq.select(cq.from(entityClass));</div><div class="line">        javax.persistence.Query q = getEntityManager().createQuery(cq);</div><div class="line">        q.setMaxResults(range[<span class="number">1</span>] - range[<span class="number">0</span>] + <span class="number">1</span>);</div><div class="line">        q.setFirstResult(range[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">return</span> q.getResultList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">        javax.persistence.criteria.CriteriaQuery cq = getEntityManager().getCriteriaBuilder().createQuery();</div><div class="line">        javax.persistence.criteria.Root&lt;T&gt; rt = cq.from(entityClass);</div><div class="line">        cq.select(getEntityManager().getCriteriaBuilder().count(rt));</div><div class="line">        javax.persistence.Query q = getEntityManager().createQuery(cq);</div><div class="line">        <span class="keyword">return</span> ((Long) q.getSingleResult()).intValue();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这是一个通用的jax-rs资源类模板，通过继承这一个类，我们能够实现最基本的增删改查，分别对应EntityManager.persist()，EntityManager.remove()，EntityManager.merge()，EntityManager.find()。其中find方法一般只能根据id查找单个实体，如果需要做更复杂的查询还需要用到Query API,后面一节会详细介绍。这里，我们先简单介绍一下EntityManager的状态。</p>
<p>　　EntityManager管理的实体有4个状态，new,managed,detached,removed。</p>
<p>　　当我们通过构造函数新创建一个entity对象时，它属于new状态，此时它的数据与数据库是不同步的，是不在persistence context里的。当我们调用persist方法后，它将获得自己的主键，与数据库同步，转化为managed状态，进入persistence context。</p>
<p>　　如果我们remove某个处于merged状态的entity，则它将变为removed状态。凡是被查找出来的实体，其状态都为managed，其变化与数据库同步，处于persistence context。</p>
<p>　　所有处于detached状态的entity都游离于persistence context之外。如果我们对某个处于detached状态的实体调用merge方法，则会变成managed状态，其实体里的数据将同步到数据库。</p>
<p>　　只要实体与数据库同步，我们便真正地实现了ORM。</p>
<h5 id="Query-API"><a href="#Query-API" class="headerlink" title="Query API"></a>Query API</h5><h6 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h6><p>　　我们知道，EntityManager的find方法只能查询某id的一个实体，如果要做复杂的查询则必须用到JPA的Query API。下面先以一段代码来认识一下Query API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;Object[]&gt; findDangerousMessages(<span class="keyword">int</span> page,<span class="keyword">int</span> perPage)&#123;</div><div class="line">       String sql = <span class="string">"(select message1.word,message1.comment_count,message1.transmission_count,message1.id,message1.publish_date,"</span> +</div><div class="line">                       <span class="string">"message2.word,message2.comment_count,message2.transmission_count,message2.id,message2.publish_date,"</span> +</div><div class="line">                       <span class="string">"subscriber1.username,subscriber2.username,subscriber1.id,subscriber2.id,manager.dangerous_message.managed_date,"</span> +</div><div class="line">                       <span class="string">"manager.action.action_name,account.auth_user.name from manager.dangerous_message left outer join "</span> +</div><div class="line">                       <span class="string">"message message1 on(manager.dangerous_message.message_id = message1.id) left outer join account.auth_user "</span> +</div><div class="line">                       <span class="string">"on(manager.dangerous_message.manager_id = account.auth_user.id) left outer join manager.action "</span> +</div><div class="line">                       <span class="string">"on(manager.dangerous_message.action_id = manager.action.id) left outer join message message2 on(message1.reference_id = message2.id)"</span> +</div><div class="line">                       <span class="string">"inner join subscriber subscriber1 on (message1.subscriber_id = subscriber1.id) left outer join subscriber subscriber2 on (message2.subscriber_id = subscriber2.id) "</span> +</div><div class="line">                       <span class="string">"where message1.is_deleted = false and message1.is_blocked = false and message1.is_removed = false)"</span> +                        </div><div class="line">                       <span class="string">"order by 2 desc,5 desc "</span> +</div><div class="line">                       <span class="string">"limit "</span> + perPage + <span class="string">"offset "</span> + (page - <span class="number">1</span>) * <span class="number">10</span>;</div><div class="line">       <span class="keyword">return</span> em.createNativeQuery(sql).getResultList();       </div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countDangerousMessage</span><span class="params">()</span></span>&#123;</div><div class="line">       String sql = <span class="string">"select count(manager.dangerous_message.id) from manager.dangerous_message left outer join message "</span></div><div class="line">               + <span class="string">"on(manager.dangerous_message.message_id = message.id) where message.is_deleted = false and "</span></div><div class="line">               + <span class="string">"message.is_blocked = false and message.is_removed = false"</span>;</div><div class="line">       <span class="keyword">return</span> (Long)em.createNativeQuery(sql).getSingleResult();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>　　由上面代码看到，我们定义了一段sql的字符串，然后调用EntityManager的createNativeQuery方法，便可以进行数据库查询。如果要返回多个属性或多条记录，可以用getResultList方法来返回;如果只返回一个属性值，可以用getSingleResult方法。这是最基本的Query API与数据库访问方法，非常简单，只要有sql与数据库基础便可以轻松开发。</p>
<p>　　除了用传统的sql语言作查询外，Query API还有一种面向对象的数据库查询语言JPQL，其语法与sql很相似，它的查询是针对ORM后的Entity class的。以字符串形式存储相应的jpql语句，然后调用createQuery方法进行查询，仍然可以用getResultList以及getSingleResult的方法返回结果。</p>
<p>　　Query API的更多方法以及JPQL的具体语法可以自行查阅资料，网上资源也很多，这里就不展开赘述了。在开发的时候查查就行，用多了就熟练了，就像sql语言一样。一般大部分sql操作都能用JPQL实现。</p>
<p>　　我们还能用@NameQuery的形式预先定义好查询语句，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="meta">@Table</span>(name = <span class="string">"dangerous_message"</span>, catalog = <span class="string">"weibo"</span>, schema = <span class="string">"manager"</span>)</div><div class="line"><span class="meta">@XmlRootElement</span></div><div class="line"><span class="meta">@NamedQueries</span>(&#123;</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"DangerousMessage.findAll"</span>, query = <span class="string">"SELECT d FROM DangerousMessage d"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"DangerousMessage.findById"</span>, query = <span class="string">"SELECT d FROM DangerousMessage d WHERE d.id = :id"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"DangerousMessage.findByMessageId"</span>, query = <span class="string">"SELECT d FROM DangerousMessage d WHERE d.messageId = :messageId"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"DangerousMessage.findByManagerId"</span>, query = <span class="string">"SELECT d FROM DangerousMessage d WHERE d.managerId = :managerId"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"DangerousMessage.findByManagedDate"</span>, query = <span class="string">"SELECT d FROM DangerousMessage d WHERE d.managedDate = :managedDate"</span>)&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DangerousMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div></pre></td></tr></table></figure></p>
<p>　　上面就是用jpql语法预先定义好一些常用的查询语句。类似的，用sql也可以预先定义查询，此时的标注是@NameNativeQuery。如果在类名前用@NameQuery注解定义好一些查询语句，在代码里需要进行查询时候只需要用name作标识就可以，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DangerousMessage dangerousMessage = (DangerousMessage)em.createNamedQuery(<span class="string">"DangerousMessage.findByMessageId"</span>).setParameter(<span class="string">"messageId"</span>,id).getSingleResult();</div></pre></td></tr></table></figure></p>
<h6 id="查询方式的选择"><a href="#查询方式的选择" class="headerlink" title="查询方式的选择"></a>查询方式的选择</h6><p>　　总而言之，我们可以选择sql语句或者jpql语句作为Query API的参数进行数据库查询；确定了语言后我们还可以选择是用标准的查询形式还是预先定义的查询。如果进行复杂的数据库查询，或者一些jpql无法实现的查询，我们优先选择用sql语言实现。而在一般情况下，我们推荐使用JPQL，因为它更贴近面向对象的思想，且其实现与底层的数据库是无关的。换言之，我们可以用一套jpql语法来处理不同数据库的查询工作，如果更换数据库，我们的代码仍然能正常运行，而不用像sql语言一样每个数据库都有自己的一套语法。</p>
<p>　　如果查询语句是动态变化，不固定的，那么只能用标准的查询方式。否则，推荐采用预先定义的查询。预先定义的查询语句存放在固定的地方，并且有更好的性能。只要进行了一次预定义查询，后面进行的查询就不用再编译，而是运行之前编译好的缓存的查询语句。</p>
<h4 id="Boundary"><a href="#Boundary" class="headerlink" title="Boundary"></a>Boundary</h4><p>　　JAX-RS的Resource组件类通常便是我们所说的Boudary。我们在Resource里调用Control层的EJB来进行业务逻辑的运算与数据库访问，然后在Boudary层组装查询的结果。如果查询结果正好是Entity对象，则直接将其序列化传输就行；如果需要另外组合，则定义一个POJO类做为数据传输类(DTO)，将其序列化传输。下面是微博评论系统的结构设计：</p>
<p><img src="/img/system-structure.png" alt="BCE模型结构"></p>
<p>　　类名里含DTO的都是新定义的作数据传输的POJO类，MessageFacadeREST是Resource组件类，它继承了AbstractFacaceREST。MessageService是EJB类，封装了大部分的数据库访问与业务逻辑。Entity包里都是ORM后的实体对象。</p>
<p>　　其实，MessageFacadeREST也是EJB实体，因为重组数据也是业务逻辑之一。所以，EJB不一定只属于Control层，Boundary层也是需要的，只是我们为了介绍方便放在Control层里讲述而已。Control层的EJB主要用于数据库访问与一些业务逻辑的运算，我们希望尽可能把JPA标准里绝大多数的业务逻辑都放到Control层内。Boundary层的EJB对象则主要处理数据的再封装，以及一些JAX-RS里对于http response的header与body的一些处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　这一次主要以BCE模型结构入手，讲述了JPA标准的基本知识，以及其与JAX-RS是怎么联合起来实现一套RESTful API的后台系统的。如果业务逻辑比较简单，我们也可以不严格按照BCE模型，省略了Control层，而把所有业务逻辑以及数据库访问都放在Boundary层的EJB内。如果系统较大，建议尽量用BCE的结构。</p>
<p>　　</p>
<p>　　
　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RESTful API规范补充以及JAX-RS传递参数的方法]]></title>
      <url>http://wjqwsp.github.io/2016/08/23/RESTful-API%E8%A7%84%E8%8C%83%E8%A1%A5%E5%85%85/</url>
      <content type="html"><![CDATA[<h3 id="搜索的过滤与排序"><a href="#搜索的过滤与排序" class="headerlink" title="搜索的过滤与排序"></a>搜索的过滤与排序</h3><p>　　搜索在RESTful API里是用GET方法实现的，URI一般是某个对象，可以是单个也可以是列表。以微博搜索为例，如果不加任何条件，其URI一般是这样的：</p>
<pre><code>/api/weibo</code></pre>
<pre><code>/api/weibo/6</code></pre>

<p>　　但往往还需要限制一下搜索条件，例如评论数大于某个数，或者含有什么关键字，如果是搜索微博列表，也可能加上对日期作升序或降序排序的要求。这些附加条件，是作为query param附加在http请求里的。例如：<br><a id="more"></a></p>
<ul>
<li>GET /weibo?deleted=true - 得到所有标记为删除的微博</li>
<li>GET /weibo?sort=-create-date - 按照创建日期反序排序得到微博列表</li>
<li>GET /weibo?sort=comment-count,-create-date - 先按微博评论数再按创建日期反序排序得到微博列表</li>
<li>GET /weibo?keyword=xxx - 得到包含关键字xxx的微博列表</li>
<li>GET /weibo?keyword=xxx&amp;deleted=true&amp;sort=comment-count,-create-date - 搜索关键字包含xxx的标记为删除的微博，按照评论数再按创建日期反序排序得到微博列表</li>
</ul>
<p>　　确定了搜索对象，例如weibo，那么在服务器端我们就知道需要查找哪个表，或者需要连接哪几个表。where后面的条件则根据附上的参数动态选择。order by后面的属性则根据sort后面的参数添加，带-号的代表降序，很容易翻译成sql语言。</p>
<p>　　我们还可以选择返回哪些属性，或者不返回哪些属性。例如：</p>
<ul>
<li>GET /weibo?fields=id,subject - 得到微博列表，每个微博里的字段只有id和subject两个，其他的都排除了。</li>
<li>GET /weibo?fields-exclude=id,subject - 得到微博列表，每个微博里的id和subject被排除了，输出其他的字段。</li>
</ul>
<p>　　这些参数就是select后面的列信息。</p>
<p>　　由于RESTful API的资源是面向对象的，我们往往是对某一个对象作查找，如果在查找里需要附带其他资源对象的信息，也可以在query param里添加，用embed字段作为key。例如：</p>
<ul>
<li>GET /weibo?embed=owner.id,owner.name - 得到微博列表，每个微博里的信息里加入这个微博的所有者的id和name两个属性。</li>
</ul>
<p>　　这些属性也是跟在select后面的，只要参数名与数据库的表名能一一对应即可。由于存在嵌入的对象属性，在数据库查找上往往便需要多表连接。</p>
<p>　　上一讲说的翻页的页数和每页的数据项数也是作为query param传给服务器的。</p>
<h3 id="常用的查询"><a href="#常用的查询" class="headerlink" title="常用的查询"></a>常用的查询</h3><p>　　上面说的对搜索的过滤和排序是通用的，根据传入的参数而动态构造sql语句。而对于某些特别常用的查询，例如新浪微博里的最热微博top10，则可以用专用的名字代替，例如：</p>
<ul>
<li>GET /weibo/top10</li>
</ul>
<h3 id="不太能归类的操作"><a href="#不太能归类的操作" class="headerlink" title="不太能归类的操作"></a>不太能归类的操作</h3><p>　　http是面向资源的，RESTful API是基于http的，其操作也是针对某个资源对象进行的，操作的类型则用http方法表达，例如PUT,POST,PATCH,DELETE,GET。然而，有些操作不是那么容易归类为上述的http方法，例如给微博点赞。我们可以把点赞操作理解成修改微博对象，按照这个定义是应该用PUT或PATCH方法。但是一般意义上我们说的对微博的修改是指编辑微博的文本内容。因此，有必要把点赞这个操作独立出来，会更加方便，意义也更加清晰。例如：</p>
<ul>
<li>PUT /weibo/12/like - 给某个微博点赞</li>
<li>DELETE /weibo/12/like - 删除某个微博的赞</li>
</ul>
<h3 id="常用的status-code"><a href="#常用的status-code" class="headerlink" title="常用的status code"></a>常用的status code</h3><ul>
<li>200 OK - 正常返回，用于GET, PUT, PATCH的这些正常操作。</li>
<li>201 Created - 用于POST创建对象正常返回。</li>
<li>204 No Content - 用于DELETE，成功操作但没啥返回的。</li>
<li>304 Not Modified - 有Cache，表示没改过。</li>
<li>400 Bad Request - 指请求里面有些参数不对。</li>
<li>401 Unauthorized - 没有登录</li>
<li>403 Forbidden - 登录了但是没有授权访问某个资源</li>
<li>404 Not Found - 资源不存在</li>
<li>405 Method Not Allowed - 登录了但是不允许做某个操作</li>
<li>410 Gone - 表示资源不再提供了，用来做老版本提示用的</li>
<li>415 Unsupported Media Type - 請求的Centent Type不對</li>
<li>422 Unprocessable Entity - 一般用于validation校验</li>
<li>429 Too Many Requests - 请求太快太多，达到限制</li>
</ul>
<p>　　http提供了很多的status code。但在RESTful API里常用的就这几个。我们可以根据业务需求对不同的request返回相匹配的状态码。方法就是上一讲提到的构造Response对象返回以及异常处理。</p>
<h3 id="JAX-RS怎样接收客户端的参数"><a href="#JAX-RS怎样接收客户端的参数" class="headerlink" title="JAX-RS怎样接收客户端的参数"></a>JAX-RS怎样接收客户端的参数</h3><p>　　RESTful API的核心是URI，HTTP方法以及数据传输格式，在第一讲详细讲过。http header也十分重要，在第二讲讲过。除此之外，服务器与客户端的交互往往需要传递一些参数，例如对象id，需要更新的整个对象以及上面提到的query param等。这些参数的传递都是通过注解实现的。下面介绍一下常用的参数注解。</p>
<h5 id="PathParam"><a href="#PathParam" class="headerlink" title="PathParam"></a>PathParam</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PATCH</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"&#123;id&#125;/remove"</span>)</div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(@PathParam(<span class="string">"id"</span>)</span> Long id,@Context HttpServletRequest request) </span>&#123;</div></pre></td></tr></table></figure>
<p>　　需要删除某条微博，此时URI里必定含有该微博的id信息，可以用@PathParam注解从URI里提取参数。</p>
<h5 id="QueryParam"><a href="#QueryParam" class="headerlink" title="QueryParam"></a>QueryParam</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"danger-unsolved"</span>)</div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json;charset=UTF-8"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">findUnSolved</span><span class="params">(@QueryParam(<span class="string">"page"</span>)</span> <span class="keyword">int</span> page,@<span class="title">QueryParam</span><span class="params">(<span class="string">"per-page"</span>)</span> <span class="keyword">int</span> perPage,@Context HttpServletResponse response) </span>&#123;</div></pre></td></tr></table></figure>
<p>　　翻页信息用query param传递，用@QueryParam注解可以提取。</p>
<h5 id="FormParam"><a href="#FormParam" class="headerlink" title="FormParam"></a>FormParam</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@POST</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"login"</span>)</div><div class="line"><span class="meta">@PermitAll</span></div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/x-www-form-urlencoded"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">login</span><span class="params">(@Context HttpServletRequest request,</span></span></div><div class="line">        @Context HttpServletResponse response,</div><div class="line">        @FormParam(<span class="string">"username"</span>) String username,</div><div class="line">        @<span class="title">FormParam</span><span class="params">(<span class="string">"password"</span>)</span> String password,</div><div class="line">        @<span class="title">FormParam</span><span class="params">(<span class="string">"remember_me"</span>)</span> String rememberMe) &#123;</div></pre></td></tr></table></figure>
<p>　　用POST请求提交的表格，其表单内容可以用@FormParam获取。</p>
<h5 id="MatrixParam"><a href="#MatrixParam" class="headerlink" title="MatrixParam"></a>MatrixParam</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Path</span>(<span class="string">"/books"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@GET</span></div><div class="line">	<span class="meta">@Path</span>(<span class="string">"&#123;year&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Response <span class="title">getBooks</span><span class="params">(@PathParam(<span class="string">"year"</span>)</span> String year,</span></div><div class="line">			@<span class="title">MatrixParam</span><span class="params">(<span class="string">"author"</span>)</span> String author,</div><div class="line">			@<span class="title">MatrixParam</span><span class="params">(<span class="string">"country"</span>)</span> String country) &#123;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> Response</div><div class="line">			.status(<span class="number">200</span>)</div><div class="line">			.entity(<span class="string">"getBooks is called, year : "</span> + year</div><div class="line">				+ <span class="string">", author : "</span> + author + <span class="string">", country : "</span> + country)</div><div class="line">			.build();</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　上述的request请求URI是/books/2011;author=mkyong;country=malaysia。@MatirxParam可以提取用；分隔的一组key/value对。</p>
<h5 id="HeaderParam和CookieParam"><a href="#HeaderParam和CookieParam" class="headerlink" title="HeaderParam和CookieParam"></a>HeaderParam和CookieParam</h5><p>　　@HeaderParam和@CookieParam注解都是提取header或者cookie里某个key的value。像@HeaderParam(“Referer”)和@CookieParam(“customerId”)等，非常简单。</p>
<h5 id="获取HttpServletRequest和HttpServletResponse"><a href="#获取HttpServletRequest和HttpServletResponse" class="headerlink" title="获取HttpServletRequest和HttpServletResponse"></a>获取HttpServletRequest和HttpServletResponse</h5><p>　　JAX-RS是基于servlet实现的。其每个资源方法都可以提取相应请求的HttpServletRequest和HttpServletResponse对象。利用这两个对象，我们可以在资源方法内构造Response对象，也可以修改header和cookie。这两个对象都可以用@Context注解获取。上面的一些例子也有体现。</p>
<h5 id="payload对象"><a href="#payload对象" class="headerlink" title="payload对象"></a>payload对象</h5><p>　　http request的payload对象在网络中是以json或xml的格式传输的，只要JAX-RS里能保证其反序列化，那么在参数列表里直接用相应的POJO对象类名和实体名表示即可。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PATCH</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"&#123;id&#125;/block"</span>)</div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> MessageDTO <span class="title">block</span><span class="params">(@PathParam(<span class="string">"id"</span>)</span> Long id,@Context HttpServletRequest request,MessageDTO messageDTO) </span>&#123;</div></pre></td></tr></table></figure>
<p>　　上面的MessageDTO对象便是http request的payload对象。</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RESTful API 入门二(JAX-RS实现)]]></title>
      <url>http://wjqwsp.github.io/2016/08/22/RESTful-API-%E5%85%A5%E9%97%A8%E4%BA%8C-JAX-RS%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="为什么要用Provider"><a href="#为什么要用Provider" class="headerlink" title="为什么要用Provider"></a>为什么要用Provider</h3><p>　　provider是在程序运行时自动调用的一些类，起到配置与修改http请求与回应的作用，是JAX-RS里不可或缺的一项组件。从上一讲可以看到，Resource组件已经能够完全实现RESTful API，在JAX-RS标准里无非就是添加一些注解的事。然而，实现功能只是最基本的要求，要做出企业级的应用，必须符合一些标准和规范，才能最大程度地提高团队的开发效率，并从最佳实践的角度去吻合市场的需求。RESTful API的一些设计规范，就必须要使用到provider去做配置。</p>
<h3 id="几种provider的介绍"><a href="#几种provider的介绍" class="headerlink" title="几种provider的介绍"></a>几种provider的介绍</h3><p>　　所有类名上添加了@provider注解的类，都属于provider组件。下面将介绍一下常用的provider。<br><a id="more"></a></p>
<h5 id="ContainerRequestFilter-ContainerResponseFilter"><a href="#ContainerRequestFilter-ContainerResponseFilter" class="headerlink" title="ContainerRequestFilter,ContainerResponseFilter"></a>ContainerRequestFilter,ContainerResponseFilter</h5><p>　　过滤器，顾名思义，是对进入服务器与从服务器输出的数据进行过滤。由于RESTful API实际上是操作http协议，那么过滤器便是对http request或http response的header或body进行过滤，作出一些修改，或判断是否拒绝该http request或http response。</p>
<p>　　containerRequestFilter的核心是filter方法，接收ContainerRequestContext对象，这个对象封装了http request。一般在这个方法里对header进行操作。ContainerResponseFilter的核心也是filter方法，接收ContainerResponseContext和ContainerResponseContext对象，这个对象封装的则是http response，也主要针对其heaer操作。</p>
<p>　　下面从两个主要的设计规范点出发，看看怎么用JAX-RS的过滤器来实现。</p>
<ul>
<li>HTTP方法重载。上一讲提到，RESTful API涉及的HTTP方法有GET，POST,PUT,PATCH,DELETE这几种，而有些http proxy只能用GET和POST方法。一般的解决方法是将PUT，PATCH和DELETE请求也用POST方法发出，但在header里添加X-HTTP-Method-Override这个key，来存储真正的方法名。那么服务器端怎么利用http header，来进行方法重新匹配的呢？这就需要用到ContainerRequestFilter了。下面请看代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="meta">@PreMatching</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpMethodOverrideEnabler</span> <span class="keyword">implements</span> <span class="title">ContainerRequestFilter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(ContainerRequestContext requestContext)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        String override = requestContext.getHeaders()</div><div class="line">                .getFirst(<span class="string">"X-HTTP-Method-Override"</span>);</div><div class="line">        <span class="keyword">if</span> (override != <span class="keyword">null</span>) &#123;</div><div class="line">            requestContext.setMethod(override);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　　先来看@PreMatching注解。所有的provider都对应特定的资源类或者资源方法，当http request到达，会首先根据其URI和HTTP方法类型去匹配相应的Resource组件类的某个方法，这在上一讲已经讲过。一般情况下所有ContainerRequestFilter的执行时机是在方法匹配之后，但是我们的需求是在方法匹配之前对方法进行重载，根据X-HTTP-Method-Override里的方法名进行重匹配。这就需要用到@PreMatching注解了，它能把过滤器的执行时机提前到方法匹配之前。filter方法里代码也很简单，就是从requestContext里提取header里的X-HTTP-Method-Override字段，如果不为空则用setMethod方法进行重匹配。</p>
<ul>
<li>对访问频率进行限制。我们提供的RESTful API服务允许开发者访问，但必须设置一定的安全措施，防止被滥用，被过度调用，被恶意攻击，因此必须对资源的访问频率进行限制。在限制的同时，我们也应该提供给调用者一些信息，让他们获知每周期的调用限制数，每周期内的剩余次数，以及到下一个周期的剩余时间。这些的实现同样可以用过滤器以及header来实现。请看代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpLimitRequestFilter</span> <span class="keyword">implements</span> <span class="title">ContainerRequestFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(ContainerRequestContext requestContext)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (requestContext.getCookies().get(<span class="string">"reset"</span>) != <span class="keyword">null</span> &amp;&amp; requestContext.getCookies().get(<span class="string">"timeout"</span>) != <span class="keyword">null</span>) &#123;</div><div class="line">            String timeOut = requestContext.getCookies().get(<span class="string">"timeout"</span>).getValue();</div><div class="line">            String reset = requestContext.getCookies().get(<span class="string">"reset"</span>).getValue();</div><div class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Date timeOutDate = sdf.parse(timeOut);</div><div class="line">                <span class="keyword">if</span> (timeOutDate.after(<span class="keyword">new</span> Date()) &amp;&amp; Integer.parseInt(reset) &lt;= <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> WebApplicationException(Response.status(<span class="number">429</span>).build());</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="meta">@Tracked</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpLimitResponseFilter</span> <span class="keyword">implements</span> <span class="title">ContainerResponseFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LIMIT = <span class="number">100</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TERM = <span class="number">60</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(ContainerRequestContext requestContext, ContainerResponseContext responseContext)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (requestContext.getCookies().get(<span class="string">"reset"</span>) == <span class="keyword">null</span> || requestContext.getCookies().get(<span class="string">"timeout"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">            addOrReplaceCookies(responseContext);</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            String timeOut = requestContext.getCookies().get(<span class="string">"timeout"</span>).getValue();</div><div class="line">            String reset = requestContext.getCookies().get(<span class="string">"reset"</span>).getValue();</div><div class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Date timeOutDate = sdf.parse(timeOut);</div><div class="line">                Date now  = <span class="keyword">new</span> Date();</div><div class="line">                <span class="keyword">if</span> (timeOutDate.before(now)) &#123;</div><div class="line">                    addOrReplaceCookies(responseContext);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">long</span> interval = (timeOutDate.getTime() - now.getTime())/<span class="number">1000</span>;</div><div class="line">                    <span class="keyword">if</span>(Integer.parseInt(reset) &gt; <span class="number">0</span>)&#123;</div><div class="line">                        NewCookie cookie = <span class="keyword">new</span> NewCookie(<span class="string">"reset"</span>, String.valueOf(Integer.parseInt(reset) - <span class="number">1</span>), <span class="string">"/sampleweb"</span>, <span class="string">""</span>, <span class="string">"comment"</span>, <span class="number">100</span>, <span class="keyword">false</span>);</div><div class="line">                        responseContext.getHeaders().add(<span class="string">"Set-Cookie"</span>, cookie);</div><div class="line">                        responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Remaining"</span>, Integer.parseInt(reset) - <span class="number">1</span>);</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        NewCookie cookie = <span class="keyword">new</span> NewCookie(<span class="string">"reset"</span>, String.valueOf(<span class="number">0</span>), <span class="string">"/sampleweb"</span>, <span class="string">""</span>, <span class="string">"comment"</span>, <span class="number">100</span>, <span class="keyword">false</span>);</div><div class="line">                        responseContext.getHeaders().add(<span class="string">"Set-Cookie"</span>, cookie);</div><div class="line">                        responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Remaining"</span>, <span class="number">0</span>);</div><div class="line">                    &#125;                    </div><div class="line">                    responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Limit"</span>, LIMIT);</div><div class="line">                    responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Reset"</span>, (<span class="keyword">int</span>)interval);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOrReplaceCookies</span><span class="params">(ContainerResponseContext responseContext)</span> </span>&#123;</div><div class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">        Calendar cal = Calendar.getInstance();</div><div class="line">        cal.add(Calendar.MINUTE, <span class="number">1</span>);        </div><div class="line">        NewCookie reset = <span class="keyword">new</span> NewCookie(<span class="string">"reset"</span>, String.valueOf(LIMIT - <span class="number">1</span>), <span class="string">"/sampleweb"</span>, <span class="string">""</span>, <span class="string">"comment"</span>, <span class="number">100</span>, <span class="keyword">false</span>);</div><div class="line">        NewCookie remain = <span class="keyword">new</span> NewCookie(<span class="string">"timeout"</span>, sdf.format(cal.getTime()), <span class="string">"/sampleweb"</span>, <span class="string">""</span>, <span class="string">"comment"</span>, <span class="number">100</span>, <span class="keyword">false</span>);</div><div class="line">        responseContext.getHeaders().add(<span class="string">"Set-Cookie"</span>, remain);</div><div class="line">        responseContext.getHeaders().add(<span class="string">"Set-Cookie"</span>, reset);</div><div class="line">        responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Limit"</span>, LIMIT);</div><div class="line">        responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Remaining"</span>, LIMIT - <span class="number">1</span>);</div><div class="line">        responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Reset"</span>, TERM);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　由于http协议是无状态的，而用户的访问频率是需要保存的状态，因此需用cookie来实现。cookie主要存储两个值，一个是本周期内还可以访问的次数，一个是本周期结束的时间。利用这两个值，在ContainerRequestFilter内判断是否接受这次请求，并在ContainerResponseFilter内更新每次请求过后cookie的值。这里有一个坑需要特别注意，ContainerResponseContext用getCookies()方法获取的cookie是只读的，不能修改，如果要更新cookie必须直接在http response的header里写入Set-Cookie字段。这也是http response携带cookie的规范做法。并且，NewCookie对象在创建时候必须指定路径。因为相同路径和域名的cookie是保存在同一个文件夹里的，一般是取工程路径，以表示相同工程内使用的cookie，不然在添加cookie的时候即便key一样也会插入新数据，而不会覆盖原来的cookie，达不到更新的效果。</p>
<p>　　反馈给用户的信息是保存在response的header里的，X-Rate-Limit-Limit表示每个累计周期内的访问次数最大是多少；X-Rate-Limit-Remaining表示目前的累计周期内还剩余多少次可以用；X-Rate-Limit-Reset表示还有多少秒钟累计周期就到期了，可以开始下一个周期了。这些header信息都是RESTful API的设计规范里包含的。</p>
<p>　　如果用户访问频率超出限制，需要抛出error code为429的http response，429在http标准里是表示Too Many Requests。这也是RESTful API的规范之一。充分利用错误码来表达操作的结果，设计RESTful API的时候对每一条http response都必须返回相应的错误码，不得有误。更详细的error code规范会在后面介绍，这里先提一下。</p>
<h5 id="MessageBodyWriter和MessageBodyReader"><a href="#MessageBodyWriter和MessageBodyReader" class="headerlink" title="MessageBodyWriter和MessageBodyReader"></a>MessageBodyWriter和MessageBodyReader</h5><p>　　这两类是进行对象的序列化与反序列化的。在基本的RESTful API开发中并不常用，因为如上一讲所说，利用@XmlRootElement这个JAXB注解便可轻松解决xml与json的序列化与反序列化，只有更高层次的要求才需要自己实现这两个类。我也并没有怎么使用过，对这两个类的认识也仅停留在官方文档的介绍，日后如果有机会实践过后，有更深入的理解再行补充。</p>
<h5 id="ContextResolver"><a href="#ContextResolver" class="headerlink" title="ContextResolver"></a>ContextResolver</h5><p>　　前面说过，RESTful API规范里数据传输的格式是json，而JAX-RS序列化后的json格式往往是没有缩进和换行的，这就使得json文本不方便阅读。RESTful API规范要求json必须按照pretty print的方式输出。实现pretty print一种比较简单的方法是使用Jackson框架，利用ObjectMapper类将对象映射成相应的json文本，并且其pretty print模式。下面请看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="meta">@Produces</span>(MediaType.APPLICATION_JSON)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonContextResolver</span> <span class="keyword">implements</span> <span class="title">ContextResolver</span>&lt;<span class="title">ObjectMapper</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JacksonContextResolver</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">this</span>.objectMapper = <span class="keyword">new</span> ObjectMapper();</div><div class="line">        <span class="keyword">this</span>.objectMapper</div><div class="line">                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>)</div><div class="line">                .configure(SerializationFeature.INDENT_OUTPUT, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">getContext</span><span class="params">(Class&lt;?&gt; objectType)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> objectMapper;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　其中objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true)便是让输出使用pretty print。注意的是，使用Jackson框架必须要在Application的实现类里注册相应资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClasses() &#123;</div><div class="line">        Set&lt;Class&lt;?&gt;&gt; resources = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</div><div class="line">        addRestResourceClasses(resources); </div><div class="line">        resources.add(JacksonFeature.class);    </div><div class="line">        <span class="keyword">return</span> resources;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>　　resources.add(JacksonFeature.class)这一句是不能省的。</p>
<h5 id="WriteInterceptor-ReadInterceptor"><a href="#WriteInterceptor-ReadInterceptor" class="headerlink" title="WriteInterceptor,ReadInterceptor"></a>WriteInterceptor,ReadInterceptor</h5><p>　　拦截器，与过滤器的作用有很多相似的地方。不同之处在于，过滤器一般用来处理header，拦截器则用来处理http request与response的body里的entity的输入输出流。可以利用拦截器对输入流进行统一的解码或解压缩，或者对输出流进行统一的编码或压缩。</p>
<p>　　RESTful API规范里要求对response同一使用GZIP压缩，把pretty print处理后的json文本压缩处理，节省带宽，节约流量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPWriterInterceptor</span> <span class="keyword">implements</span> <span class="title">WriterInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundWriteTo</span><span class="params">(WriterInterceptorContext context)</span></span></div><div class="line">                    <span class="keyword">throws</span> IOException, WebApplicationException &#123;</div><div class="line"></div><div class="line">    	MultivaluedMap&lt;String,Object&gt; headers = context.getHeaders();</div><div class="line">    	headers.add(<span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</div><div class="line">        <span class="keyword">final</span> OutputStream outputStream = context.getOutputStream();</div><div class="line">        context.setOutputStream(<span class="keyword">new</span> GZIPOutputStream(outputStream));</div><div class="line">        context.proceed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　上面的代码是利用WriteInterceptor进行GZIP压缩的示例，十分简单，ReadInterceptor类似，只是换成操作输入流。只需要在输出流外再包装一层GZIPOutputStream的包装流便可。注意必须在header里添加Content-Encoding字段，这样浏览器才知道怎么解压缩。</p>
<p>　　上面最值得一提的是context.proceed()这个方法。所有拦截器必须调用这个方法，调用这个方法后会自动调用下一个拦截器，直到到达拦截器链末端的最后一个拦截器，此时该拦截器调用proceed()方法后会调用MessageBodyWriter或MessageBodyReader去进行序列化或反序列化。</p>
<p>　　拦截器以及MessageBodyWriter和MessageBodyReader都是在entity不为空的情况下才会调用的，若response不返回数据或者request的body不携带数据，则这些类都不会被使用。</p>
<h5 id="provider的调用顺序"><a href="#provider的调用顺序" class="headerlink" title="provider的调用顺序"></a>provider的调用顺序</h5><ol>
<li>pre-matching ContainerRequestFilters</li>
<li>post-matching ContainerRequestFilters</li>
<li>ReaderInterceptor</li>
<li>MessageBodyReader</li>
<li>ContainerResponseFilters</li>
<li>WriterInterceptor</li>
<li>MessageBodyWriter</li>
</ol>
<h5 id="资源绑定"><a href="#资源绑定" class="headerlink" title="资源绑定"></a>资源绑定</h5><p>　默认情况下所有的http请求的到来都会让所有provider类自动运行相应的方法，但我们可以通过资源绑定的方式，让某些provider只会被某些request触发。主要有两种方式：Name binding和Dynamic binding</p>
<ol>
<li>Name binding</li>
</ol>
<p>通过@NameBinding注解实现：</p>
<ul>
<li>定义注解，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NameBinding</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Tracked &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>为provider添加该注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="meta">@Tracked</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpLimitResponseFilter</span> <span class="keyword">implements</span> <span class="title">ContainerResponseFilter</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>为相应的资源方法或资源类添加该注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"current_user"</span>)</div><div class="line"><span class="meta">@PermitAll</span></div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Tracked</span></div><div class="line"><span class="function"><span class="keyword">public</span> JsonObject <span class="title">getCurrentUserInfo</span><span class="params">(@Context HttpServletRequest request)</span> </span>&#123;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Stateless</span></div><div class="line"><span class="meta">@RolesAllowed</span>(&#123;<span class="string">"operator"</span>&#125;)</div><div class="line"><span class="meta">@Path</span>(<span class="string">"message"</span>)</div><div class="line"><span class="meta">@Tracked</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFacadeREST</span> <span class="keyword">extends</span> <span class="title">AbstractFacade</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</div></pre></td></tr></table></figure>
<p>　　当访问带有@Tracked注解的方法或类时，带有@Tracked的provider便会在相应的资源方法调用前后自动触发。从而实现资源绑定。</p>
<ol>
<li>Dynamic binding</li>
</ol>
<p>　　动态绑定是通过DynamicFeature接口实现的，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressionDynamicBinding</span> <span class="keyword">implements</span> <span class="title">DynamicFeature</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceInfo resourceInfo, FeatureContext context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (HelloWorldResource.class.equals(resourceInfo.getResourceClass())</div><div class="line">                &amp;&amp; resourceInfo.getResourceMethod()</div><div class="line">                    .getName().contains(<span class="string">"VeryLongString"</span>)) &#123;</div><div class="line">            context.register(GZIPWriterInterceptor.class);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　configure()方法里接收两个参数，ResourceInfo对象用来对request要访问的资源进行过滤，FeatureContext对象用来对相应的provider进行动态注册。</p>
<h3 id="异常处理以及返回Response对象"><a href="#异常处理以及返回Response对象" class="headerlink" title="异常处理以及返回Response对象"></a>异常处理以及返回Response对象</h3><p>　　如果没有错误正常返回，一般直接返回结果对象或者什么也不返回即可，这时不需要额外配置response的header或status code。但是，若抛出异常或者结果不正确，则需要返回相应的status code。这时候便需要我们构造Response对象返回。</p>
<p>　　JAX-RS的异常处理建议统一使用WebApplicationException类或者使用ExceptionMapper类来实现。</p>
<h5 id="WebApplicationException"><a href="#WebApplicationException" class="headerlink" title="WebApplicationException"></a>WebApplicationException</h5><p>　　直接抛出WebApplicationException:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> WebApplicationException(Response.status(<span class="number">429</span>).build());</div></pre></td></tr></table></figure>
<p>　　接收的参数可以是用相应status code构造的Response对象，也可以直接用status code作为参数。此时JAX-RS便会构造出相应status code的http response报文。</p>
<h5 id="ExceptionMapper"><a href="#ExceptionMapper" class="headerlink" title="ExceptionMapper"></a>ExceptionMapper</h5><p>　　如果在程序运行期间抛出异常，导致不能返回正确结果，可以用ExceptionMapper的实现类来捕捉特定的异常。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessLocalExceptionMapper</span> <span class="keyword">implements</span> <span class="title">ExceptionMapper</span>&lt;<span class="title">AccessLocalException</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">toResponse</span><span class="params">(AccessLocalException exception)</span> </span>&#123;        </div><div class="line">        <span class="keyword">return</span> Response.status(Response.Status.UNAUTHORIZED).build();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　ExceptionMapper可以定义成任何异常类的处理类，在toResponse()方法里进行异常处理，并构造Response对象返回。有这么一个机制来统一进行异常处理，使得代码管理十分清晰，行文十分优雅。</p>
<h5 id="正常返回Response对象"><a href="#正常返回Response对象" class="headerlink" title="正常返回Response对象"></a>正常返回Response对象</h5><p>　　即便是在资源方法里正常返回，但如果除了传输数据外，还需要携带header,cookie等信息，则也需要构造Response对象返回，正常数据则作为Response对象里的GenericEntity对象保存。</p>
<p>　　在正常的业务逻辑里，我们读取一些数据的时候往往需要翻页信息，页数以及每页的数据项数在RESTful API规范里往往是作为http request的query params传输的，而相应的http response也通常会在header里返回上一页，下一页，第一页以及最后一页数据的URI，方便用户继续访问。下面就以这一个规范点作为需求，看看代码里怎么构造翻页信息的Response对象的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GenericEntity entity = <span class="keyword">new</span> GenericEntity&lt;List&lt;MessageDTO&gt;&gt;(messageRepo)&#123;&#125;;</div><div class="line"><span class="keyword">double</span> count = (<span class="keyword">double</span>)messageService.countDangerousMessage();</div><div class="line">response.setHeader(<span class="string">"next"</span>, <span class="string">"https://localhost:8080/sampleweb/api/message/danger-unsolved?page="</span> + (page + <span class="number">1</span>));</div><div class="line">response.setHeader(<span class="string">"prev"</span>, <span class="string">"https://localhost:8080/sampleweb/api/message/danger-unsolved?page="</span> + (page - <span class="number">1</span>));</div><div class="line">response.setHeader(<span class="string">"first"</span>, <span class="string">"https://localhost:8080/sampleweb/api/message/danger-unsolved?page=1"</span>); </div><div class="line">response.setHeader(<span class="string">"last"</span>, <span class="string">"https://localhost:8080/sampleweb/api/message/danger-unsolved?page="</span> + (<span class="keyword">int</span>)Math.ceil(count / perPage));</div><div class="line">response.setHeader(<span class="string">"X-Total-Count"</span>,String.valueOf((<span class="keyword">int</span>)count));</div><div class="line"><span class="keyword">return</span> Response.ok(entity).build();</div></pre></td></tr></table></figure>
<p>　　GenericEntity保存需要返回的body里的数据。在header里添加上相应页面资源的URI，并且让X-Total-Count返回总的数据项数。这些信息都是提供给用户的。Response的ok()方法接收entity参数，并且构造status code为200的http response返回给用户。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　这一讲主要讲的是JAX-RS的provider组件，并涉及了一些异常处理和构造Response对象的内容，其实主要就是围绕http request和http response展开的。希望读者能够体会到，RESTful API归根结底就是http报文，http报文又可以分为header和body。对header和body，RESTful API都有一定的规范对其进行限制，而实现这些规范的手段便是provider，异常处理以及Response对象。RESTful API必须对每一个接口的request和response的header和body有清楚的定义。手段方法是其次，RESTful API的思想与规范才是根本。下一讲会把一些还没涉及的设计规范讲一下，但用到的技术基本就是这一讲和上一讲Resource和Provider组件的内容了。       </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RESTful API 入门一(JAX-RS实现)]]></title>
      <url>http://wjqwsp.github.io/2016/08/21/RESTful-API-%E5%85%A5%E9%97%A8-JAX-RS%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　关于RESTful API的概念网上已经说过很多，可以用很多语言与框架实现，其规范也十分详尽。我这篇入门教程尽量用自己的理解去总结RESTful API的一些要点，并以JaveEE规范的JAX-RS框架为例，以实战的形式去讲述怎么搭建一套RESTful API，并在实践过程中体现RESTful API的设计规范。</p>
<h3 id="什么是RESTful-API"><a href="#什么是RESTful-API" class="headerlink" title="什么是RESTful API"></a>什么是RESTful API</h3><ol>
<li>服务器端提供给开发者的一套接口，开发者通过调用这些接口，访问服务器的资源。这些资源通常是数据库的表抽象出来的对象，程序员通过获取这些对象，把对这些对象的增删改查映射到数据库，从而实现自己前后端的其他业务逻辑。目前移动端很多都是使用RESTful API来访问后台，受移动端影响，浏览器端也越来越多地使用这种规范。</li>
<li>本质就是http协议。RESTful API的所有操作无非是CRUD，全部映射成http的POST,GET,PUT,PATCH,DELETE等方法，操作RESTful API实际上就是操作http报文，其只是在http协议外面再封装一层。因此操作十分简洁，直观，代码优雅。</li>
<li>用URI定位所有资源。服务器端把所有供开发者访问的资源都以特定的URI表示。URI与http方法(上述的POST，GET等)组合，便可以实现对所有资源的所有操作。以微博和评论为例，假如新浪微博开放了所有微博和评论允许开发者访问。那么所有微博的URI可能是：<a id="more"></a>
<pre><code>api/weibo</code></pre><br>　　id为30691的微博URI可能是：<br><pre><code>api/weibo/30691</code></pre><br>　　id为30691的微博所有评论的URI可能是：<br><pre><code>api/weibo/30691/comment</code></pre><br>　　id为30691的微博对应的评论id为2589的评论的URI可能是：<br><pre><code>api/weibo/30691/comment/2589</code></pre><br>　　出于面向对象的思想，一般每个资源都对应一个对象，应该用名词表示，且倾向于单数。资源之间的依赖关系可以参照上述的weibo与comment。由于评论必定对应于某一条微博，所以可以用类似weibo/30691/comment的形式表示这种依赖。</li>
</ol>
<p>　　显而易见，这种目录式的URI定位十分直观，简单。</p>
<h3 id="搭建基本JAX-RS环境"><a href="#搭建基本JAX-RS环境" class="headerlink" title="搭建基本JAX-RS环境"></a>搭建基本JAX-RS环境</h3><p>　　JAX-RS是JaveEE框架里专门用来实现RESTful API的技术。搭建十分简单，且大都用注解注入的形式实现，使代码结构十分清晰，代码量很少。除了依赖的包以及一些xml配置文件以外，代码里只需要自己继承实现javax.ws.rs.core.Application类便可以完成最基本的配置。依赖的包和xml配置可自行上网搜索，不是我这篇教程的重点，这里将主要介绍代码里如何实现RESTful API</p>
<h5 id="Application类"><a href="#Application类" class="headerlink" title="Application类"></a>Application类</h5><p>　　必须创建一个类继承Application类。JAX-RS里我们用到的组件主要有两类，分别是Resource和Provider。Resource就是上述的URI对应的可供用户访问的资源。Provider是运行时自行调用的一些类，起到配置作用，这在下一讲再详细介绍。这两类组件都必须在Application类的实现类的Set<class<?>&gt; getClasses()方法里进行注册。以下是官网文档的示例：</class<?></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClasses() &#123;</div><div class="line">        Set&lt;Class&lt;?&gt;&gt; s = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</div><div class="line">        s.add(HelloWorldResource.class);</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　HelloWorldResource就是Resource组件的其中一个类，如果RESTful API需要访问这个资源类，则需要用上述的语法实现注册，是不是很简单。</p>
<h5 id="ResourceConfig类"><a href="#ResourceConfig类" class="headerlink" title="ResourceConfig类"></a>ResourceConfig类</h5><p>　　ResourceConfig是JAX-RS里提供的一个Application的实现类，通过继承这个类并且在其派生类的构造方法里对组件进行注册，可以简化注册的过程。除了对需要使用的Resource和Provider组件进行register以外，还可以通过提供要注册组件所在的包，而自动将包内所有这两类组件注册。以下是示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyApplication</span><span class="params">()</span> </span>&#123;</div><div class="line">        packages(<span class="string">"org.foo.rest;org.bar.rest"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRESTExampleApplication</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRESTExampleApplication</span><span class="params">()</span> </span>&#123;</div><div class="line">         packages(<span class="string">"com.carano.fleet4all.restExample"</span>);</div><div class="line">         register(JacksonFeature.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ApplicationPath注解"><a href="#ApplicationPath注解" class="headerlink" title="ApplicationPath注解"></a>ApplicationPath注解</h5><p>　　可以为Application的实现类添加@javax.ws.rs.ApplicationPath注解，那么所有RESTful API的URI资源都将包含该注解提供的名字作为前缀。以下是示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@javax</span>.ws.rs.ApplicationPath(<span class="string">"api"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClasses() &#123;</div><div class="line">        Set&lt;Class&lt;?&gt;&gt; resources = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</div><div class="line">        addRestResourceClasses(resources); </div><div class="line">        resources.add(JacksonFeature.class);    </div><div class="line">        <span class="keyword">return</span> resources;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　在这里注册的所有资源，其URI定位都必然是/api/…</p>
<h3 id="Resource组件"><a href="#Resource组件" class="headerlink" title="Resource组件"></a>Resource组件</h3><p>　　搭建了基本的JAX-RS环境，便可以进行真正的业务逻辑的实现了。所谓的业务逻辑，无非对特定URI资源的增删改查操作。这些都是在Resource组件方法里通过特定的注解实现操作和资源的匹配的。所有在类名上面添加了@path注解的，都被认为是Resource组件。这些类方法上添加的@path注解，将与类的@path注解提供的名字以及ApplicationPath注解提供的名字组合在一起，作为其URI。</p>
<p>　　以下是Resource组件类示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Path</span>(<span class="string">"message"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFacadeREST</span> <span class="keyword">extends</span> <span class="title">AbstractFacade</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</div></pre></td></tr></table></figure></p>
<p>　　以下是某资源方法示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"danger-unsolved"</span>)</div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json;charset=UTF-8"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">findUnSolved</span><span class="params">(@QueryParam(<span class="string">"page"</span>)</span> <span class="keyword">int</span> page,@<span class="title">QueryParam</span><span class="params">(<span class="string">"per-page"</span>)</span> <span class="keyword">int</span> perPage,@Context HttpServletResponse response) </span>&#123;</div></pre></td></tr></table></figure></p>
<p>　　先忽略掉无关的代码，只看@GET和@Path标注。@GET很容易猜到是用http的GET方法。@Path便是该资源的URI的一部分。如果findUnSolved方法是类MessageFacadeREST里的方法，且MessageFacadeREST在ApplicationConfig类里注册，那么findUnSolved方法便可以通过/api/message/danger-unsolved这个URI访问。如果加上@GET方法，那么就是对/api/message/danger-unsolved这个资源用http的GET方法访问，实际上便是调用对应的findUnSolved方法。</p>
<h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>　　RESTful API里涉及的HTTP方法一般是GET,POST,PUT,PATCH,DELETE。这些HTTP方法都是用注解形式添加在相应的Resource组件类的方法上。</p>
<ol>
<li>GET方法：用于对资源的读取，一般返回单个对象或者对象列表。</li>
<li>POST方法：用于创建新对象，需要在客户端传送一个完整对象给服务器，然后将整个对象写入数据库。一般需返回创建好的对象。</li>
<li>PUT方法：用于创建或替换已有对象，需要在客户端传送一个完整对象给服务器，如果数据库没有对应数据，则插入新数据；如果已有旧记录，则用新对象更新。一般需返回创建或更新的对象。</li>
<li>PATCH方法：用于修改某已有对象的部分属性。如果确保对象记录已经在服务器存在，且只需要修改很少的属性，那么推荐用PATCH方法去代替PUT方法。PATCH方法不需要传送整个对象，只需要传送对象id以及需要修改的属性即可。一般需返回更新的对象。</li>
<li>DELETE方法：删除相应对象记录。无返回。</li>
</ol>
<p>　　有一些HTTP proxy只支持GET和POST方法，而不支持其他方法。这种情况在规范里一般在http header里加入X-HTTP-Method-Override的key，里面保存真正的http方法，例如”PUT”或”PATCH”，而请求一律通过POST方法发送到服务器端。具体的代码实现将会在下一讲介绍。</p>
<h3 id="数据传输及序列化与反序列化"><a href="#数据传输及序列化与反序列化" class="headerlink" title="数据传输及序列化与反序列化"></a>数据传输及序列化与反序列化</h3><p>　　在RESTful API操作的是对象，传出与接收一般是实体的POJO对象。而对象如果传出，需要先进行序列化，以xml或json的形式传送。对象如果接收，则要进行反序列化，把json或xml的数据转换成实体的POJO对象。序列化或进行反序列化的数据类型一般用@Produces和@Consumes注解来实现。下面给出一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PUT</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"&#123;id&#125;/block"</span>)</div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> MessageDTO <span class="title">block</span><span class="params">(@PathParam(<span class="string">"id"</span>)</span> Long id,@Context HttpServletRequest request,MessageDTO messageDTO) </span>&#123;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@XmlRootElement</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageDTO</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Long message1Id;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String message1Word;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> message1CommentCount;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> message1TransmissionCount;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String message1UserName;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Timestamp message1Date;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Long message1OwnerId;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> referenced;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Long message2Id;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String message2Word;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> message2CommentCount;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> message2TransmissionCount;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String message2UserName;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Timestamp message2Date;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Long message2OwnerId;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> blocked;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> deleted;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Timestamp managedDate;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String action;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String operator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Timestamp <span class="title">getManagedDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> managedDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setManagedDate</span><span class="params">(Timestamp managedDate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.managedDate = managedDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAction</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> action;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAction</span><span class="params">(String action)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.action = action;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOperator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> operator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOperator</span><span class="params">(String operator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.operator = operator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlocked</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> blocked;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlocked</span><span class="params">(<span class="keyword">boolean</span> blocked)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.blocked = blocked;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDeleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> deleted;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeleted</span><span class="params">(<span class="keyword">boolean</span> deleted)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.deleted = deleted;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageDTO</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getMessage1Id</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1Id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1Id</span><span class="params">(Long message1Id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1Id = message1Id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage1Word</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1Word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1Word</span><span class="params">(String message1Word)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1Word = message1Word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessage1CommentCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1CommentCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1CommentCount</span><span class="params">(<span class="keyword">int</span> message1CommentCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1CommentCount = message1CommentCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessage1TransmissionCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1TransmissionCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1TransmissionCount</span><span class="params">(<span class="keyword">int</span> message1TransmissionCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1TransmissionCount = message1TransmissionCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage1UserName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1UserName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1UserName</span><span class="params">(String message1UserName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1UserName = message1UserName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Timestamp <span class="title">getMessage1Date</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1Date;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1Date</span><span class="params">(Timestamp message1Date)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1Date = message1Date;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getMessage1OwnerId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1OwnerId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1OwnerId</span><span class="params">(Long message1OwnerId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1OwnerId = message1OwnerId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReferenced</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> referenced;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReferenced</span><span class="params">(<span class="keyword">boolean</span> referenced)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.referenced = referenced;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getMessage2Id</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2Id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2Id</span><span class="params">(Long message2Id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2Id = message2Id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage2Word</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2Word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2Word</span><span class="params">(String message2Word)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2Word = message2Word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessage2CommentCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2CommentCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2CommentCount</span><span class="params">(<span class="keyword">int</span> message2CommentCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2CommentCount = message2CommentCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessage2TransmissionCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2TransmissionCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2TransmissionCount</span><span class="params">(<span class="keyword">int</span> message2TransmissionCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2TransmissionCount = message2TransmissionCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage2UserName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2UserName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2UserName</span><span class="params">(String message2UserName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2UserName = message2UserName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Timestamp <span class="title">getMessage2Date</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2Date;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2Date</span><span class="params">(Timestamp message2Date)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2Date = message2Date;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getMessage2OwnerId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2OwnerId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2OwnerId</span><span class="params">(Long message2OwnerId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2OwnerId = message2OwnerId;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　方法block是通过http的PUT方法访问的，需要传入一个MessageDTO对象，并返回一个MessageDTO对象。@Produces定义了返回对象将序列化成为json格式；@Cosumes定义了接收的对象是json格式的，将对其进行反序列化。JAX-RS里本身没有实现对特定对象自动进行序列化与反序列化。一般需实现MessageBodyWriter或MessageBodyReader这两个类，在这两个类里自行进行序列化与反序列化的处理。这两个类都属于Provider，将在下一讲介绍。但实际上，如果只是简单的进行json或xml的转换是非常简单的，并不需要另外实现Provider，只有对具体的格式有要求或者需要进行更多的配置才有必要实现。一般如果进行xml转换，只需要修改@Produces和@Consumes为对应格式，并且在需要进行序列化与反序列化的POJO类上加上@XmlRootElement注解，便可实现。这种做法实际上是JAX-RS后台调用JAXB实现，@XmlRootElement是JAXB注解，而JAXB是专门用于进行xml和JAVA对象转换的技术。如果需要用json格式，同样可以通过JAXB的@XmlRootElement注解实现，只需把@Provider或@Consumes修改为application/json即可。实际上如果你是用glassfish 4以上作为application server container的，如果以json格式进行传输不需要任何其他Provider或@XmlRootElement，只需要修改@Provider或@Consumes即可。因为glassfish 4已经配置了MOXy作为Default JSON-Binding Provider。MOXy是json的一个框架，它可以在Application里自动注册，不需要显示地手动注册资源。</p>
<p>　　目前，RESTful API规范建议一律采用json作为数据传输的格式，而不要使用xml。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　这篇教程主要针对JAX-RS的Resource组件的基础知识，介绍了RESTful API的概念，以及HTTP方法，URI资源定位和数据传输格式这三个最核心的内容，并涉及了一些RESTful API的设计规范。更多的设计规范以及关于Provider的知识，将再后面一一介绍。</p>
]]></content>
    </entry>
    
  
  
</search>
