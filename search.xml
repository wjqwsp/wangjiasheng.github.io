<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[linux系统内存管理]]></title>
      <url>http://wjqwsp.github.io/2018/08/18/linux%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　主要介绍linux操作系统的虚拟内存以及动态内存分配的概念，从硬件，内核，用户程序3个层面自底而上地概述一下linux内存管理的要点。<br><a id="more"></a></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>　　我们平时看到的内存条，在插入主板后被操作系统当做物理内存使用，区别于物理内存，计算机系统抽象出了一个虚拟内存的概念。它是在硬件与操作系统的结合下工作的。实际上它是虚拟出了一段独立的内存空间，与实际的物理内存空间产生映射关系，用户程序以及操作系统程序只需要与这个虚拟的内存空间打交道，在底层硬件的帮助下会自动地将这个虚拟内存空间映射到物理内存。</p>
<p>　　它主要有以下优点：</p>
<ol>
<li>作为物理磁盘的缓存。这个概念非常重要，整个虚拟内存都是作为物理磁盘的缓存存在的，每一个内存地址都能映射到实际的磁盘存储区域。通过这个方式加速程序IO。</li>
<li>每个进程使用独立的虚拟内存，这就提供了隔离性，让进程之间的数据不会互相破坏。同时，每个进程的内存结构都是相同的，方便了内存管理以及操作系统的链接。</li>
</ol>
<h3 id="虚拟内存工作原理"><a href="#虚拟内存工作原理" class="headerlink" title="虚拟内存工作原理"></a>虚拟内存工作原理</h3><h4 id="硬件的虚拟内存管理"><a href="#硬件的虚拟内存管理" class="headerlink" title="硬件的虚拟内存管理"></a>硬件的虚拟内存管理</h4><h5 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h5><p>　　要认识虚拟内存的工作原理，首要前提是明白虚拟内存如何与物理内存映射起来的。</p>
<p>　　虚拟内存被划分成很多4KB或者4MB这种内存块，每一个内存块都与物理内存相同大小的内存块相对应。这个匹配关系linux用内存页表来存储。内存页表由许多页表条目（PTE）组成，每一个页表条目存储了一个物理内存块的第一个字节的物理地址，当然PTE里还存储了一些元信息，例如该地址的访问权限，该虚拟地址是否已经分配等等。内存映射的关键便是通过虚拟地址，先找到内存页表相应的PTE，然后取出该PTE储存的物理内存块地址，再根据虚拟内存找到该4KB或者4MB块的某个内存偏移，再读出相应的字节。</p>
<p>　　以32位地址空间，4KB内存页为例。将32位虚拟地址分成两部分，第一部分20bit组成，用来索引内存页表的PTE，因此内存页表共有1024*1024个PTE。找到PTE后，取出20bit的物理地址高位，再与虚拟地址第二部分的12bit偏移量组合起来，形成物理地址。</p>
<p>　　从上面例子可以看到，无论PTE是否分配，都需要1024*1024个PTE常驻内存，如果每个PTE是4个字节，那么就需要4MB的空间，其中很多空间是浪费的。所以实际操作系统往往采用多级页表的形式。</p>
<p>　　以二级页表为例，32bit的虚拟地址分成3部分。第一部分10bit作为一级页表的索引，找出二级页表的物理地址。然后再用第二部分10bit作为二级页表的索引，找出PTE，取出20bit的物理地址高位，再与再与虚拟地址第三部分的12bit偏移量组合起来，形成物理地址。从这个例子可以看出，常驻内存的只有一级页表，4KB的内存空间，内存消耗降低了1024倍。</p>
<p>　　页表层级越多，内存消耗越少，但是容易想到，翻译内存耗时也会增加，因为要读某个内存地址的数据，都要沿着页表层级依次读出相应内存页表的PTE。实际上CPU芯片里有一个TLB（翻译后备缓冲器）的结构，作为PTE的缓存，访问速度非常快，多级页表的性能影响基本可以忽略。</p>
<h4 id="CPU如何读取内存数据"><a href="#CPU如何读取内存数据" class="headerlink" title="CPU如何读取内存数据"></a>CPU如何读取内存数据</h4><p>　　由于内核以及应用程序都是通过虚拟内存地址来访问内存，所以，我们可以从CPU执行一条读内存的指令开始，去分析这个指令的执行过程。</p>
<ol>
<li>CPU发送虚拟地址给CPU芯片上的内存管理单元MMU。</li>
<li>MMU从CPU芯片的TLB（翻译后备缓冲器）里查找是否缓存了PTE。其中多级页表需要查找多次。缓存命中则跳到3。否则跳到5。</li>
<li>MMU得到PTE，如果该PTE页命中且权限正确，则取出高20bit物理地址，并与虚拟地址低12bit偏移量组合，得到物理地址，返回CPU。如果该PTE没有分配，或权限错误，则产生段错误，触发一个一般保护故障，跳到异常处理程序。若PTE缺页，则跳到缺页异常处理程序。由于内存是磁盘的缓存，该程序会读取磁盘的相应数据，然后在内存中找出牺牲页，如果该页数据已被修改，则写回磁盘，然后用新读取的页替换掉该牺牲页。当异常处理程序返回时，会重新执行该读内存指令，因此跳到1重新执行。再次执行就会是页命中了。</li>
<li>CPU用得到的物理地址向高速缓存/主存请求数据。</li>
<li>TLB缓存不命中，需要向高速缓存/主存请求PTE。得到后跳到3。</li>
</ol>
<h4 id="内核的虚拟内存管理"><a href="#内核的虚拟内存管理" class="headerlink" title="内核的虚拟内存管理"></a>内核的虚拟内存管理</h4><p>　　前面主要讲了硬件部分如何进行地址翻译，这一节讲一下内核是如何协助硬件管理虚拟内存的。<a href="https://wjqwsp.github.io/2018/07/07/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%8F%8A%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" title="linux可执行文件结构及链接过程分析">linux可执行文件结构及链接过程分析</a> 之前写的关于链接过程的文章中也说了，linux系统对于内存实际是分段管理的，分成数据段、代码段、共享库内存映射区域、栈、堆等等。在内核中，每一个进程都维护了自己的元数据，其中有两个字段pgd和mmap非常重要，前者是第一级页表的基址，在内存调度时会把该地址CR3基址寄存器，MMU工作时会从该地址获取内存页表。第二个字段是指向维护了所有虚拟内存区域的链表，每个区域主要有以下4个字段：</p>
<ol>
<li>vm_start，区域的起始地址。</li>
<li>vm_end，区域的结束地址。</li>
<li>vm_prot，区域的读写许可权限。</li>
<li>vm_flags，描述该区域是共享的或者是私有的。</li>
</ol>
<h5 id="细看缺页异常程序"><a href="#细看缺页异常程序" class="headerlink" title="细看缺页异常程序"></a>细看缺页异常程序</h5><p>　　在讲CPU读取内存数据时，提到了缺页异常处理程序。这里再详细补充一下该程序的功能：</p>
<ol>
<li>判断虚拟地址是否合法。即判断该地址是否在某个内存区域的vm_start和vm_end内。</li>
<li>判断内存访问是否合法。即判断是否有读写该区域的权限。这个判断不同于MMU根据PTE的某些标志位的判断，这个判断不是硬件层面的，是内核层面进行进一步的过滤。</li>
<li>进行页替换，重新执行缺页指令。</li>
</ol>
<h5 id="内存与磁盘的映射"><a href="#内存与磁盘的映射" class="headerlink" title="内存与磁盘的映射"></a>内存与磁盘的映射</h5><p>　　这个关系是内核建立并维护的。虚拟内存地址必须与某个磁盘地址对应起来。内核实际上是把某段内存区域映射到某个磁盘文件上。</p>
<p>　　可以映射成普通文件，例如在执行exec系统调用时，就会建立起内存区域与磁盘的可执行文件的代码段与数据段的映射，然后进行按需页面调度。按需页面调度，实际上就是利用上面提到的缺页异常程序按需把磁盘的数据拷贝到内存里，再刚映射时并没有任何数据传输。</p>
<p>　　也可以映射成匿名文件，这些匿名文件的创建与删除完全由内核负责，linux系统上的swap区域就是干这个事。例如进程的栈，堆等没有真实文件可以对应的，就会映射到swap区域的匿名文件，并用二进制0初始化该区域。当内存不足，必须要把某些内存页交换到磁盘时，就会产生从内存到swap区域的数据传输，在刚开始建立映射时也是没有任何数据交换的。</p>
<p>　　要特别注意的是，当进程运行过程中，修改了数据段的某些内容时，如果内存不足造成缺页，此时内核不会把内存交换回真实文件区域，而是交换到swap区域，并重新建立映射关系。</p>
<p>　　内存区域要么是共享的，要么是私有的。由于每个区域都有唯一的文件名相对应，因此内核很容易判断是否有其他进程的虚拟内存映射相同的物理内存。共享区域的管理比较简单，读写都会更改到同样的物理内存上，并且当内存区域被修改，dirty页最终会被写回真实文件上。私有区域的管理则稍微复杂一点，采用写时复制的策略，即一开始多个进程的内存页表都指向同样的物理内存，当某个进程对该区域产生修改时，则会另外分配一个副本，并调整内存映射关系。fork系统调用就是基于该写时复制策略来实现的。</p>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><h4 id="用户态的内存管理"><a href="#用户态的内存管理" class="headerlink" title="用户态的内存管理"></a>用户态的内存管理</h4><p>　　前面所讲的内存管理，按照由底层到高层的顺序，分别讲述了硬件与内核互相协调的内存管理策略。而我们在写程序时候动态分配的内存，例如c程序的malloc库函数，是一个用户态的内存管理工具，它帮助我们管理堆空间的内存。</p>
<p>　　堆在用户进程内存模型中是向上增长的，内核维护了一个brk指针来标识当前堆的最高地址，用户进程通过系统调用sbrk来增加或者缩小brk指针。c标准库中的malloc便是通过调用sbrk来管理用户进程分配的内存。</p>
<h4 id="分配器实现"><a href="#分配器实现" class="headerlink" title="分配器实现"></a>分配器实现</h4><p>　　这里介绍几种经典的分配器内存管理策略。分配器在找不到空闲内存块满足用户进程需求时，会调用sbrk系统调用向内核请求内存。但分配器不会往内核归还内存，即便调用free这类函数，也只是把内存标记为空闲，由malloc这样的分配器去管理空闲块，进行下一次分配。分配器主要工作便是维护空闲块链表满足用户进程的分配和释放需求。</p>
<h5 id="分配器的吞吐率和内存利用率"><a href="#分配器的吞吐率和内存利用率" class="headerlink" title="分配器的吞吐率和内存利用率"></a>分配器的吞吐率和内存利用率</h5><p>　　衡量分配器的两个指标，一个是吞吐率：每单位时间完成分配和释放的操作数；一个是内存利用率：实际使用内存占总分配内存的比率。</p>
<p>　　其中内存利用率又可以用两个指标来表现，内部碎片与外部碎片。内部碎片是已分配块比有效载荷大，一些内存分配的字节对齐，或者添加内存块的头部尾部进行管理等等都可能导致内部碎片。外部碎片是虽然总空闲内存满足分配要求，但找不到一个单独的连续的空闲块可以满足这次请求。</p>
<p>　　吞吐率和内存利用率是相互矛盾的。</p>
<h5 id="分配器的数据组织方式"><a href="#分配器的数据组织方式" class="headerlink" title="分配器的数据组织方式"></a>分配器的数据组织方式</h5><h6 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h6><p>　　隐式空闲链表没有单独将空闲块抽出来用独立的链表维护，而只是简单地通过每个内存块的头部和尾部的块大小、分配标志位来区分空闲块与已分配块，在分配内存时，时间复杂度与所有内存块的数量成线性关系。</p>
<p><img src="/img/black-mem.jpg" alt="隐式空闲链表"></p>
<p>　　通过内存块头部和尾部的大小，可以把前后块像链表一样连起来。并且在释放内存的时候，可以在常数时间判断前后内存块是否空闲，空闲的话合并起来，避免假碎片现象。</p>
<h6 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h6><p>　　把空闲块单独组织成一个链表，在分配内存时时间复杂度与所有空闲块的数量成线性关系。</p>
<p><img src="/img/white-mem.jpg" alt="隐式空闲链表"></p>
<p>　　通过空闲块的pred与succ指针，找到上一个与下一个空闲块的位置。当释放内存时，可以选择把空闲块放到链表的头部（后进先出LIFO），这样只需要常数时间。也可以按照地址顺序维护链表，这样释放就需要线性时间。但按地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配。显式链表的缺点是空闲块必须足够大，以容纳头部，尾部与所有指针，潜在提高了内存碎片的程度。</p>
<h6 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h6><p>　　对显式空闲链表的优化方式，是把空闲链表按大小分类，每个类维护一个单独的空闲链表，分配器维护一个空闲链表数组，那么每次分配只搜索相应大小类的空闲链表即可。只有在当前空闲链表找不到满足的空闲块时，才搜索下一个链表。</p>
<p>　　比较经典的有两种实现方式，简单分离存储与分离适配。</p>
<ol>
<li>简单分离存储。每个大小类包含大小相等的空闲块。空闲块不分割，不合并。链表为空，就向内核申请固定数量的内存页，然后分割成相等的块，连成链表；否则分配时从开头第一个取即可。已分配块的大小可以从地址推断出来，而且没有合并，所以不需要头部和脚部。分配和释放都从空闲链表起始处开始，所以只需要succ指针，最小块为1个字。分配和释放都是常数时间，但由于没有合并和分割，每个链表的块大小都一样，容易造成内部碎片与外部碎片。</li>
<li>分离适配。每个空闲链表是一个大小类，大小不相等。对空闲链表做首次适配，如果找到，就分割并把剩余部分插入适当的空闲链表；如果找不到，就搜索下一个空闲链表。如果所有空闲链表都搜索完，仍然找不到合适的块，则向内核请求堆内存。释放的时候需要合并，然后放到合适的空闲链表中。对分离空闲链表的首次适配搜索，内存利用率近似最佳适配。malloc采用了分离适配的方式。伙伴系统是分离适配的一个特例，是linux内核采用的内存管理手段。其大小类为2的幂，分配和释放都递归地2分内存块或组合相应的伙伴。给定一个内存块的地址，容易计算出其伙伴的地址，适合快速搜索与合并，便于管理。由于块大小只能是2的幂，可能会导致内部碎片。一般适合于块大小肯定是2的幂的系统。</li>
</ol>
<h5 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h5><ol>
<li>首次适配。从链表头部开始，找到第一个可以分配的内存块马上分配，这种方式倾向于把大的空闲块放到链表后面，在链表起始处留下小的空闲块“碎片”，增加了大块的搜索时间。</li>
<li>下一次适配。在上一次查询结束的地方开始搜索，比首次适配要快，但内存利用率较低。</li>
<li>最佳适配。检查每一个空闲块，选择最适合大小的空闲块。内存利用率最高，但性能最差。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis sentinel与raft协议]]></title>
      <url>http://wjqwsp.github.io/2018/08/03/redis-sentinel%E4%B8%8Eraft%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h3 id="redis的高可用性"><a href="#redis的高可用性" class="headerlink" title="redis的高可用性"></a>redis的高可用性</h3><p>　　前一篇文章提到，redis用复制来解决可靠性，一份数据做多份冗余。但是，当master节点因为某种原因下线，还必须有一种机制能让slave节点自动地转化成master节点，对外提供写服务，保证系统的高可用性。redis的sentinel就是这样的一种机制。<br><a id="more"></a></p>
<h3 id="sentinel与raft"><a href="#sentinel与raft" class="headerlink" title="sentinel与raft"></a>sentinel与raft</h3><p>　　redis的sentinel是一个独立的进程，其代码的基础仍然是redis的IO多路复用，单线程多客户端的结构，但在启动时候通过指定启动项和配置文件，将创建一个独立的进程，与普通的redis进程进行解耦。一个master节点往往需要多个sentinel进程来监控，当master节点下线时，多个sentinel需要通过一个分布式协议来进行leader选举，选出的leader将负责从该master的slave节点内选出一个，成为新的master，让其他slave对其进行复制。由于当前比较流行且可靠的raft协议正是解决分布式系统中节点下线或者脑裂等问题，redis就用raft协议来进行leader选举。这个功能只用到raft协议的一小部分。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>　　sentinel是通过配置文件启动的，在配置文件里会保存sentinel所监控的master,slave和其他sentinel等信息，每当有其他节点的状态变化时，都会修改配置文件，让这些更改落盘，这样即便sentinel下线，再重启之后也可以恢复。</p>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>　　redis的sentinel进程也是通过定时事件来处理主要的业务，包括向其他节点发送心跳，发送自身的信息以及接收其他sentinel,slave和master的心跳以及redis进程的主要信息等。在定时任务中还会发起leader选举以及进行slave向master的切换。这些任务的完成需要一个状态机，sentinel主要就是通过这个状态机来实现raft协议以及slave到master的升级。定时任务会把所有sentinel知道的master,slave,还有其他sentinel都遍历一遍，处理相关的状态变化。</p>
<p>　　sentinel的定时任务还会每次都修改一下下一次定时任务的触发时间，从而让多个sentinel的定时任务事件错开，避免在选leader时大家都差不多时间开始，导致票数被拆分。这与一般raft协议的做法有区别，raft协议是在每次发起投票时，每个节点先等一个随机的时间，但两者达到的效果都是一样的。</p>
<h3 id="titl模式"><a href="#titl模式" class="headerlink" title="titl模式"></a>titl模式</h3><p>　　sentinel是通过心跳来获取其他slave,master和sentinel的在线以及详细信息的，但是心跳除了因为网络分区，节点下线等问题丢失以外，自身机器的繁忙程度或者修改系统时间这些意外的操作也可能影响sentinel的心跳正常工作，因此redis为sentinel提供了一个特殊的模式，称为titl，这个模式下，sentinel 仍然会进行监控并收集信息，它只是不执行诸如故障转移、下线判断之类的操作而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelCheckTiltCondition</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 计算当前时间</span></div><div class="line">    <span class="keyword">mstime_t</span> now = mstime();</div><div class="line"></div><div class="line">    <span class="comment">// 计算上次运行 sentinel 和当前时间的差</span></div><div class="line">    <span class="keyword">mstime_t</span> delta = now - sentinel.previous_time;</div><div class="line"></div><div class="line">    <span class="comment">// 如果差为负数，或者大于 2 秒钟，那么进入 TILT 模式</span></div><div class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span> || delta &gt; SENTINEL_TILT_TRIGGER) &#123;</div><div class="line">        <span class="comment">// 打开标记</span></div><div class="line">        sentinel.tilt = <span class="number">1</span>;</div><div class="line">        <span class="comment">// 记录进入 TILT 模式的开始时间</span></div><div class="line">        sentinel.tilt_start_time = mstime();</div><div class="line">        <span class="comment">// 打印事件</span></div><div class="line">        sentinelEvent(REDIS_WARNING,<span class="string">"+tilt"</span>,<span class="literal">NULL</span>,<span class="string">"#tilt mode entered"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新最后一次 sentinel 运行时间</span></div><div class="line">    sentinel.previous_time = mstime();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　每次定时任务redis都会执行上面这个函数，每次执行这个函数时都会产生一个sentinel.previous_time，表示这次执行sentinel逻辑的时间。如果上次执行sentinel的时间早于当前时间（说明系统时间发生改变）或者两次执行sentinel的时间相隔过长（代表当前系统繁忙，进程不能正常工作），sentinel就会进入titl模式。</p>
<h3 id="发送心跳"><a href="#发送心跳" class="headerlink" title="发送心跳"></a>发送心跳</h3><p>　　sentinel会在配置文件里指定监控哪些master，但这些master可能会有其他sentinel同时在监控，这些master每一个都会跟着一个或多个slave，sentinel对这些slave和sentinel都是通过心跳来动态发现的，而不是在初始的配置文件里指定。当然，在发现以后，这些状态会保存在配置文件中，在下次启动时就会加载。</p>
<p>　　sentinel的心跳分为3种，一种是ping命令，用来检测进程是否在线；一种是info命令，用来获取进程的详细信息，master的slave就是通过这个命令的返回来动态发现的；一种是频道信息，用来获取其他sentinel的信息，master的sentinel就是通过这个频道信息来动态发现的。</p>
<p>　　sentinel中通过哈希表保存所有的master，每一个master都是sentinelRedisInstance结构体。对于每一个master，都会有一个slave表，一个sentinel表，都是哈希表，保存了sentinelRedisInstance结构体，用来保存这个master的所有slave和sentinel。</p>
<p>　　在info命令的返回中，如果发现了新的slave，则会创建新的sentinelRedisInstance；在频道信息返回中，如果发现了新的sentinel，则也会创建新的sentinelRedisInstance。这时候仅仅初始化一些状态信息，并不会真正创建网络连接。</p>
<h3 id="创建网络连接及重连"><a href="#创建网络连接及重连" class="headerlink" title="创建网络连接及重连"></a>创建网络连接及重连</h3><p>　　sentinel在定时任务中创建对所有master,sentinel,slave的网路连接，以及对一些长期没有响应的连接进行重连。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelReconnectInstance</span><span class="params">(sentinelRedisInstance *ri)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 示例未断线（已连接），返回</span></div><div class="line">    <span class="keyword">if</span> (!(ri-&gt;flags &amp; SRI_DISCONNECTED)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Commands connection. */</span></div><div class="line">    <span class="comment">// 对所有实例创建一个用于发送 Redis 命令的连接</span></div><div class="line">    <span class="keyword">if</span> (ri-&gt;cc == <span class="literal">NULL</span>) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 连接实例</span></div><div class="line">        ri-&gt;cc = redisAsyncConnect(ri-&gt;addr-&gt;ip,ri-&gt;addr-&gt;port);</div><div class="line"></div><div class="line">        <span class="comment">// 连接出错</span></div><div class="line">        <span class="keyword">if</span> (ri-&gt;cc-&gt;err) &#123;</div><div class="line">            sentinelEvent(REDIS_DEBUG,<span class="string">"-cmd-link-reconnection"</span>,ri,<span class="string">"%@ #%s"</span>,</div><div class="line">                ri-&gt;cc-&gt;errstr);</div><div class="line">            sentinelKillLink(ri,ri-&gt;cc);</div><div class="line"></div><div class="line">        <span class="comment">// 连接成功</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 设置连接属性</span></div><div class="line">            ri-&gt;cc_conn_time = mstime();</div><div class="line">            ri-&gt;cc-&gt;data = ri;</div><div class="line">            redisAeAttach(server.el,ri-&gt;cc);</div><div class="line">            <span class="comment">// 设置连线 callback</span></div><div class="line">            redisAsyncSetConnectCallback(ri-&gt;cc,</div><div class="line">                                            sentinelLinkEstablishedCallback);</div><div class="line">            <span class="comment">// 设置断线 callback</span></div><div class="line">            redisAsyncSetDisconnectCallback(ri-&gt;cc,</div><div class="line">                                            sentinelDisconnectCallback);</div><div class="line">            <span class="comment">// 发送 AUTH 命令，验证身份</span></div><div class="line">            sentinelSendAuthIfNeeded(ri,ri-&gt;cc);</div><div class="line">            sentinelSetClientName(ri,ri-&gt;cc,<span class="string">"cmd"</span>);</div><div class="line"></div><div class="line">            <span class="comment">/* Send a PING ASAP when reconnecting. */</span></div><div class="line">            sentinelSendPing(ri);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Pub / Sub */</span></div><div class="line">    <span class="comment">// 对主服务器和从服务器，创建一个用于订阅频道的连接</span></div><div class="line">    <span class="keyword">if</span> ((ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) &amp;&amp; ri-&gt;pc == <span class="literal">NULL</span>) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 连接实例</span></div><div class="line">        ri-&gt;pc = redisAsyncConnect(ri-&gt;addr-&gt;ip,ri-&gt;addr-&gt;port);</div><div class="line"></div><div class="line">        <span class="comment">// 连接出错</span></div><div class="line">        <span class="keyword">if</span> (ri-&gt;pc-&gt;err) &#123;</div><div class="line">            sentinelEvent(REDIS_DEBUG,<span class="string">"-pubsub-link-reconnection"</span>,ri,<span class="string">"%@ #%s"</span>,</div><div class="line">                ri-&gt;pc-&gt;errstr);</div><div class="line">            sentinelKillLink(ri,ri-&gt;pc);</div><div class="line"></div><div class="line">        <span class="comment">// 连接成功</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">            <span class="comment">// 设置连接属性</span></div><div class="line">            ri-&gt;pc_conn_time = mstime();</div><div class="line">            ri-&gt;pc-&gt;data = ri;</div><div class="line">            redisAeAttach(server.el,ri-&gt;pc);</div><div class="line">            <span class="comment">// 设置连接 callback</span></div><div class="line">            redisAsyncSetConnectCallback(ri-&gt;pc,</div><div class="line">                                            sentinelLinkEstablishedCallback);</div><div class="line">            <span class="comment">// 设置断线 callback</span></div><div class="line">            redisAsyncSetDisconnectCallback(ri-&gt;pc,</div><div class="line">                                            sentinelDisconnectCallback);</div><div class="line">            <span class="comment">// 发送 AUTH 命令，验证身份</span></div><div class="line">            sentinelSendAuthIfNeeded(ri,ri-&gt;pc);</div><div class="line"></div><div class="line">            <span class="comment">// 为客户但设置名字 "pubsub"</span></div><div class="line">            sentinelSetClientName(ri,ri-&gt;pc,<span class="string">"pubsub"</span>);</div><div class="line"></div><div class="line">            <span class="comment">/* Now we subscribe to the Sentinels "Hello" channel. */</span></div><div class="line">            <span class="comment">// 发送 SUBSCRIBE __sentinel__:hello 命令，订阅频道</span></div><div class="line">            retval = redisAsyncCommand(ri-&gt;pc,</div><div class="line">                sentinelReceiveHelloMessages, <span class="literal">NULL</span>, <span class="string">"SUBSCRIBE %s"</span>,</div><div class="line">                    SENTINEL_HELLO_CHANNEL);</div><div class="line">            </div><div class="line">            <span class="comment">// 订阅出错，断开连接</span></div><div class="line">            <span class="keyword">if</span> (retval != REDIS_OK) &#123;</div><div class="line">                <span class="comment">/* If we can't subscribe, the Pub/Sub connection is useless</span></div><div class="line">                 * and we can simply disconnect it and try again. */</div><div class="line">                sentinelKillLink(ri,ri-&gt;pc);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Clear the DISCONNECTED flags only if we have both the connections</span></div><div class="line">     * (or just the commands connection if this is a sentinel instance). */</div><div class="line">    <span class="comment">// 如果实例是主服务器或者从服务器，那么当 cc 和 pc 两个连接都创建成功时，关闭 DISCONNECTED 标识</span></div><div class="line">    <span class="comment">// 如果实例是 Sentinel ，那么当 cc 连接创建成功时，关闭 DISCONNECTED 标识</span></div><div class="line">    <span class="keyword">if</span> (ri-&gt;cc &amp;&amp; (ri-&gt;flags &amp; SRI_SENTINEL || ri-&gt;pc))</div><div class="line">        ri-&gt;flags &amp;= ~SRI_DISCONNECTED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　对所有实例创建一个命令连接，对所有非sentinel实例创建频道连接。如果连接创建成功，把sentinelRedisInstance状态的SRI_DISCONNECTED标志位去掉。</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p>　　当前sentinel认为某个实例下线，称为主观下线。redis只需要判断上次发送ping的时间与当前的时间是否超过一定的值，如果超过的时间过长，说明当前sentinel与该实例的通信有问题，因为sentinel只有当上次ping返回之后，才会发送下一个ping命令。这时候，sentinel会把该实例的状态设为主观下线SRI_S_DOWN，并按需要可能会断开当前的连接，在下一次定时任务的时候尝试重连。</p>
<h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>　　只有在判断某个实例客观下线（即大部分的节点都认为该实例下线），sentinel才会进行slave到master的升级的故障恢复操作。在隔一定时间，sentinel都会向sentinel针对某个master实例发送<code>SENTINEL is-master-down-by-addr</code>命令，收集其他sentinel对于该master是否在线的意见，当大部分的sentinel都认为该master不在线时，触发一次故障转移。</p>
<h4 id="SENTINEL-FAILOVER-STATE-WAIT-START"><a href="#SENTINEL-FAILOVER-STATE-WAIT-START" class="headerlink" title="SENTINEL_FAILOVER_STATE_WAIT_START"></a>SENTINEL_FAILOVER_STATE_WAIT_START</h4><p>　　当大部分的sentinel判断某master客观下线，那么该master进入SENTINEL_FAILOVER_STATE_WAIT_START状态，处于该状态时sentinel会发起一次leader选举，并进入一个新的纪元，这个纪元的概念与raft协议的term是一致的。</p>
<p>　　leader选举的过程跟raft协议比较相似，且简单很多，因为不涉及log的一致性判断，不需要让选出来的leader比较log的term和index，基本是采取先到先得的原则，sentinel收到其他sentinel的投票请求，会采纳第一个sentinel的票，而返回给其他sentinel自己之前采纳过的sentinel。由于每个sentinel只投一个sentinel，且只有获得大部分的sentinel的票时才当选，因此必然能够保证有且仅有一个leader被选上。且之前提到过，每个sentinel的定时任务的执行频率都是随机化的，基本不会产生票数被拆分的问题。</p>
<p>　　所有的sentinel都可以发起leader选举，但只有一个sentinel来执行这个故障转移，当已经发起了一次选leader，但发现自己没选上，则会等一段时间（故障转移超时时间）后解除这一状态，重新判断客观下线，然后触发故障转移；但一般情况下，如果别的sentinel先发起选举，当前sentinel收到投票请求时，会更新一个叫做failover_start_time的变量，那么即便在判断客观下线后，也要判断当前时间是否与failover_start_time相隔2*故障转移超时时间，从而避免多个sentinel同时发起故障转移。raft协议里本身是没有这一逻辑的，那是因为当某个节点当选了master，会发心跳给slave，slave收到心跳就表明集群里已经存在leader，就不会再发起leader选举。而redis里没有这一leader到follower的心跳通信，所以需要用这个faileover_start_time来过滤一下。</p>
<h4 id="SENTINEL-FAILOVER-STATE-SELECT-SLAVE"><a href="#SENTINEL-FAILOVER-STATE-SELECT-SLAVE" class="headerlink" title="SENTINEL_FAILOVER_STATE_SELECT_SLAVE"></a>SENTINEL_FAILOVER_STATE_SELECT_SLAVE</h4><p>　　如果当前sentinel成为leader,则进入SENTINEL_FAILOVER_STATE_SELECT_SLAVE状态，进行故障转移。这一步是在该master的所有slave中选出一个作为新的master。</p>
<p>　　当选的几个条件：</p>
<ol>
<li>没有下线</li>
<li>没有长时间没有收到该slave的info信息</li>
<li>没有与master长时间断开。</li>
</ol>
<p>　　这几个条件限定了slave的数据比较新，且与sentinel的通信可靠。</p>
<p>　　然后，对候选的slave进行排序：</p>
<ol>
<li>比较优先级，较小的优先级优先。</li>
<li>复制偏移量较大者优先</li>
<li>运行id较小者优先</li>
</ol>
<h4 id="SENTINEL-FAILOVER-STATE-SEND-SLAVEOF-NOONE"><a href="#SENTINEL-FAILOVER-STATE-SEND-SLAVEOF-NOONE" class="headerlink" title="SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE"></a>SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE</h4><p>　　选出了slave，就进入SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE状态，给该slave发送<code>slaveof no one</code>命令。</p>
<h4 id="SENTINEL-FAILOVER-STATE-WAIT-PROMOTION"><a href="#SENTINEL-FAILOVER-STATE-WAIT-PROMOTION" class="headerlink" title="SENTINEL_FAILOVER_STATE_WAIT_PROMOTION"></a>SENTINEL_FAILOVER_STATE_WAIT_PROMOTION</h4><p>　　在info命令的返回里判断该slave的角色是否变成master，是则进入下一个状态，否则超时等到下一次定时任务重新触发故障转移。</p>
<h4 id="SENTINEL-FAILOVER-STATE-RECONF-SLAVES"><a href="#SENTINEL-FAILOVER-STATE-RECONF-SLAVES" class="headerlink" title="SENTINEL_FAILOVER_STATE_RECONF_SLAVES"></a>SENTINEL_FAILOVER_STATE_RECONF_SLAVES</h4><p>　　当选中的slave角色已变成master，就要向原master的其他slave发送slaveof命令，让它们复制新的master，这时候它们的状态均加上SRI_RECONF_SENT标志位，代表复制请求已发出。保证一定数量的slave并发发起向新master的同步，同样在info命令的返回里判断这些slave是否同步完毕。info命令里如果发现slave复制的master的ip地址和端口号与新master一致，那么slave进入SRI_RECONF_INPROG状态；当发现slave的<code>slave_master_link_status == SENTINEL_MASTER_LINK_STATUS_UP</code>成立，那么说明slave已经完成对master的同步，此时slave进入SRI_RECONF_DONE状态。当所有slave都进入SRI_RECONF_DONE状态，则故障转移基本结束，sentinel进入SENTINEL_FAILOVER_STATE_UPDATE_CONFIG状态。</p>
<h4 id="SENTINEL-FAILOVER-STATE-UPDATE-CONFIG"><a href="#SENTINEL-FAILOVER-STATE-UPDATE-CONFIG" class="headerlink" title="SENTINEL_FAILOVER_STATE_UPDATE_CONFIG"></a>SENTINEL_FAILOVER_STATE_UPDATE_CONFIG</h4><p>　　该状态主要是修改配置文件，让sentinel的master,slave和sentinel都在故障转移后进行相应更新，例如把原master的ip,port等修改成新master等等，把状态都初始化，并重置所有网络连接。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis复制过程浅析]]></title>
      <url>http://wjqwsp.github.io/2018/07/23/redis%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>　　在分布式系统遇到网络分区故障时，往往需要依赖分区容错性来对外提供可用性和一致性服务，这就要求同一份数据在分布式环境中存在数据冗余，并在某部分数据损坏或不可访问后，仍然能够不影响用户的使用。复制便是提供这种分区容错性的常用手段，它要求同一份数据在多台机器各保存一份完整的版本。之前几篇文章介绍了redis单机版本的一些工作原理，本文便开始扩展到分布式环境，简单分析一下redis的多机版本是如何实现复制这一功能的。整个复制过程可分为master和slave两个部分介绍。<br><a id="more"></a></p>
<h3 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h3><p>　　每一个redis进程都有两种身份，一种是master，另一种是slave。master负责接收数据写入，同时有一个或多个slave作为数据备份，一般的业务场景是一个master维护多个slave，slave同时也可以是其他slave的master。master和slave之间是客户端-服务器的形式通信，与单机版本服务器处理客户端的模型一样，也是IO多路复用，读写绑定不同的事件处理器。其中master是slave的客户端，把其他客户端的命令原封不动转发给slave。slave也是master的客户端，定期向master汇报当前的复制偏移量。</p>
<p>　　由于复制过程是slave发起的，便先从slave这一端介绍。无论master还是slave，在处理复制这一过程里实际上便是实现了一套通信协议，这个协议涉及master和slave在多个状态之间转换，因此master和slave都相当于状态机。我们只要关注这几个状态的转移，便可以理清整个复制过程。</p>
<h4 id="REDIS-REPL-NONE"><a href="#REDIS-REPL-NONE" class="headerlink" title="REDIS_REPL_NONE"></a>REDIS_REPL_NONE</h4><p>　　第一个状态是REDIS_REPL_NONE，代表不进行复制，该进程是单机进程。</p>
<h4 id="REDIS-REPL-CONNECT"><a href="#REDIS-REPL-CONNECT" class="headerlink" title="REDIS_REPL_CONNECT"></a>REDIS_REPL_CONNECT</h4><p>　　第二个状态是REDIS_REPL_CONNECT,这个状态的含义是尝试连接master。REDIS_REPL_NONE与REDIS_REPL_CONNECT之间转移是通过命令slaveof实现的。<code>slaveof no one</code>取消复制，从REDIS_REPL_CONNECT转移到REDIS_REPL_NONE；<code>slaveof ip port</code>开始复制，设置master服务器的ip和port，同时完成从REDIS_REPL_NONE到REDIS_REPL_CONNECT的状态转移。</p>
<h4 id="REDIS-REPL-CONNECTING"><a href="#REDIS-REPL-CONNECTING" class="headerlink" title="REDIS_REPL_CONNECTING"></a>REDIS_REPL_CONNECTING</h4><p>　　第三个状态是REDIS_REPL_CONNECTING，代表正在连接。redis的定时函数serverCron里，每秒钟会调用一次replicationCron函数，这个函数会检查当进程状态是REDIS_REPL_CONNECTING时，尝试建立与master的socket连接。前面说过，复制过程的master和slave也是沿用了redis单机版的客户端-服务器通信模型，并且在slaveof命令时已然获取了master的ip和port，那么就可以建立socket连接了。由于redis采用单线程Io多路复用模型，注重高性能，不能容忍任何形式的长时间阻塞，因此尝试建立socket的过程也是无阻塞的，如果失败立即返回。socket建立成功后，则正式进入REDIS_REPL_CONNECTING状态，并且给socket绑定读写事件处理器syncWithMaster，这个事件处理器会完成开启数据同步的任务。</p>
<h4 id="REDIS-REPL-RECEIVE-PONG"><a href="#REDIS-REPL-RECEIVE-PONG" class="headerlink" title="REDIS_REPL_RECEIVE_PONG"></a>REDIS_REPL_RECEIVE_PONG</h4><p>　　第四个状态是REDIS_REPL_RECEIVE_PONG，代表等待PONG到达。由于之后的数据传输非常耗时，同时需要占用大量带宽，这个状态主要是测试master和slave之间的网络是否健康，能否承担起之后的数据传输重任。redis的IO多路复用模型检查master的socket是否可写，可写则调用syncWithMaster函数，当检测到当前状态是REDIS_REPL_CONNECTING时，会往master发送PING，等待PONG到达，此时状态转换为REDIS_REPL_RECEIVE_PONG，并解除写事件处理器的绑定，以防再次因为可写而反复调用syncWithMaster。如果超过一定时间，redis进程状态仍为REDIS_REPL_CONNECTING或REDIS_REPL_RECEIVE_PONG，那么说明网络条件不好，状态退回到REDIS_REPL_CONNECT，关闭socket连接，解除事件处理器绑定，等到在定时函数中再次尝试连接master。</p>
<h4 id="REDIS-REPL-TRANSFER"><a href="#REDIS-REPL-TRANSFER" class="headerlink" title="REDIS_REPL_TRANSFER"></a>REDIS_REPL_TRANSFER</h4><p>　　第五个状态是REDIS_REPL_TRANSFER，代表开始接受master的数据传输。在规定时间内收到PONG，那么首先会开启部分重同步或者完整重同步。这里先介绍一下部分重同步和完整重同步，以及涉及到的几个技术点。</p>
<h5 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h5><p>　　对于不是第一次进行复制的redis进程，可能之前已经有master的大部分数据了，只是由于网络故障等原因断开了连接，此时不需要把master的全部数据都传输一遍，只需要传输缺少的部分就可以。redis进程的主要业务就是执行命令，因此维护了一个叫复制缓冲区的东西，每当有命令到达，就把该命令语句追加到复制缓冲区中，同时维护一个只增的复制偏移量，一直往上加命令语句的字节数。复制缓冲区在内部是用在内存的环形列表实现的，其大小一般设为2<em>平均每秒产生的写命令长度总和</em>断线到重连接的平均时间。这个区域越大，则重连接时传输的数据越少，同步越快，同时消耗的内存也会增加。</p>
<h5 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h5><p>　　如果slave的复制偏移量已经不在复制缓冲区的范围内，就需要进行完整重同步了。完整重同步会传输一个RDB文件到slave上，然后由slave加载。之所以选择RDB文件，是因为它是二进制文件，体积小，便于传输，同时包含了完整的数据。</p>
<p>　　slave在REDIS_REPL_RECEIVE_PONG状态下在规定时间内收到PONG，会解除读事件处理器的绑定，因为暂时不再需要了，同时向master发送PSYNC命令<code>PSYNC master_id offset</code>。由于之前可能有master连接过，所以这里可以带上master对应的redis进程的id， offset代表当前slave的复制偏移量。master会判断id是否是自身的id，并且offset是否在复制缓冲区内，如果是则进行部分重同步，向slave发送”+CONTINUE”回复；如果有一个条件不满足，则向slave发送”+FULLRESYNC”回复，进行完整重同步。如果是第一次进行复制，那么slave向master发送<code>PSYNC ？ -1</code>，在master返回”+FULLRESYNC”后进行完整重同步。这个过程redis涉及到对socket的读和写，在一般情况下，读写绑定了不同的事件处理器，是异步进行的，但在这里是同步地发出psync命令，然后同步地收取回复。具体的实现就是立即等待单个socket的数据，并设置超时时间。</p>
<p>　　如果是完整重同步的情况，收到psync回复后，绑定新的读事件处理器readSyncBulkPayload，这个函数会读取master传来的RDB文件，然后写入到一个临时文件中，状态转换为REDIS_REPL_TRANSFER。如果是部分重同步，就比较简单了，状态直接转换为REDIS_REPL_CONNECTED，绑定读写事件处理器readQueryFromClient和sendReplyToClient。这两个事件处理器就和普通的客户端-服务器形式没有任何区别了，仅仅是用来处理各种redis命令。</p>
<h4 id="REDIS-REPL-CONNECTED"><a href="#REDIS-REPL-CONNECTED" class="headerlink" title="REDIS_REPL_CONNECTED"></a>REDIS_REPL_CONNECTED</h4><p>　　第六个状态是REDIS_REPL_CONNECTED，代表已连接。这个状态可以在完整重同步完成后由REDIS_REPL_TRANSFER转换得到。当处在REDIS_REPL_TRANSFER状态时，首先会等待master完成写RDB文件，在写完后，会先往slave发送RDB文件的大小，然后开始发送RDB文件。每次读事件发生，slave会以4k为单位读取数据，剩余的数据留到下次再读，避免阻塞其他客户端。同时每写一定的数据到磁盘，都会手动sync一次，避免一次写磁盘用满IO，导致响应缓慢。当判断已读数据达到RDB文件的大小时，解除读事件处理器，清空原来数据库，然后加载RDB文件。这个过程会一直阻塞，直到数据加载成功。然后状态转换为REDIS_REPL_CONNECTED。</p>
<p>　　在每次读事件发生时，会更新slave与master的交互时间，如果长时间没有数据到达，那么会在replicationCron函数里停掉这个传输过程，并把状态回退到REDIS_REPL_CONNECT。由于master写RDB文件可能耗时较长，因此master会在replicationCron里发送\0给这个状态的slave，slave收到以后仅仅更新交互时间。同时由于slave在清空数据库或者载入RDB文件时，可能会耗时较久，为了避免master认为slave断开，slave也会定时发送\0到master。</p>
<p>　　master会在replicationCron里向所有online的slave发送ping命令，以让slave更新与服务器的交互时间。当处在REDIS_REPL_CONNECTED状态的slave超过一定时间没有收到master的命令，那么便认为连接中断了，会关闭socket，状态回退到REDIS_REPL_CONNECT。</p>
<h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><p>　　master这端维护多个slave，每个slave对应的client也是一个状态机，其状态与slave的状态也是有一定的对应关系的。</p>
<h4 id="REDIS-REPL-NONE-1"><a href="#REDIS-REPL-NONE-1" class="headerlink" title="REDIS_REPL_NONE"></a>REDIS_REPL_NONE</h4><p>　　这个状态与slave的REDIS_REPL_NONE是完全对应的，代表该客户端不是slave。</p>
<h4 id="REDIS-REPL-ONLINE"><a href="#REDIS-REPL-ONLINE" class="headerlink" title="REDIS_REPL_ONLINE"></a>REDIS_REPL_ONLINE</h4><p>　　这个状态代表slave就绪，与master的复制关系已经建立。master开始复制的生命周期，是从slave发送psync指令开始的，如果可以进行部分重同步，那么直接跳到这个状态，并且把复制缓冲区中slave缺失的部分发给它。</p>
<h4 id="REDIS-REPL-WAIT-BGSAVE-START"><a href="#REDIS-REPL-WAIT-BGSAVE-START" class="headerlink" title="REDIS_REPL_WAIT_BGSAVE_START"></a>REDIS_REPL_WAIT_BGSAVE_START</h4><p>　　如果在开启完整重同步后，发现之前已经有后台的写rdb进程在工作，并且这个进程不是为其他slave的复制准备的，那么进入REDIS_REPL_WAIT_BGSAVE_START状态，等待下一次写RDB文件开启。redis会在rdb进程结束的回调函数里把所有处于该状态的slave的状态转换为REDIS_REPL_WAIT_BGSAVE_END。该状态对应slave的REDIS_REPL_TRANSFER状态。</p>
<h4 id="REDIS-REPL-WAIT-BGSAVE-END"><a href="#REDIS-REPL-WAIT-BGSAVE-END" class="headerlink" title="REDIS_REPL_WAIT_BGSAVE_END"></a>REDIS_REPL_WAIT_BGSAVE_END</h4><p>　　如果在开启完整重同步后，之前并没有rdb进程在工作，那么开始新的写rdb进程，进入REDIS_REPL_WAIT_BGSAVE_END状态，等待rdb进程结束。或者rdb进程为其他slave的复制作准备，那么复制其他slave的输出缓冲区，以共用之后的rdb数据。该状态也对应slave的REDIS_REPL_TRANSFER状态。</p>
<h4 id="REDIS-REPL-SEND-BULK"><a href="#REDIS-REPL-SEND-BULK" class="headerlink" title="REDIS_REPL_SEND_BULK"></a>REDIS_REPL_SEND_BULK</h4><p>　　当RDB文件写入完毕，会调用回调函数，该函数会遍历所有slave，把状态为REDIS_REPL_WAIT_BGSAVE_END<br>的slave转换为REDIS_REPL_SEND_BULK，然后重新绑定新的写事件处理器sendBulkToSlave，打开RDB文件，准备传输。该状态同样对应slave的REDIS_REPL_TRANSFER状态。</p>
<p>　　IO多路复用模型每次发现slave可写，就调用sendBulkToSlave函数，读取一定的RDB数据，然后写到网络上。每次不能写太多数据，避免阻塞其他客户端。当RDB文件传送完毕后，状态转移到REDIS_REPL_ONLINE。</p>
<h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>　　当复制建立完成，数据完成同步后，之后master的每次写操作都会在slave端回放一遍。redis为了高性能，复制是异步完成的，命令返回的时候slave不一定能把命令执行完。但slave会在replicationCron函数里向master发送命令<code>REPLCONF ACK offset</code>，汇报自己的复制偏移量。master收到以后更新client的复制偏移量，以及交互时间。当超过一定数量的slave的交互时间相隔过长，就会禁止写入新数据。</p>
<h3 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h3><p>　　redis的复制默认是异步的，如果需要同步复制，那么可以用WAIT命令来实现。每当有命令执行时，redis都会记录当前的复制偏移量到客户端状态里。当调用WAIT命令时，用户指定至少多少个replication成功以及超时时间。redis会把客户端加到等待slave响应的队列里，并把客户端状态设置为REDIS_BLOCKED_WAIT。处于该状态的客户端无法处理socket的输入数据，后续命令会在输入缓冲区堆积，直到WAIT之前的命令复制完成或者超时。</p>
<p>　　在每次进入IO多路复用的等待事件前，会调用beforeSleep函数，该函数会给所有slave发送<code>REPLCONF GETACK</code>命令，收到该命令的slave会马上发送自己的复制偏移量给master。beforeSleep函数还会检查等待slave响应队列里是否有客户端的有足够多的slave的复制偏移量不少于要求的值，足够的话就解除block，把客户端状态设为REDIS_UNBLOCKED，并让这些客户端开始处理输入缓冲区的命令。</p>
<p>　　在serverCron里还会对所有block的客户端进行检查，如果达到超时时间，就解除这些客户端的block，并通知这些客户端超时。</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux可执行文件结构及链接过程分析]]></title>
      <url>http://wjqwsp.github.io/2018/07/07/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%8F%8A%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　简单总结一下linux可执行文件的结构，以及有关链接的几个比较重要的概念，如符号表，重定位，静态链接，动态链接等。本文例子及部分描述摘自《深入理解计算机系统》及MIT教学操作系统xv6（Unix第6版用ANSI C重写）的源码。<br><a id="more"></a></p>
<h3 id="elf格式"><a href="#elf格式" class="headerlink" title="elf格式"></a>elf格式</h3><p>　　gcc是linux环境里的c语言编译器，它编译得到的可执行文件都是elf文件格式，这些文件包括我们平常使用的cat,ls,mkdir,touch等等命令，还包括我们每天都在使用的shell程序。</p>
<h3 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h3><p>　　在linux系统编译简单的c程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Og -o prog main.c sum.c</div></pre></td></tr></table></figure>
<p>　　该命令执行后，会编译main.c和sum.c两个源文件，生成名为prog的可执行文件。这个过程可分为4个步骤：</p>
<ol>
<li>预处理阶段，把#include语句以及一些宏插入程序文本中，得到main.i和sum.i文件。</li>
<li>编译阶段，将文本文件main.i和sum.i编译成文本文件main.s和sum.c的汇编语言程序。</li>
<li>汇编阶段，将main.s和sum.s翻译成机器语言的二进制指令，并打包成一种叫做可重定位目标程序的格式，并将结果保存在main.o和sum.o两个文件中。这种文件格式就比较接近elf格式了。</li>
<li>链接阶段，合并main.o和sum.o，得到可执行目标文件，就是elf格式文件。</li>
</ol>
<h3 id="链接到底做了什么"><a href="#链接到底做了什么" class="headerlink" title="链接到底做了什么"></a>链接到底做了什么</h3><p>　　先看一个简单的例子。</p>
<p>　　main.c的源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　sum.c的源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, s = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</div><div class="line">        s += a[i]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在汇编阶段后，可重定位目标程序main.o和sum.o得到的全是汇编的二进制指令，这些指令有很重要的一部分都涉及对内存的引用，这些内存引用就是我们在程序中定义的全局变量和函数，例如sum, array。汇编阶段会给这些全局变量和函数分配一个假的内存地址。</p>
<p>　　由于main.c和sum.c的源代码是单独编译的，main函数知道array这个符号是真实存在的，因为它的引用和定义都在一个文件内，但它不知道sum函数的定义，它就无法给它指定地址。所以真正内存地址的指定是在链接阶段后完成的。链接完成后，所有全局变量和函数的内存地址都确定，那么在运行可执行文件的时候，操作系统就知道把这些数据和代码加载到内存的哪个位置，每一个CPU指令就知道应该把数据从哪个内存地址转移到哪个另外的内存地址，或者从哪个内存位置把数据加载到寄存器中。链接主要就是与这些符号打交道，它要把每一个源代码文件的符号的定义和引用都关联起来，让每一次符号引用（即内存引用）都能定位到正确的内存定义上（符号真正的内存地址）。</p>
<p>　　因此，链接主要的任务有两个，符号解析与重定位。符号解析需要借助一个叫做符号表的数据结构，它把源代码中涉及到的所有符号都单独提出来，以便在链接时候帮助定位每一个符号定义和引用，把每一次引用都与一次定义关联起来。这个符号表在每个可重定位目标程序中都存在，依上例，main.o和sum.o都有一个这样的结构。重定位就是把所有可重定位目标程序的数据和代码都合到一个文件里，给它们指定符号定义的真正的内存地址，并修改每一次符号引用的地址。</p>
<h3 id="elf文件结构"><a href="#elf文件结构" class="headerlink" title="elf文件结构"></a>elf文件结构</h3><p>　　由于链接过程涉及的符号解析和重定位都与elf文件的某个结构相关，因此先介绍一下elf文件结构。</p>
<p><img src="/img/reconstruct-elf.jpg" alt="reconstruct-elf"></p>
<p>　　只介绍几个比较重要的部分。</p>
<ol>
<li>.text已编译的机器代码。</li>
<li>.data已初始化的全局和静态变量。</li>
<li>.bss未初始化的全局和静态变量，不真正分配空间，仅仅作为占位符。</li>
<li>.symtab符号表，程序定义和引用的全局变量、静态变量及函数信息。</li>
<li>.rel.text，.text节的可重定位信息。</li>
<li>.rel.data，.data节的可重定位信息。</li>
<li>.strtab, 符号表中出现的符号的名字，符号表会有很多指针指向这个部分的某个偏移。这个部分就是以null结尾的字符串序列。</li>
</ol>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p><img src="/img/symbol.jpg" alt="symbol"></p>
<p><img src="/img/symbol-description.jpg" alt="symbol-description"></p>
<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>　　链接的主要目的是要让多个源代码文件编译生成的多个二进制机器码文件能够合并起来，给代码和数据指定真实的内存地址。符号解析是为重定位服务的。重定位分为两步：</p>
<ol>
<li>把.o文件（可重定位目标文件）合并成一个文件，相同类型的节合到一起，例如.text都合到一起，.data也合到一起，各自成为可执行文件的一个大的.text和.data节。把这些节的每一条代码和数据都指定运行时的内存地址。因此，符号表中的每一个符号都有了正确的运行时内存地址。</li>
<li>重定位符号引用。修改.text和.data中的对每个符号的引用，使其指向正确的运行时地址。</li>
</ol>
<h4 id="rel-text和-rel-data"><a href="#rel-text和-rel-data" class="headerlink" title=".rel.text和.rel.data"></a>.rel.text和.rel.data</h4><p><img src="/img/rel.jpg" alt="rel"></p>
<p>　　type主要有两种类型。</p>
<ol>
<li>R_X86_64_PC32。32位PC相对地址引用</li>
<li>R_X86_64_32。32位绝对地址引用</li>
</ol>
<h4 id="重定位符号引用"><a href="#重定位符号引用" class="headerlink" title="重定位符号引用"></a>重定位符号引用</h4><p><img src="/img/readdr.jpg" alt="readdr"></p>
<p>　　引用《深入理解计算机系统》的例子，说明一下相对地址引用的重定位。</p>
<p><img src="/img/rel-main.jpg" alt="rel-main"></p>
<p><img src="/img/rel-sum.jpg" alt="rel-sum"></p>
<p>　　因为在执行call指令时，PC指向的实际是call指令的下一条指令，所以计算PC相对地址需要有一个-4的padding。</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><h4 id="标准库函数如何链接？"><a href="#标准库函数如何链接？" class="headerlink" title="标准库函数如何链接？"></a>标准库函数如何链接？</h4><p>　　我们平常用到的标准库函数，例如printf, scanf, atoi等等，对每个c程序都是可用的，我们只需要include相应的头文件，例如<code>#include &lt;stdlib.h&gt;</code>这样，就可以使用。但我们在编译时候并没有显式的指定相应的源代码文件，那么这些代码是怎么跟我们自己写的代码链接到一起的呢？</p>
<p>　　在说gcc的做法之前，我们可以先思考一下，如果是自己实现编译器，会怎么处理这个问题。</p>
<ol>
<li>把所有的库函数硬编码到编译器代码里。但是由于标准库函数非常多，显然会令gcc的实现非常复杂，而且每当库函数有更新，都要更新编译器的版本。</li>
<li>将所有标准c函数都编译到一个可重定位目标文件（.o）文件里，然后每次链接的时候指定一下<code>gcc main.c /usr/lib/libc.o</code>。但是，可能我们的代码只用到一个printf函数，但我们就需要把所有库函数的代码和数据段都合并到最终的可执行文件中，白白浪费磁盘空间。</li>
<li>将每一个标准库函数单独编译成一个.o文件，在需要的时候手动链接。例如<code>gcc main.c /usr/lib/prinf.o /usr/lib/scanf.o</code>，这样编译过程就弄得非常复杂，对于大项目，我们可能要手动链接成百上千个.o文件。</li>
</ol>
<h4 id="linux的做法"><a href="#linux的做法" class="headerlink" title="linux的做法"></a>linux的做法</h4><p>　　静态库以归档文件的特殊格式存放在磁盘上，由.a后缀标识。将标准库函数拆分成很多的目标模块，将不同的模块一起打包成一个.a文件。在链接的时候，判断我们的程序用到哪个模块，就把哪个模块的数据段和代码段和我们的程序一起链接成可执行文件。标准库归档文件libc.a会自动作为参数传给编译器，无需显示指定。</p>
<h4 id="静态库链接的符号解析过程"><a href="#静态库链接的符号解析过程" class="headerlink" title="静态库链接的符号解析过程"></a>静态库链接的符号解析过程</h4><p><code>gcc foo.c libx.a liby.a libz.a</code></p>
<ol>
<li>整个链接过程，编译器会维护两个数据集合。一个代表所有已定义的符号集合D，一个代表未解析的符号结合U。</li>
<li>一个一个分析输入参数，如果是可重定位目标文件，将所有已定义的符号都加入到D集合中，把所有该文件引用了，但没有找到定义的符号都加入到集合U中。</li>
<li>如果输入参数是归档文件，那么就遍历该归档文件的所有模块，看哪些模块定义了当前集合U中的符号，找到的话把这个模块加入链接，并去掉U中的相应符号。同时把模块里的所有符号按照一样的规则加入到集合D和集合U中。</li>
</ol>
<p>　　从链接的过程可以看到，参数的顺序非常重要。如果foo.c引用了libz.a的某个模块的符号，而该模块的某个符号又引用了libx.a的一个符号，就会链接失败。一般各个库都是相对独立的，我们只要保证把自己写的源文件放到最前面就好了。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>　　现代的标准库函数都是动态链接的，即在编译时不进行链接，而在运行可执行文件时候才进行链接。</p>
<h4 id="静态链接有什么问题？"><a href="#静态链接有什么问题？" class="headerlink" title="静态链接有什么问题？"></a>静态链接有什么问题？</h4><ol>
<li>几乎所有程序都需要printf这样的库函数，每个可执行文件都包含该模块的代码段和数据段，浪费磁盘空间。</li>
<li>linux采用虚拟内存管理内存分配，每个进程的内存空间是独立的，运行时所有程序都要把这些库函数代码段和数据段加载到自己的内存里，浪费内存。</li>
</ol>
<h4 id="如何实现动态链接"><a href="#如何实现动态链接" class="headerlink" title="如何实现动态链接"></a>如何实现动态链接</h4><ol>
<li>共享库是.so文件，不会和我们自己的代码一起合并成可执行文件，不占磁盘空间。</li>
<li>运行时一个共享库的代码段和数据段在物理内存中只有一份，但映射到多个虚拟内存片段上，供不同程序使用。其中代码段是只读的，整个操作系统绝对只有一份。但数据段有可能被修改，在修改的时候则会复制一个副本，每个进程有自己的一个内存副本。</li>
<li>共享库的代码段和数据段加载到任意的内存段中，位置不固定。</li>
<li>加载完成后，进行符号重定位。</li>
</ol>
<p>　　回想一下之前说过的重定位过程，需要修改所有符号引用的地址。由于动态链接在运行时才确定共享库代码段和数据段的内存地址，所以在运行时才能进行重定位。</p>
<ol>
<li>运行时修改代码，想想就觉得不优雅。</li>
<li>Linux不允许在运行时修改代码段。</li>
</ol>
<p>　　由此，要完成动态链接，还需要引入了最后一个重要的概念，位置无关代码，即在加载时无需重定位的代码。</p>
<h4 id="位置无关代码（Position-Independent-Code-PIC）"><a href="#位置无关代码（Position-Independent-Code-PIC）" class="headerlink" title="位置无关代码（Position-Independent Code, PIC）"></a>位置无关代码（Position-Independent Code, PIC）</h4><p>　　所有的技巧都来自于一个标准：无论是共享库还是目标模块，代码段和数据段的距离都是恒定的。由于数据段是可以在运行时修改的，所以可以把对代码段的修改转化为对数据段的修改。</p>
<p>　　在数据段前面加入一个数据结构，全局偏移量表（GOT）。每一个被该模块引用的符号，都在GOT里有一个8字节条目，并为每个条目生成一个重定位条目。</p>
<p><img src="/img/pic.jpg" alt="pic"></p>
<p>　　这样，在重定位时只需要重定位GOT相应条目的内容即可，不需要修改代码段。</p>
<h3 id="加载可执行文件"><a href="#加载可执行文件" class="headerlink" title="加载可执行文件"></a>加载可执行文件</h3><h4 id="可执行文件磁盘布局"><a href="#可执行文件磁盘布局" class="headerlink" title="可执行文件磁盘布局"></a>可执行文件磁盘布局</h4><p><img src="/img/disk-structure.jpg" alt="disk-structure"></p>
<h4 id="可执行文件内存布局"><a href="#可执行文件内存布局" class="headerlink" title="可执行文件内存布局"></a>可执行文件内存布局</h4><p><img src="/img/mem-structure.jpg" alt="mem-structure"></p>
<h4 id="加载时需要做什么？"><a href="#加载时需要做什么？" class="headerlink" title="加载时需要做什么？"></a>加载时需要做什么？</h4><p>　　把相应的文件区域映射到内存区域，要知道从哪个文件偏移的多少字节数据是哪个程序段的，需要加载到哪个内存地址上。这就需要借助ELF头部和段头部表里。</p>
<h4 id="xv6加载内核程序到内存"><a href="#xv6加载内核程序到内存" class="headerlink" title="xv6加载内核程序到内存"></a>xv6加载内核程序到内存</h4><p>　　内核代码也是一个elf格式的文件存放在磁盘上。以这一段xv6教学操作系统加载内核的小函数为例，分析可执行文件的加载过程。当然，这个过程是几十年前的技术了，现代</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> elfhdr *elf;</div><div class="line">  <span class="keyword">struct</span> proghdr *ph, *eph;</div><div class="line">  <span class="keyword">void</span> (*entry)(<span class="keyword">void</span>);</div><div class="line">  uchar* pa;</div><div class="line"></div><div class="line">  elf = (<span class="keyword">struct</span> elfhdr*)<span class="number">0x10000</span>;  <span class="comment">// scratch space</span></div><div class="line"></div><div class="line">  <span class="comment">// Read 1st page off disk</span></div><div class="line">  readseg((uchar*)elf, <span class="number">4096</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Is this an ELF executable?</span></div><div class="line">  <span class="keyword">if</span>(elf-&gt;magic != ELF_MAGIC)</div><div class="line">    <span class="keyword">return</span>;  <span class="comment">// let bootasm.S handle error</span></div><div class="line"></div><div class="line">  <span class="comment">// Load each program segment (ignores ph flags).</span></div><div class="line">  ph = (<span class="keyword">struct</span> proghdr*)((uchar*)elf + elf-&gt;phoff);</div><div class="line">  eph = ph + elf-&gt;phnum;</div><div class="line">  <span class="keyword">for</span>(; ph &lt; eph; ph++)&#123;</div><div class="line">    pa = (uchar*)ph-&gt;paddr;</div><div class="line">    readseg(pa, ph-&gt;filesz, ph-&gt;off);</div><div class="line">    <span class="keyword">if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)</div><div class="line">      stosb(pa + ph-&gt;filesz, <span class="number">0</span>, ph-&gt;memsz - ph-&gt;filesz);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Call the entry point from the ELF header.</span></div><div class="line">  <span class="comment">// Does not return!</span></div><div class="line">  entry = (<span class="keyword">void</span>(*)(<span class="keyword">void</span>))(elf-&gt;entry);</div><div class="line">  entry();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>elfhdr结构体就是ELF头部的格式。首先解析elf头部。</li>
<li>首先检查magic字段，判断该文件是否是elf格式文件。</li>
<li>然后取出elf-&gt;phoff，找出程序头部表在文件中的位置;取出elf-&gt;phnum，找出程序头部表的数目，一般代码段是一个程序段，数据段也是一个段，phnum有两个。proghdr结构体就是程序头部表的格式。</li>
<li>逐个程序段解析proghdr，ph-&gt;paddr代表程序段的要加载到的内存地址，ph-&gt;filesz代表在文件中的大小，ph-&gt;memsz代表加载到内存后的大小。调用readseg函数读磁盘内容到相应内存位置，memsz有可能比filesz大，因为.bss和.data一起作为一个程序段加载到内存，最后的部分可能要补0预先占位。</li>
<li>elf-&gt;entry是入口函数的地址，这个函数最终调用main函数。</li>
</ol>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis 浅析单机服务器工作原理]]></title>
      <url>http://wjqwsp.github.io/2018/04/16/redis-%E6%B5%85%E6%9E%90%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　redis服务器的设计非常精巧，涵盖了内存kv数据库要考虑的方方面面。本文旨在总结和分析单机服务器部分的工作原理以及设计思想，希望能尽可能地涵盖整个单机服务器的工作流程。<br><a id="more"></a></p>
<h3 id="服务器启动"><a href="#服务器启动" class="headerlink" title="服务器启动"></a>服务器启动</h3><h4 id="配置参数加载"><a href="#配置参数加载" class="headerlink" title="配置参数加载"></a>配置参数加载</h4><p>　　redis服务器可以让用户配置许多系统参数，以定制适合自己业务场景的系统，同时也对所有可配置的参数提供了默认项。这些参数包括触发数据库备份的条件，内存回收的策略，客户端的最大空闲时间（超过会被释放）等等。在启动服务器时，会加载所有系统参数。</p>
<p>　　这里还有一个比较关键的步骤是创建了命令表。redis server以redisCommand的结构体来表示客户端要执行的命令，在服务器初始化时会把这些结构体都放到一个哈希表里，以命令名为key。当收到客户端的数据并解析成功后，就会在该哈希表里找到相应的redisCommand，并执行结构体内保存的命令函数。</p>
<h4 id="设置redis服务器为守护进程"><a href="#设置redis服务器为守护进程" class="headerlink" title="设置redis服务器为守护进程"></a>设置redis服务器为守护进程</h4><p>　　如果配置了redis为守护进程的形式启动，则会运行daemonize()函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* parent exits */</span></div><div class="line">    setsid(); <span class="comment">/* create a new session */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Every output goes to /dev/null. If Redis is daemonized but</span></div><div class="line">     * the 'logfile' is set to 'stdout' in the configuration file</div><div class="line">     * it will not log at all. */</div><div class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">"/dev/null"</span>, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</div><div class="line">        dup2(fd, STDIN_FILENO);</div><div class="line">        dup2(fd, STDOUT_FILENO);</div><div class="line">        dup2(fd, STDERR_FILENO);</div><div class="line">        <span class="keyword">if</span> (fd &gt; STDERR_FILENO) close(fd);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这里先顺便总结一下创建守护进程的一般流程：</p>
<ol>
<li><p>fork()创建子进程，父进程exit()退出。这是创建守护进程的第一步。确保进程不是会话首进程，让init接管该进程。</p>
</li>
<li><p>在子进程中调用 setsid() 函数创建新的会话。在调用了 fork() 函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来。</p>
</li>
<li><p>再次 fork() 一个子进程并让父进程退出。现在，进程已经成为无终端的会话组长，但它可以重新申请打开一个控制终端，可以通过 fork() 一个子进程，该子进程不是会话首进程，该进程将不能重新打开控制终端。退出父进程。</p>
</li>
<li><p>在子进程中调用 chdir() 函数，让根目录 ”/” 成为子进程的工作目录。这一步也是必要的步骤。使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统（如“/mnt/usb”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入单用户模式）。因此，通常的做法是让”/“作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp。改变工作目录的常见函数是chdir。</p>
</li>
<li><p>在子进程中调用 umask() 函数，设置进程的文件权限掩码为0。文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限。由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为0，可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是umask。在这里，通常的使用方法为umask(0)。</p>
</li>
<li><p>在子进程中关闭任何不需要的文件描述符。同文件权限码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，文件描述符为0、1和2 的3个文件（常说的输入、输出和报错）已经失去了存在的价值，也应被关闭。</p>
</li>
<li><p>守护进程退出处理。当用户需要外部停止守护进程运行时，往往会使用 kill 命令停止该守护进程。所以，守护进程中需要编码来实现 kill 发出的signal信号处理，达到进程的正常退出。</p>
</li>
</ol>
<p>　　从redis的源代码中可以看到，redis创建守护进程并没有完全实现上述步骤。其中，第二次fork去掉了，只要保证redis server之后不会重新申请控制终端就行。umask和关闭文件描述符也没有，因为redis server在刚启动时就创建守护进程，没有打开文件，也没有修改文件权限掩码，之后使用文件也没有特殊的要求。之后，redis把标准输入，标准输出和标准错误都重定向到/dev/null里了。</p>
<p>　　另外，redis还创建了pid file保存守护进程的Pid。</p>
<p>　　作为守护进程，redis有自己的信号处理机制，后面会介绍。</p>
<h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><p>　　redis首先会忽略SIGHUP和SIGPIPE两个信号。SIGHUP前面也讲过，而SIGPIPE主要是处理客户端tcp连接关闭以后，服务器还往客户端写数据的问题。这是因为：对一个对端已经关闭的socket调用两次write, 第二次将会生成SIGPIPE信号, 该信号默认结束进程。</p>
<p>　　TCP是全双工的信道, 可以看作两条单工信道, TCP连接两端的两个端点各负责一条。当对端调用close时, 虽然本意是关闭整个两条信道, 但本端只是收到FIN包。 按照TCP协议的语义, 表示对端只是关闭了其所负责的那一条单工信道, 仍然可以继续接收数据. 也就是说, 因为TCP协议的限制, 一个端点无法获知对端的socket是调用了close还是shutdown。</p>
<p>　　对一个已经收到FIN包的socket调用read方法, 如果接收缓冲已空, 则返回0, 这就是常说的表示连接关闭. 但第一次对其调用write方法时, 如果发送缓冲没问题, 会返回正确写入(发送). 但发送的报文会导致对端发送RST报文, 因为对端的socket已经调用了close, 完全关闭, 既不发送, 也不接收数据.。所以, 第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号, 导致进程退出。</p>
<p>　　redis还自定义了一些信号处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigtermHandler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</div><div class="line">    REDIS_NOTUSED(sig);</div><div class="line"></div><div class="line">    redisLogFromHandler(REDIS_WARNING,<span class="string">"Received SIGTERM, scheduling shutdown..."</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 打开关闭标识</span></div><div class="line">    server.shutdown_asap = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupSignalHandlers</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sigaction act;</div><div class="line"></div><div class="line">    <span class="comment">/* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.</span></div><div class="line">     * Otherwise, sa_handler is used. */</div><div class="line">    sigemptyset(&amp;act.sa_mask);</div><div class="line">    act.sa_flags = <span class="number">0</span>;</div><div class="line">    act.sa_handler = sigtermHandler;</div><div class="line">    sigaction(SIGTERM, &amp;act, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_BACKTRACE</span></div><div class="line">    sigemptyset(&amp;act.sa_mask);</div><div class="line">    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;</div><div class="line">    act.sa_sigaction = sigsegvHandler;</div><div class="line">    sigaction(SIGSEGV, &amp;act, <span class="literal">NULL</span>);</div><div class="line">    sigaction(SIGBUS, &amp;act, <span class="literal">NULL</span>);</div><div class="line">    sigaction(SIGFPE, &amp;act, <span class="literal">NULL</span>);</div><div class="line">    sigaction(SIGILL, &amp;act, <span class="literal">NULL</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　一般的kill命令会发送SIGTERM信号，redis自定义了该信号的处理函数，该函数设置server.shutdown_asap = 1。在redis的时间处理器中，会检查该标志位，如果标记为1，则会进行一些必要的保存和清理操作，打日志，然后退出进程，更详细的过程后面介绍。建议通过该方式退出redis。</p>
<p>　　SIGSEGV等信号则是一些运行时错误导致redis退出，redis也自定义了信号处理函数。该信号处理函数主要是打日志，打调用栈等有助于debug的信息，然后如果是守护进程形式运行redis的话，还会删除pid file。我们可以看看sigsegvHandler的最后干了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sigemptyset (&amp;act.sa_mask);</div><div class="line">act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;</div><div class="line">act.sa_handler = SIG_DFL;</div><div class="line">sigaction (sig, &amp;act, <span class="literal">NULL</span>);</div><div class="line">kill(getpid(),sig);</div></pre></td></tr></table></figure>
<p>　　SIG_DFL表示默认的信号处理。redis在该信号处理函数后面又把信号处理函数设成原默认的处理方式，随即给自己发送了相同的信号，进行默认的信号处理。这里SA_RESETHAND代表当调用信号处理函数时，将信号的处理函数重置为缺省值SIG_DFL。一般情况下，当信号处理函数运行时，内核将阻塞该给定信号。但是如果设置了SA_NODEFER标记，那么在该信号处理函数运行时，内核将不会阻塞该信号。SA_NODEFER | SA_RESETHAND说明当在信号处理过程中又有相同的信号到达，那么马上执行默认的信号处理函数。</p>
<p>　　这里的SA_ONSTACK值得探讨一下。信号处理函数是在用户态栈上运行的，如果因为栈溢出触发的该信号，那么换一个栈执行信号处理显然更合适。</p>
<h3 id="初始化数据结构"><a href="#初始化数据结构" class="headerlink" title="初始化数据结构"></a>初始化数据结构</h3><p>　　初始化redis server的数据结构，留到创建守护进程之后，避免fork造成大量的内存拷贝。创建的数据结构很多，这里挑单机数据库里比较重要的几个介绍。</p>
<h4 id="创建共享对象"><a href="#创建共享对象" class="headerlink" title="创建共享对象"></a>创建共享对象</h4><p>　　共享对象大量用在输出缓冲区的链表中，以及直接用作数据库的object，都是比较常用的数据。这些数据在系统启动时预先创建，以节约系统内存。</p>
<h4 id="修改进程的最大打开文件数"><a href="#修改进程的最大打开文件数" class="headerlink" title="修改进程的最大打开文件数"></a>修改进程的最大打开文件数</h4><p>　　每一个redisClient都要维护一个socket连接，都需要一个文件描述符，redis必须保证一定的最大打开文件数来确保客户端的数量。</p>
<h4 id="创建事件循环"><a href="#创建事件循环" class="headerlink" title="创建事件循环"></a>创建事件循环</h4><p>　　事件循环用作管理redis的所有client，封装了io多路复用和事件处理功能。</p>
<h4 id="创建基本事件处理器"><a href="#创建基本事件处理器" class="headerlink" title="创建基本事件处理器"></a>创建基本事件处理器</h4><p>　　每个redis server进程绑定配置好的ip或者0.0.0.0在配置的端口上进行监听，等待tcp连接的到达；如果配置了unixsocket的路径，则还要监听unixsocket，默认是没有配置。并把创建的socket文件描述符绑定到事件处理器上，在event loop中进行io多路复用。同时还创建了一个时间事件处理器，定时执行serverCron函数。</p>
<h4 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h4><p>　　创建系统配置文件指定的或者默认数目的数据库，主要是创建dict和expires两个dict结构。</p>
<h3 id="判断操作系统是否允许overcommit-memory"><a href="#判断操作系统是否允许overcommit-memory" class="headerlink" title="判断操作系统是否允许overcommit_memory"></a>判断操作系统是否允许overcommit_memory</h3><p>　　操作系统可以允许申请的内存大于系统的总内存。因为很多时候进程实际使用的内存小于申请的内存，而linux系统实际的内存分配是在使用的瞬间而不是在申请的瞬间。如果不允许overcommit_memory的话，redis在执行background save的时候有可能因当前操作系统剩余的内存过低而失败。这里会检查操作系统是否允许overcommit_memory，如果不允许的话会在日志打出warning。</p>
<h3 id="从持久化文件中加载数据库数据"><a href="#从持久化文件中加载数据库数据" class="headerlink" title="从持久化文件中加载数据库数据"></a>从持久化文件中加载数据库数据</h3><p>　　redis是内存数据库，但支持持久化，持久化方式有rdb和aof。在系统启动时候，默认会先判断是否开启aof，如果开启了则从aof文件中加载数据；否则从rdb文件中加载数据。因为如果aof开启的话，aof文件往往比rdb持久化的数据更多，但从aof文件加载数据要比rdb慢，因为rdb是二进制协议文件，体积更小，且不用进行字符解析。在加载过程中，redis server也可以响应部分事件，执行部分指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">processEventsWhileBlocked</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> iterations = <span class="number">4</span>; <span class="comment">/* See the function top-comment. */</span></div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (iterations--) &#123;</div><div class="line">        <span class="keyword">int</span> events = aeProcessEvents(server.el, AE_FILE_EVENTS|AE_DONT_WAIT);</div><div class="line">        <span class="keyword">if</span> (!events) <span class="keyword">break</span>;</div><div class="line">        count += events;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在加载过程中，每隔一段时间会执行上述函数一次。io多路复用机制会监听当前是否有文件事件到达，但不阻塞。</p>
<h3 id="进入事件循环"><a href="#进入事件循环" class="headerlink" title="进入事件循环"></a>进入事件循环</h3><p>　　redis server的主函数核心部分就是不断地在事件循环中进行事件处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line"></div><div class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 如果有需要在事件处理前执行的函数，那么运行它</span></div><div class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</div><div class="line">            eventLoop-&gt;beforesleep(eventLoop);</div><div class="line"></div><div class="line">        <span class="comment">// 开始处理事件</span></div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在while循环中不断调用事件处理函数，利用io多路复用机制处理文件事件以及定期执行时间事件处理器。文件事件处理在上一篇博文中已有讲述，下一部分将重点讲述redis的时间事件处理函数serverCron，看看redis server定期处理了什么。</p>
<h3 id="服务器定时任务"><a href="#服务器定时任务" class="headerlink" title="服务器定时任务"></a>服务器定时任务</h3><h4 id="软件看门狗"><a href="#软件看门狗" class="headerlink" title="软件看门狗"></a>软件看门狗</h4><p>　　设置信号SIGALRM的下次到达时间。如果在规定时间内定时任务还不启动的话，说明系统延迟较大，使得定时任务被推延了。这时候会进入SIGALRM的信号处理函数，该函数会打印一些有用的日志帮助用户找出系统的问题。如果系统运行足够快，那么在下次进入定时函数时，会重置看门狗的时间，使得信号SIGALRM一直不会到达。一般该时间要设置成定时函数运行的时间间隔的2倍，这样才有意义。</p>
<h4 id="更新时间"><a href="#更新时间" class="headerlink" title="更新时间"></a>更新时间</h4><p>　　定时任务中发起系统调用，得到当前时间，以及LRU时钟。因为这些时间会被频繁查询，如果每次都进行系统调用则会影响性能，所以在定时任务中缓存一份，对于对时间精度要求不高的动作，则可以直接使用该缓存时间，而不需要进行系统调用。</p>
<h4 id="检查是否需要关闭redis进程"><a href="#检查是否需要关闭redis进程" class="headerlink" title="检查是否需要关闭redis进程"></a>检查是否需要关闭redis进程</h4><p>　　前面说到，如果收到信号SIGTERM，则会设置server.shutdown_asap = 1，表示要异步关闭redis服务器进程。redis会在定时任务中进行清理和保存任务，然后安全退出。</p>
<ol>
<li>如果此时有rdb或者aof的后台进程，把它们kill掉，因为之后会重新进行rdb备份，以免发生多进程的竞态条件。redis server杀死子进程用的是SIGUSR1信号，该信号被认为是官方信号，不同于其他信号，用这种方式杀死子进程，不会被认为是备份失败。执行rdbsave，进行snapshot。</li>
<li>移除pid文件。</li>
<li>把所有socket连接都主动close，这样重启时候会快一点。</li>
</ol>
<h4 id="检查客户端"><a href="#检查客户端" class="headerlink" title="检查客户端"></a>检查客户端</h4><p>　　服务器会定期检查所有的客户端，包括销毁一些超时的客户端以及缩小客户端的查询缓冲区大小。每次会检查客户端数目（<em>1/server.hz</em>10）个客户端。由于客户端检查每秒会检查server.hz次，而server.hz最小是1，所以最多需要10秒遍历所有客户端。每次检查至少遍历50个客户端。</p>
<p>　　检查的时候会取出客户端列表的尾端元素，放到表头，然后检查是否需要关闭。关闭的时候只需要删除表头就行。</p>
<p>  　除了一些特殊的客户端，例如复制的master和slave，如果客户端最后通信时间超过一个设定值，则会被关闭。</p>
<p>　　如果查询缓冲区的大小大于 BIG_ARG 以及是querybuf_peak的两倍，或者客户端不活跃，并且缓冲区大于 1k，则会把sds中free的空间释放掉。</p>
<p>　　</p>
<h4 id="删除过期键"><a href="#删除过期键" class="headerlink" title="删除过期键"></a>删除过期键</h4><p>　　Redis会定期清理数据库中过期的键值对。清理分两种模式，一种是慢速清理，这个是正常情况下在每次定时任务中要执行的清理动作，一般时间较长，占大约25%的CPU时间；还有一种快速清理，是在上一次慢速清理时候超时了，那么会在下次执行定时任务前快速的执行一次清理动作，一般时间较短，默认是1毫秒。每次清理会检查一定量的数据库，每个数据库检查一定量的过期键。如果数据库没有设置了过期时间的键，那么跳过该数据库。如果该数据库使用率较低，那么也跳过，因为如果检查该库，会遍历大量的空槽位，浪费CPU时间。如果在检查某个数据库的过程中发现过期的键数目较多，超过要检查键数目的25%，那么会对该数据库进行多一轮清理。</p>
<h4 id="数据库rehash"><a href="#数据库rehash" class="headerlink" title="数据库rehash"></a>数据库rehash</h4><p>　　不同于字典类型的value，在插入和删除项的时候会检查是否需要rehash，然后把rehash分摊到每次对该值的操作中。数据库本身的字典表是在定时任务中定期检查是否需要rehash，并且执行渐进式rehash，每次检查一定量的数据库，如果需要rehash，则在每次花1毫秒的时间进行rehash，如果没有rehash结束，则留到下一次定时任务中。只要执行了一次渐进性rehash，则会结束遍历其他库，避免在定时任务中耗费时间过多，阻塞服务器。如果有rdb和aof重写的子进程在工作，那么先不进行rehash，避免copy-on-write机制触发大量的内存拷贝。</p>
<h4 id="rdb和aof"><a href="#rdb和aof" class="headerlink" title="rdb和aof"></a>rdb和aof</h4><p>　　检查rdb备份的条件是否满足，即距离上次rdb备份是否对数据库做了足够多的修改，以及检查aof文件的大小，确定是否需要进行重写。</p>
<p>　　如果上次aof写发生错误，则在定时任务中再执行一次flush任务，以清除错误标识，让数据库变得可写。</p>
<p>　　用wait3系统调用以非阻塞方式检查rdb和aof重写的子进程是否结束了，执行相应的回调函数。回调函数中一般是检查子进程的返回码以及是否被信号中断，设置相应的备份状态。如果子进程失败了并且不是以官方手段正常信号终止的，那么会标记成error，只要这个error状态不被清楚，数据库就不可写。</p>
<h3 id="beforeSleep函数"><a href="#beforeSleep函数" class="headerlink" title="beforeSleep函数"></a>beforeSleep函数</h3><p>　　在开始事件循环之前，还会执行一个beforeSleep函数。对于单机服务器来说，这个函数主要有两个功能：</p>
<ol>
<li>如果上次清理过期键超时了，需要执行快速模式的清理过期键，那么执行一次。</li>
<li>把aof缓冲区的内容flush到磁盘上，保证数据的可靠性。</li>
</ol>
<h3 id="执行命令及内存清理"><a href="#执行命令及内存清理" class="headerlink" title="执行命令及内存清理"></a>执行命令及内存清理</h3><p>　　在文件事件中，最核心的就是执行客户端传来的命令。在介绍redis服务器和客户端通信那篇博文里，已介绍了redis如何从输入缓冲区中读取并解析命令，最终获得一个redisCommand的对象。该对象有一个字段绑定了相应的处理函数，执行该函数会对数据库做读写操作，从而执行了命令，这里并没有什么难以理解的部分。我主要想介绍一下redis的主动内存清理策略。</p>
<p>　　如果服务器设置了最大内存，在执行任务时，Redis会检查当前Redis服务器占用的内存是否超过了设定值，如果超过则要按照配置的内存清理策略释放内存。如果内存释放失败并且该命令需要占用大量内存的话，那么拒绝执行。</p>
<p>　　清理策略可能是对数据库表进行清理，也可能是对过期表进行清理。第一种策略是每个数据库随机选一个key删除，直到内存减少到最大内存一下；第二种策略是选择一个样本集合，从过期表中随机抽取键值对放到集合中，然后从集合中找出过期时间最长的键。最后一种策略是用了LRU算法，我想重点介绍一下该策略。</p>
<p>　　一般而言，LRU算法是寻找最近使用时间最久的删除，因此会维护一个所有元素的有序链表。Redis为了节省内存以及插入和删除数据的时间，用一个驱逐池和比较样本集结合来代替有序链表。驱逐池实际上是一个升序数组，的每个元素有两个字段，一个是key，代表相应数据库元素的key，一个是idle time，用LRU clock来近似计算，按idle time的升序排列。默认驱逐池有16个元素。</p>
<p>　　每次要执行内存清理时，会遍历每个数据库，每个数据库都弹出一个比较样本集，默认是16个。这里有一个优化的技巧，redis会在栈上默认分配16个字典元素的数组，只有当设置的样本数大于16个，才会在堆上分配，在样本数较少时能减少内存分配的系统调用。</p>
<p>　　比较样本集的元素逐个与驱逐池的元素比较，驱逐池按idle time从小到大排列。在比较的时候维护一个数组索引指针，如果比较样本集的元素的idle time大于相应相应索引的驱逐池元素，则把该比较样本集的元素插入到该元素的右端，反之插入在左端，从而让驱逐池永远保持按idle time的升序排列。</p>
<p>　　在要删除元素时，只要从右往左遍历驱逐池，把最右侧的元素删除即可。驱逐池与比较样本集越大，idle time的比较越精确，但同时要消耗更多的内存，同时在比较时会更耗时，容易造成服务器阻塞。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis 浅析IO多路复用与事件处理]]></title>
      <url>http://wjqwsp.github.io/2018/03/25/redis-%E6%B5%85%E6%9E%90IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>　　在讲redis的IO多路复用机制前，先简单介绍一下其他几种常见的IO模型。这几种IO模型的根本差异在于以下两个过程的处理方式不同：</p>
<ol>
<li>kernel等待足够的数据到达。</li>
<li>kernel将数据从内核空间拷贝到用户空间。</li>
</ol>
<a id="more"></a>
<h4 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h4><p>　　上述两个过程都是阻塞的，进程会一直阻塞直到数据到达并从内核空间拷贝到用户空间。</p>
<h4 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h4><p>　　第一个过程是非阻塞的，当没有数据到达时，调用会立即返回，此时用户进程需要不断轮询，如果轮询频繁，则浪费了大量的CPU资源；如果轮询频率低，则不能实时地获取数据。</p>
<h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>　　以上两个过程都是非阻塞的，当进程发起系统调用之后会马上返回，可以继续干别的事情，当数据在用户空间准备好后，内核会给用户进程一个signal。</p>
<h4 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h4><p>　　第一个过程是非阻塞的，当数据在内核中准备好后会给进程发送一个signal。但之后用户进程必须以阻塞的方式从内核中把数据拷贝到用户空间，因此本质上还是同步IO。</p>
<h3 id="Redis为何要使用IO多路复用"><a href="#Redis为何要使用IO多路复用" class="headerlink" title="Redis为何要使用IO多路复用"></a>Redis为何要使用IO多路复用</h3><p>　　IO多路复用的本质是同步阻塞IO，但是，它最大的优势在于可以在一次阻塞中监听多个文件描述符。我们代入Redis的场景，来分析一下为什么需要用到IO多路复用。</p>
<ol>
<li>需要处理多个客户端连接，最先想到的恐怕是用多个线程，每个线程处理一个连接。多线程的的存在必然需要昂贵的上下文切换，而且每个线程会有内存消耗，开销还是较大，如果只是要找出有事件到达的客户端，用多线程显然是得不偿失的。Redis本身就是单进程单线程的模式工作，多线程等待多个客户端显然与其系统思想不符。</li>
<li>假如采用普通的同步阻塞IO，那么Redis可能会在一个客户端上长期阻塞。该客户端可能长期没有数据到达，而Redis需要处理多个客户端的通信，当其他客户端有请求到达时，Redis则无法处理了，这显然是无法接受的。</li>
<li>假如采用同步非阻塞IO，那么Redis的确可以不断地按顺序轮询所有客户端。但很可能客户端是长期空闲的，这种反复地轮询会浪费大量的CPU资源。</li>
</ol>
<p>　　Redis需要的是可以单线程同时监听多个客户端，IO多路复用显然使其首选。</p>
<h3 id="IO多路复用原理"><a href="#IO多路复用原理" class="headerlink" title="IO多路复用原理"></a>IO多路复用原理</h3><p>　　IO多路复用的实现主要是Unix的3个系统调用，按性能升序排列分别是select,poll和epoll。其他操作系统也有类似的系统函数。下面主要介绍并比较一下select,poll和epoll这三个系统调用。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>　　主要用到的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n,</span></span></div><div class="line">fd_set *readfds,</div><div class="line">fd_set *writefds,</div><div class="line">fd_set *exceptfds,</div><div class="line"><span class="keyword">struct</span> timeval *timeout);</div><div class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</div><div class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</div><div class="line">FD_SET(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</div><div class="line">FD_ZERO(fd_set *<span class="built_in">set</span>);</div></pre></td></tr></table></figure>
<p>　　select的第一个参数代表要检查的最大描述符加1，第二个参数代表要监听读事件的文件描述符集合，第三个参数代表要监听写事件的文件描述符集合，第四个参数代表要监听异常事件的文件描述符集合，第五个参数代表超时时间。当有文件描述符有相应监听事件发生，则select返回，或者在超过timeout指定的时间后，仍然没有事件到达，则函数仍然返回。函数返回后，readfds,writefds和exceptfds指向的集合包含所有有事件响应的文件描述符，即函数调用前后参数会改变。</p>
<p>　　fd_set的实现一般是比特数组，用比特置位复位操作来表示有哪个事件响应。unix定义了几个宏来处理fd_set。FD_CLR用于取消集合中某个文件描述符的事件监听；FD_ISSET用于判断文件描述符是否存在于集合中，从而判断是否有该事件发生；FD_SET用于加入某个文件符进行事件监听；FD_ZERO用于清空集合。</p>
<p>　　select的缺点主要有：</p>
<ol>
<li>函数调用前后参数会改变，如果要重新进行监听的话要重新修改传入的集合参数。</li>
<li>用比特数组构建集合，在内核中需要遍历整个集合来找出有事件响应的文件描述符，如果监听的文件描述符排列非常稀疏，那么遍历操作浪费的时间更多。</li>
<li>每次调用都要重复拷贝文件描述符信息到内核空间，并且重新绑定事件到设备的等待队列以等待唤醒。</li>
<li>监听的最大文件描述符有限制，一般是1024。</li>
</ol>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>　　主要用到的函数与数据类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> pollfd &#123;</div><div class="line"><span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></div><div class="line"><span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></div><div class="line"><span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>　　与select不同的是，poll的参数不是比特数组，而是pollfd结构体，每个pollfd指定一个监听的文件描述符以及监听的事件。events的值一般是宏POLLIN，POLLOUT或者POLLIN|POLLOUT。并且当函数返回后，revents的值会变成有响应的事件。</p>
<p>　　与select相比，poll主要有以下优势：</p>
<ol>
<li>没有1024的文件描述符限制。</li>
<li>函数返回不会弄乱输入参数，下次还可以复用原来的参数。</li>
<li>内核只需要遍历需要监听的事件来寻找有事件响应的文件描述符，不会有稀疏数组的问题。</li>
</ol>
<p>　　但仍然存在以下不足：</p>
<ol>
<li>仍然需要遍历所有监听的文件描述符，可能有大部分是没有事件响应的。</li>
<li>每次调用都要把要监听的文件描述符信息从用户空间拷贝到内核空间，也同样要把进程绑定到相应设备的等待队列中。</li>
</ol>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>　　epoll基本上解决了select和poll的所有问题，它用到的主要函数和数据类型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span> <span class="params">(<span class="keyword">int</span> flags)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span> <span class="params">(<span class="keyword">int</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span> <span class="params">(<span class="keyword">int</span> epfd,</span></span></div><div class="line"><span class="keyword">int</span> op,</div><div class="line"><span class="keyword">int</span> fd,</div><div class="line"><span class="keyword">struct</span> epoll_event *event);</div><div class="line"></div><div class="line"><span class="keyword">struct</span> epoll_event &#123;</div><div class="line"><span class="number">__u</span>32 events; <span class="comment">/* events */</span></div><div class="line"><span class="keyword">union</span> &#123;</div><div class="line"><span class="keyword">void</span> *ptr;</div><div class="line"><span class="keyword">int</span> fd;</div><div class="line"><span class="number">__u</span>32 u32;</div><div class="line"><span class="number">__u</span>64 u64;</div><div class="line">&#125; data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span> <span class="params">(<span class="keyword">int</span> epfd,</span></span></div><div class="line"><span class="keyword">struct</span> epoll_event *events,</div><div class="line"><span class="keyword">int</span> maxevents,</div><div class="line"><span class="keyword">int</span> timeout);</div></pre></td></tr></table></figure>
<p>　　epoll把事件的注册和事件的监听解耦了。它把一个函数调用分成了3个。其中epoll_create1和epoll_create一般只需要调用一次，会初始化一个epoll实例，返回一个文件描述符作为后续操作的句柄。两个函数基本一样，Redis用到的是epoll_create，它的参数只是需要监听的文件描述符数量的一个hint，实际上文件描述符集合是动态调整的，用户不需要担心size的问题。</p>
<p>　　epoll_ctl用来进行事件的注册或者注销，其中op接受三个值EPOLL_CTL_ADD、EPOLL_CTL_DEL和EPOLL_CTL_MOD。epoll_event指定监听的事件，其中evnets的值一般是EPOLLIN，EPOLLOUT或者EPOLLIN|EPOLLOUT，代表监听读事件和写事件。data字段一般只用到fd。</p>
<p>　　epoll_wait用来真正进行事件监听，该函数会阻塞，直到有事件响应或者超时。函数返回后，events参数指向的数组会包含所有有事件响应的epoll_events。</p>
<p>　　由于事件的注册和监听分离，只有文件描述符产生变动的情况下才会进行从内核到用户空间的内存拷贝以及绑定到等待队列上。而且，当有事件响应之后，响应的事件会以回调的方式把相应的文件描述符插入到一个队列上，因此内核只需要遍历所有发生响应的文件描述符，而不需要遍历所有文件描述符。</p>
<h3 id="Redis的事件处理"><a href="#Redis的事件处理" class="headerlink" title="Redis的事件处理"></a>Redis的事件处理</h3><p>　　监听到有读、写事件发生以后，接着要进行事件处理。Redis会为每个监听的文件描述符绑定一个读事件处理器或者写事件处理器，当事件发生时，会执行相应的事件处理函数。对于不同的客户端绑定的事件处理器可能会不相同，例如一般的客户端和用作复制功能的代表master或slave的客户端。除了文件事件以外，Redis还会定时执行时间事件。下面阐述一下Redis的事件处理机制。</p>
<h4 id="文件事件处理"><a href="#文件事件处理" class="headerlink" title="文件事件处理"></a>文件事件处理</h4><p>　　Redis的文件事件处理实际上是在select,epoll上再封装了一层，Redis会用封装起来的事件处理器，管理要监听的文件描述符集合、已经触发事件的文件描述符集合、最多监听的文件描述符数量、当前监听的最大的文件描述符、每个监听的文件描述符的待监听事件、文件描述符映射的Redis客户端以及事件处理函数等等信息。事件处理器会根据Redis所在的系统，选择性能最好的IO多路复用库作为底层实现。</p>
<h5 id="选择IO多路复用库"><a href="#选择IO多路复用库" class="headerlink" title="选择IO多路复用库"></a>选择IO多路复用库</h5><p>　　Redis会在编译时选择系统性能最好的IO多路复用库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_evport.c"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_epoll.c"</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_kqueue.c"</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_select.c"</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h5 id="初始化事件处理器"><a href="#初始化事件处理器" class="headerlink" title="初始化事件处理器"></a>初始化事件处理器</h5><p>　　Redis服务器在启动时会初始化事件处理器状态，然后，Redis服务器的主函数的主要任务便是循环调用事件处理器，以单进程单线程的模式循环进行事件处理。</p>
<p>　　初始化事件处理器主要是分配内存空间作为要监听的文件描述符集合以及表示已触发事件的文件描述符集合，都用数组来表示，数组索引便是文件描述符号。Redis会事先限定一部分文件描述符数量作为这个集合的size，这个size通常是Redis的最大允许客户端连接数加上一个的缓冲数。Redis服务器初始化并以后一直维护的event loop结构体如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeEventLoop &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 目前已注册的最大描述符</span></div><div class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></div><div class="line"></div><div class="line">    <span class="comment">// 目前已追踪的最大描述符</span></div><div class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></div><div class="line"></div><div class="line">    <span class="comment">// 用于生成时间事件 id</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</div><div class="line"></div><div class="line">    <span class="comment">// 最后一次执行时间事件的时间</span></div><div class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></div><div class="line"></div><div class="line">    <span class="comment">// 已注册的文件事件</span></div><div class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></div><div class="line"></div><div class="line">    <span class="comment">// 已就绪的文件事件</span></div><div class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></div><div class="line"></div><div class="line">    <span class="comment">// 时间事件</span></div><div class="line">    aeTimeEvent *timeEventHead;</div><div class="line"></div><div class="line">    <span class="comment">// 事件处理器的开关</span></div><div class="line">    <span class="keyword">int</span> stop;</div><div class="line"></div><div class="line">    <span class="comment">// 多路复用库的私有数据</span></div><div class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></div><div class="line"></div><div class="line">    <span class="comment">// 在处理事件前要执行的函数</span></div><div class="line">    aeBeforeSleepProc *beforesleep;</div><div class="line"></div><div class="line">&#125; aeEventLoop;</div></pre></td></tr></table></figure>
<p>　　然后，初始化函数会调用底层IO多路复用库的初始化函数，来初始化相应IO多路复用库的事件处理状态。</p>
<p>　　对于select来说，它会维护两组fd_set，每组都有两个fd_set，分别代表读和写。之所以有两组，是因为select调用会弄乱输入的fd_set参数，所以其中一组是用来记录当前要监听的文件描述符，另外一组是用来作为select调用的传入参数的。Redis服务器的事件处理器会维护以下结构体作为事件处理状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeApiState &#123;</div><div class="line">    fd_set rfds, wfds;</div><div class="line">    <span class="comment">/* We need to have a copy of the fd sets as it's not safe to reuse</span></div><div class="line">     * FD sets after select(). */</div><div class="line">    fd_set <span class="number">_</span>rfds, <span class="number">_</span>wfds;</div><div class="line">&#125; aeApiState;</div></pre></td></tr></table></figure>
<p>　　初始化事件处理器时，select会调用FD_ZERO来对rfds和wfds清零。</p>
<p>　　而对于epoll，在初始化事件处理器时会调用epoll_create初始化一个epoll实例，获得一个文件描述符句柄，以及预分配返回的epoll_event指针数组的内存空间。Redis服务器的事件处理器会维护以下结构体作为事件处理状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeApiState &#123;</div><div class="line"></div><div class="line">    <span class="comment">// epoll_event 实例描述符</span></div><div class="line">    <span class="keyword">int</span> epfd;</div><div class="line"></div><div class="line">    <span class="comment">// 事件槽</span></div><div class="line">    <span class="keyword">struct</span> epoll_event *events;</div><div class="line"></div><div class="line">&#125; aeApiState;</div></pre></td></tr></table></figure>
<h5 id="注册事件监听"><a href="#注册事件监听" class="headerlink" title="注册事件监听"></a>注册事件监听</h5><p>　　首先会更新event loop结构体events数组里相应文件描述符的aeFileEvent结构体，记录注册的事件监听信息，包括客户端对象，事件类型和事件处理函数等。</p>
<p>　　对于select,会根据要监听的事件类型用FD_SET把文件描述符加到相应的fd_set中。</p>
<p>　　对于epoll，则会调用epoll_ctl注册事件监听。</p>
<h5 id="注销事件监听"><a href="#注销事件监听" class="headerlink" title="注销事件监听"></a>注销事件监听</h5><p>　　会修改event loop结构体events数组里相应文件描述符的相应事件的监听标志。</p>
<p>　　对于select,会用FD_CLR清空相应fd_set的文件描述符标志位。</p>
<p>　　对于epoll，会用epoll_ctl注销事件监听。</p>
<h5 id="等待文件事件"><a href="#等待文件事件" class="headerlink" title="等待文件事件"></a>等待文件事件</h5><p>　　对于select，会调用select函数阻塞，当有事件响应或超时时，遍历所有文件描述符，用FD_ISSET来判断当前检查的文件描述符是否属于select调用后的fd_set参数数组中，如果属于，则更新event loop结构体的fired文件事件指针数组。</p>
<p>　　对于epoll，会调用epoll_wait阻塞，当有事件响应或超时时，遍历所有已触发的文件描述符，并更新相应fired文件事件指针数组的元素。</p>
<p>　　上层调用只要检查fired数组，就可获得所有已触发的文件事件，不需要管下层io多路复用库是什么。</p>
<h4 id="时间事件与event-loop"><a href="#时间事件与event-loop" class="headerlink" title="时间事件与event loop"></a>时间事件与event loop</h4><p>　　Redis同样也有时间事件处理器，用一个无序链表来管理所有时间事件。Redis会在每个事件处理周期中，遍历这个链表，检查哪个时间事件到期。由于目前Redis只有一个时间事件处理器，因此无序链表不会影响服务器性能。Redis服务器在每个事件处理周期中，会寻找离当前时间最近的时间处理器，把到该时间事件的时间差作为超时时间，然后调用select或epoll_wait让进程休眠，直到有文件事件发生或超时。之后，Redis会遍历fired数组，按序处理文件事件。然后再遍历时间事件链表，处理已到时的时间事件。所有事件处理完毕后，进入下一个事件处理周期。</p>
<p>　　这样的event loop机制既不用频繁轮询文件事件，又不会让进程长期阻塞，优雅地管理了所有文件事件与时间事件。</p>
<p>　　由于Redis是单线程的，顺序执行事件，所以不能让单个事件阻塞服务器。每个socket连接都是非阻塞的，同时每个事件处理函数要尽快地结束，把事件让给下一个事件，如果还有数据没有读完或者写完都会留到下一个事件处理周期去完成。如果确实有可能长期阻塞服务器，则会在别的进程或线程中单独处理。</p>
<h4 id="关于poll"><a href="#关于poll" class="headerlink" title="关于poll"></a>关于poll</h4><p>　　Redis的event loop中没有使用poll作为底层的io多路复用库，但是在某些情况若对某个socket需要进行阻塞io时，会单独用poll来在给定时间内进行监听。</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis 浅析服务器与客户端的通信流程]]></title>
      <url>http://wjqwsp.github.io/2018/03/21/redis-%E6%B5%85%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　这段时间实验室工作较忙，很难静下心来写点东西。发现还是得把做的看的记录下来，抽时间总结一下。最近研究redis的源码，本文就先简要分析一下服务器与客户端的通信流程，这一块也算是redis的核心功能了。</p>
<a id="more"></a>
<h3 id="接收新的客户端连接"><a href="#接收新的客户端连接" class="headerlink" title="接收新的客户端连接"></a>接收新的客户端连接</h3><p>　　一切的通信都要从接收客户端的连接开始。redis把读客户端数据、写数据到客户端以及接收客户端的连接三种事件以IO多路复用的形式，在event loop中用单进程、单线程来处理。IO多路复用可以在一次IO阻塞中监听多个文件描述符。接收客户端连接在redis中作为读事件来处理，每个redis服务器进程在初始化时候都会绑定一个端口作为客户端连接的端口，并在该端口上绑定一个事件处理函数。如果在该端口中监听到有客户端的连接请求，则会运行该事件处理函数。</p>
<p>　　该端口可以维护一个等待队列，来缓存没有处理的连接请求，超过队列长度的会被拒绝。当redis进程监听到有新的连接请求，则连续处理最多1000个连接。每获得一个连接，会为该连接分配一个新的端口作为socket连接，redis进程就得到了该连接的一个独有的文件描述符。然后会为该描述符创建一个redisClient的结构体。redis在配置文件中定义最多的客户端连接数，超过该数目的客户端会被拒绝，redisClient结构体内存被释放，向客户端的文件符发送拒绝信息。由于此时客户端不一定可写，所以该拒绝信息不保证能成功发送，这是尽最大努力的尝试。</p>
<p>　　创建redisClient主要是初始化各种状态，例如输入缓冲区，输出缓冲区的内存分配，参数列表的初始化等等。对于网络通信来说，这一步最重要的就是为新分配的文件描述符绑定一个读事件，也作为IO多路复用监听的事件之一。那么如果客户端有数据到达，该文件描述符就会被唤醒，执行读数据的事件处理函数。</p>
<h3 id="读网络数据"><a href="#读网络数据" class="headerlink" title="读网络数据"></a>读网络数据</h3><p>　　如果有读事件到达，执行相应的事件处理函数。下面介绍一下redis通用的客户端读事件处理函数的逻辑。客户端向redis服务器发送的数据一般是redis命令。redis命令的格式是由严格的协议规定的，只有满足协议的命令才能得到正确解析，命令才会正确执行。而网络中数据到达的时间是不确定的，且传输层的输入缓冲区是有限的，命令参数可能非常长，例如可能客户端发了一个插入一条512MB的字符串数据到数据库中的命令，那么一次读是不一定能把命令解析完的，甚至不能把一个参数都读完整。</p>
<p>　　针对这种问题，redis的哲学是：尽可能地读所有数据，直到不能再读为止；尽可能解析命令，如果已经读出来的数据可以解析成一条完整的命令，那么执行该命令；如果不能构成完整的命令，那么尽可能地解析一个完整的参数，然后存到redisClient的参数数组中；如果不能解析一个完整的参数，那么尽可能获得将要解析的参数的信息，例如一共有多少参数，将要解析的参数要占多少内存，然后根据这些信息去优化输入缓冲区的空间来存放将要解析的参数，避免无谓的内存拷贝。</p>
<p>　　要满足上述要求，Redis必须为每个客户端设置一个输入缓冲区，缓存尚未能解析的命令；同时，已解析的参数可以在缓冲区中移除，加入每个客户端的参数数组中；客户端也要保存当前解析的命令的参数个数，以及当前正在解析的参数的长度。</p>
<p>　　Redis在执行读数据事件处理函数时，会保证输入缓冲区有16MB的空闲空间存放网络数据。如果有大量的数据作为参数到达服务器，Redis也不会瞬间让输入缓冲区空间暴涨，而是以16MB为单位地增加，避免短时间内消耗大量内存，使得服务器来不及释放空间。同时一次读太多数据也会导致服务器阻塞，由于Redis采用单进程单线程IO多路复用模型，应该避免IO阻塞。输入缓冲区最多1GB，超过则客户端会被马上释放。</p>
<p>　　每次接到读数据事件，都会更新客户端的最后互动时间，更新输入缓冲区的峰值，设置服务器的当前客户端为该客户端。在函数执行结束后，把当前客户端设为空。</p>
<p>　　Redis客户端发来的命令的格式是非常固定的。命令的开始会有一个整数代表参数个数，后面跟着每个参数的长度以及参数数据。参数个数，参数长度，参数数据都以\r\n划分。因此，Redis会检测字符串的\r\n，用来解析参数。在解析的过程中如果发现格式不满足协议要求，则马上停止解析，向客户端写错误信息到输出缓冲区，并设置客户端为输出缓冲区清空后就马上释放。</p>
<p>　　Redis对于非常长的参数（大于32KB），有特殊的优化方法。如果将要解析的参数的长度已经获取，那么在读数据到输入缓冲区时则不是16MB为单位读取了，而是只要该数据比16MB小，则只会读数据到刚好能解析该参数；如果比16MB大，则还是以16MB为单位读取，在读最后一小块时候还是能让输入缓冲区只存放该参数。为什么要让输入缓冲区只有该参数呢？这样就可以直接用输入缓冲区构造Redis对象加入参数数组内，而不用进行大量的内存复制，既耗时，又浪费内存。</p>
<p>　　当命令完全解析之后，Redis就会根据参数数组（第一个参数为命令名字）查找命令表，并用相应的参数执行相应的函数了。</p>
<h3 id="写网络数据"><a href="#写网络数据" class="headerlink" title="写网络数据"></a>写网络数据</h3><p>　　不同于读事件，如果总是把客户端的文件描述符绑定写事件监听的话，那么会频繁地提示可写，因此只会在真的写数据到输出缓冲区之后，才绑定事件处理器，且在事件处理函数执行完后，要手动解除绑定。写数据一般发生在执行命令的时候，命令函数会把一些数据写到输出缓冲区中，然后要绑定写事件。</p>
<p>　　Redis的输出缓冲区有两个，一个是定长数组，是预分配的空间，一般是16KB。当该缓冲区没写满，且新数据能全部放进该区域时，优先写到该定长缓冲区，可以避免内存分配。一个是变长缓冲区，用列表实现，列表元素是Redis对象，且编码都是sds。之所以用Redis对象构成输出缓冲区，是可以充分利用对象的共享性。对象的共享性包括一些高频率使用的对象Redis把它们做成全局唯一的全局共享对象，还有一些数据库里保存的数据，在输出到网络时直接把数据库里的Redis对象引用计数加1即可，避免无谓的内存复制，既费时，又耗内存。</p>
<p>　　当列表末尾的Redis对象元素的sds长度不满16KB时，新写到缓冲区的数据优先拼接到列表的最后一个元素。这是因为每次写数据到网络都是以一个列表元素为单位写的，所以要控制好每次写的长度，避免过长产生阻塞，也避免过短，影响IO效率。而且每写完一个列表元素，就会把相应的内存释放掉，这个长度也是控制内存释放的速率。</p>
<p>　　在把数据推到变长缓冲区时，还会累加缓冲区的内存，当然这个内存只是估计值，因为有很大一部分可能都是共享对象。每次把数据写到变长缓冲区之后，都要判断一下当前输出缓冲区的大小是否超过限制，这个限制分为硬限制和软限制，超过硬限制或者在一段时间内仍然超过软限制，则会把客户端加入异步销毁列表，在服务器处理定时任务时候异步销毁掉客户端。</p>
<p>　　Redis写缓冲区也是尽力写，但有可能socket的输出缓冲区满了使得不一定把当前要写的数据都写完，而Redis的读写都是非阻塞的，就要记录当前写的数据的位置，下次接着写。</p>
<p>　　Redis同样会避免一个客户端写大量的数据阻塞主线程，因此一次事件处理一般只能写64KB的数据，然后把CPU时间让给别的事件。但如果此时Redis的内存占用超过上限，则希望把客户端的输出缓冲区尽快清空，以回收内存。</p>
<p>　　如果客户端设置了清空输出缓冲区马上释放，则释放客户端。</p>
<h3 id="释放客户端"><a href="#释放客户端" class="headerlink" title="释放客户端"></a>释放客户端</h3><p>　　对于普通客户端，释放客户端主要是把客户端的输入缓冲区、输出缓冲区、参数数组以及把redisClient结构体本身所分配的内存全部归还给操作系统。对于本文所涉及的网络通信而言，在输入缓冲区或输出缓冲区超出限制的情况下，或是协议解析错误的情况下，会释放客户端，保证Redis服务器不会有大量的内存被客户端占据，影响正常业务。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[xv6 bootstrap部分源代码分析]]></title>
      <url>http://wjqwsp.github.io/2017/06/06/xv6-bootstrap%E9%83%A8%E5%88%86%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　xv6是x86处理器上用ANSI标准C重新实现的Unix第六版(Unix V6，通常直接被称为V6)，本文主要对xv6的bootstrap实现部分的源代码进行分析，分析一下机器开机之后，从BIOS引导boot loader，boot loader从磁盘加载内核到内存，到执行内核程序的全过程。<br><a id="more"></a></p>
<h3 id="计算机内存布局"><a href="#计算机内存布局" class="headerlink" title="计算机内存布局"></a>计算机内存布局</h3><p>　　在涉及源代码前，先介绍一下计算机内存布局：</p>
<p><img src="/img/memory-layout.png" alt="memory laytou"></p>
<p>　　在早期的x86计算机里，用的是16位的Intel 8088处理器，寻址空间只有1MB，也就是图中所示0x00000000到0x000FFFFF的地址空间。其中还有一部分空间是系统保留的，其中最主要的就是BIOS ROM。而用户能用到的内存空间主要就是0x00000000到0x000A0000这个640KB段。</p>
<p>　　现代计算机内存空间远远不止1M，而CPU字长也从16位发展到32位，64位。本文介绍的xv6操作系统，就是32位操作系统，运行在32位处理器上。32位处理器寻址空间可到4GB，这部分地址超出1MB的地址，就是图中的Extended Memory。</p>
<p>　　但所有的x86计算机都保持了向下兼容的特性，因此在刚开机的时候，CPU是模仿Intel 8088的工作模式工作的，最大寻址空间只有1M。xv6就需要在boot loader里把原始工作模式进行升级，使得寻址能力达到4GB。</p>
<h3 id="BIOS引导"><a href="#BIOS引导" class="headerlink" title="BIOS引导"></a>BIOS引导</h3><p>　　在计算机刚开机时候，内存除了BIOS ROM里的程序外没有任何程序。因此最开始必须由BIOS进行引导。当我们按下开机键，CPU执行的第一条指令位于内存F000:FFF0位置。此时CPU工作于实时模式，该模式会通过段寄存器CS与指令寄存器IP共同寻找指令所在的物理地址。计算方法是CS里的内容左移4位再加上IP里的内容，得到实际物理地址，这里BIOS第一条指令的物理地址是0xffff0。与上面的内存布局图对照，这个位置正是BIOS ROM区域的顶部。</p>
<p>　　这条指令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ljmp   $0xf000,$0xe05b</div></pre></td></tr></table></figure>
<p>　　跳转到物理地址0xfe05b位置，执行后续的指令。这个也比较好理解，因为0xffff0比较接近0xfffff这个物理内存地址的最顶端，这么少的内存空间做不了什么事，这时候就转移一下代码的所在位置。然后，BIOS会进行一系列的硬件初始化工作。当这些工作都完成了，计算机的硬件都处在一个基础的就绪状态，就可以进行操作系统的引导了。xv6作为一个精简的unix操作系统，其boot loader在可启动磁盘上的第一个扇区，即第一个512字节的区域。BIOS会把这段代码拷贝到物理地址0x7c00到0x7dff的内存空间中。这段代码就叫做boot loader，主要用于引导操作系统内核。</p>
<h3 id="boot-loader"><a href="#boot-loader" class="headerlink" title="boot loader"></a>boot loader</h3><p>　　BIOS设置cs寄存器为0x0，ip寄存器为0x7c00，开始执行boot loader程序。该程序可分为两部分，第一部分是汇编语言编写的，源代码在<a href="https://github.com/wjqwsp/xv6-public/blob/master/bootasm.S。第二部分是c语言编写的，源代码在https://github.com/wjqwsp/xv6-public/blob/master/bootmain.c。" target="_blank" rel="external">https://github.com/wjqwsp/xv6-public/blob/master/bootasm.S。第二部分是c语言编写的，源代码在https://github.com/wjqwsp/xv6-public/blob/master/bootmain.c。</a></p>
<h4 id="bootasm-S"><a href="#bootasm-S" class="headerlink" title="bootasm.S"></a>bootasm.S</h4><p>　　在引导内核之前，boot loader必须对CPU进行一些必要的设置，这部分代码就是完成这些初始化的工作，为后续c程序接管作准备。</p>
<h5 id="基本初始化"><a href="#基本初始化" class="headerlink" title="基本初始化"></a>基本初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.code16                       # Assemble for 16-bit mode</div><div class="line">.globl start</div><div class="line">start:</div><div class="line">  cli                         # BIOS enabled interrupts; disable</div><div class="line"></div><div class="line">  # Zero data segment registers DS, ES, and SS.</div><div class="line">  xorw    %ax,%ax             # Set %ax to zero</div><div class="line">  movw    %ax,%ds             # -&gt; Data Segment</div><div class="line">  movw    %ax,%es             # -&gt; Extra Segment</div><div class="line">  movw    %ax,%ss             # -&gt; Stack Segment</div></pre></td></tr></table></figure>
<p>　　这是boot loader最开始的代码。首先禁用中断响应。在BIOS执行时，是开启了中断的，这里必须把中断禁用，以防引导过程被干扰。</p>
<p>　　然后把ax,ds,es,ss寄存器都清零，作为初始化。</p>
<h5 id="打开A20-Gate"><a href="#打开A20-Gate" class="headerlink" title="打开A20 Gate"></a>打开A20 Gate</h5><p>　　在段寄存器加偏移量的内存地址计算方式里，最多可以用到21位的地址，但在实时模式下CPU只支持20位的地址寻址。那么多出来的一位是通过地址卷绕机制忽略的，简单来说就是忽略第21位地址，例如物理地址0x10ffef会被当做0x0ffef。</p>
<p>　　在实时模式下，每个地址段的只能用16位偏移量表示，只有64KB大小，这样如果执行大型程序的话则很不方便，往往需要跨多个地址段。而且寻址空间是在太小，完全不能满足现代计算机的需要。因此，现代的CPU还提供了一种保护模式，能够大幅度提升寻址空间，并且用32位来表示物理地址。</p>
<p>　　要开启保护模式，首先要禁用地址卷绕，也就是开启编号为20的地址线，即第21位地址。xv6采用的方法是键盘控制器法，通过输出命令到键盘控制器的IO接口，控制A20的开启与关闭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">seta20.1:</div><div class="line">  inb     $0x64,%al               # Wait for not busy</div><div class="line">  testb   $0x2,%al</div><div class="line">  jnz     seta20.1</div><div class="line"></div><div class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</div><div class="line">  outb    %al,$0x64</div><div class="line"></div><div class="line">seta20.2:</div><div class="line">  inb     $0x64,%al               # Wait for not busy</div><div class="line">  testb   $0x2,%al</div><div class="line">  jnz     seta20.2</div><div class="line"></div><div class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</div><div class="line">  outb    %al,$0x60</div></pre></td></tr></table></figure>
<p>　　与键盘控制器有关的IO接口是0x60和0x64。其中0x64起到一个状态控制的功能，0x60则是数据端口。首先需要检查键盘控制器是否忙碌，例如是否正有键盘输入等等。这个状态检查是通过读取0x64实现的。通过检查该状态数据的低第二个比特位是否为高，来判断是否忙碌。等到该比特位为低，就可以向0x64写命令了。</p>
<p>　　向0x64写入命令0xd1，该命令用于指示即将向键盘控制器的输出端口写一个字节的数据。</p>
<p>　　再检查0x64，判断键盘控制器是否忙碌。等不忙碌后，就可以向0x60写入数据0xdf。该数据代表开启A20。</p>
<h5 id="GDT的设置"><a href="#GDT的设置" class="headerlink" title="GDT的设置"></a>GDT的设置</h5><p>　　前面说到，在实时模式下，每个地址段只有64KB。而保护模式则采用了段模式进行内存管理。该模式会通过一个全局的段描述符表（GDT）来进行内存分段。这里的段不再有64KB的限制，而可以指定更大的段。该段描述符表的每一项叫做段描述符，每项占8个字节。在保护模式下，物理地址的计算不再采用段寄存器加偏移量的方式，而用段寄存器来存储段描述符的索引，通过该索引找到段描述符，再通过段描述符找到物理地址段。下面先给出段描述符的结构，该结构参考自<a href="http://example.com/" title="leenjewel Blog里的【学习xv6】从实模式到保护模式" target="_blank" rel="external">leenjewel Blog里的【学习xv6】从实模式到保护模式</a></p>
<p><img src="/img/gdt-item.png" alt="gdt item"></p>
<p>　　3块基地址组合起来刚好是32位地址，两块limit段共20个比特，代表该内存段的长度。剩余其他比特位都是一些属性信息。</p>
<ul>
<li>P:       0 本段不在内存中</li>
<li>DPL:     访问该段内存所需权限等级 00 — 11，0为最大权限级别</li>
<li>S:       1 代表数据段、代码段或堆栈段，0 代表系统段如中断门或调用门</li>
<li>E:       1 代表代码段，可执行标记，0 代表数据段</li>
<li>ED:      0 代表忽略特权级，1 代表遵守特权级</li>
<li>RW:      如果是数据段（E=0）则1 代表可写入，0 代表只读；如果是代码段（E=1）则1 代表可读取，0 代表不可读取</li>
<li>A:       1 表示该段内存访问过，0 表示没有被访问过</li>
<li>G:       1 表示 20 位段界限单位是 4KB，最大长度 4GB；0 表示 20 位段界限单位是 1 字节，最大长度 1MB</li>
<li>DB:      1 表示地址和操作数是 32 位，0 表示地址和操作数是 16 位</li>
<li>XX:      保留位永远是 0</li>
<li>AA:      给系统提供的保留位</li>
</ul>
<p>　　要启用保护模式，首先需要设置好GDT，下面看一下xv6的bootloader如何设置GDT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Bootstrap GDT</div><div class="line">.p2align 2                                # force 4 byte alignment</div><div class="line">gdt:</div><div class="line">  SEG_NULLASM                             # null seg</div><div class="line">  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg</div><div class="line">  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg</div><div class="line"></div><div class="line">gdtdesc:</div><div class="line">  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1</div><div class="line">  .long   gdt                             # address gdt</div></pre></td></tr></table></figure>
<p>　　这里的gdt标号就是GDT的地址。现在把宏全部翻译过来，看看xv6的GDT是怎么样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gdt:</div><div class="line">  .word 0, 0;</div><div class="line">  .byte 0, 0, 0, 0                             # 空</div><div class="line">  .word 0xffff, 0x0000;</div><div class="line">  .byte 0x00, 0x9a, 0xcf, 0x00                 # 代码段</div><div class="line">  .word 0xffff, 0x0000;</div><div class="line">  .byte 0x00, 0x92, 0xcf, 0x00                 # 数据段</div></pre></td></tr></table></figure>
<p>　　先定义了一个空的段描述符，64位全0。</p>
<p>　　然后定义代码段。下面看看代码段的结构：</p>
<p><img src="/img/code-seg.png" alt="code segment"></p>
<p>　　DB=1表示地址和操作数都是32位，通过这项正式启用32位模式。G=1表示段界限单位是4KB，由于界限是0xfffff，则代码段的总长度为4KB*2^20=4GB，说明该代码段的寻址空间是4GB。DPL代表该段内存权限最高，相当于root。这是因为xv6是一款精简的操作系统，并没有高级的用户功能，因此这里不作特别设置。S=1与E=1代表是代码段。RW=1说明该代码段可读取。基地址是0x00000000，说明该段的物理地址范围是0~4GB。</p>
<p>　　数据段的定义也是类似，下面是数据段的结构：</p>
<p><img src="/img/data-seg.png" alt="data segment"></p>
<p>　　这里与代码段不同的就是E=0，代表数据段。RW=1虽然与代码段相同，但表示的意义不同，对于数据段表示可读可写。</p>
<p>　　不难发现，代码段与数据段的寻址空间都是0~4GB。其实这里的段模式只是走个形式，并没有真正采用该模式来进行内存管理，而是简单地进行全部内存寻址。xv6实际上是用分页模式来管理内存的，这在后面会看到。</p>
<h5 id="开启保护模式"><a href="#开启保护模式" class="headerlink" title="开启保护模式"></a>开启保护模式</h5><p>　　GDT设置好以后，需要加载。CPU单独准备了一个寄存器GDTR来保存GDT在内存中的位置和我们GDT的长度，它共有48位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lgdt    gdtdesc</div><div class="line">movl    %cr0, %eax</div><div class="line">orl     $CR0_PE, %eax</div><div class="line">movl    %eax, %cr0</div></pre></td></tr></table></figure>
<p>　　lgdt指令会把gdtdesc地址的48比特内容加载到GDTR寄存器里。其中低16位用来存储GDT有多少个段描述符信息，单位是字节。16位可以表示65536个数，而每个段描述符需要8个字节，所以最多可以有8192个段描述符。高32位就是GDT的物理地址。</p>
<p>　　要开启保护模式，需要打开一个开关。该开关用cr0寄存器的最低位表示，该寄存器为1代表开启保护模式。</p>
<p>　　单纯启用保护模式，处理器仍然不能马上利用保护模式进行寻址。只有当cs段寄存器的值被更新以后，才会读取GDT表来进行逻辑地址到物理地址的映射。xv6采用以下方式更新cs段寄存器的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ljmp    $(SEG_KCODE&lt;&lt;3), $start32</div></pre></td></tr></table></figure>
<p>　　SEG_KCODE这个宏是1，该语句会把cs寄存器的值设为0x08。前面说到，最多可以有8192个段描述符，而16位的寄存器只需要用高13位即可表示8192个数。所以这里的索引是1，代表标号为1的内存段，这正是代码段。这时候会执行start32地址里的代码，正式开启32位模式与保护模式。</p>
<h5 id="引导内核前的最后准备"><a href="#引导内核前的最后准备" class="headerlink" title="引导内核前的最后准备"></a>引导内核前的最后准备</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">start32:</div><div class="line">  # Set up the protected-mode data segment registers</div><div class="line">  movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector</div><div class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</div><div class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</div><div class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</div><div class="line">  movw    $0, %ax                 # Zero segments not ready for use</div><div class="line">  movw    %ax, %fs                # -&gt; FS</div><div class="line">  movw    %ax, %gs                # -&gt; GS</div><div class="line"></div><div class="line">  # Set up the stack pointer and call into C.</div><div class="line">  movl    $start, %esp</div><div class="line">  call    bootmain</div><div class="line"></div><div class="line">  # If bootmain returns (it shouldn&apos;t), trigger a Bochs</div><div class="line">  # breakpoint if running under Bochs, then loop.</div><div class="line">  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00</div><div class="line">  movw    %ax, %dx</div><div class="line">  outw    %ax, %dx</div><div class="line">  movw    $0x8ae0, %ax            # 0x8ae0 -&gt; port 0x8a00</div><div class="line">  outw    %ax, %dx</div><div class="line">spin:</div><div class="line">  jmp     spin</div></pre></td></tr></table></figure>
<p>　　把数据段的索引写入ds,es,ss寄存器。把ax,fs,gs寄存器清零。将start代表的地址写入堆栈的偏移寄存器，代表堆栈指针。start是boot loader的第一条指令所在内存位置，即物理地址0x7c00，而堆栈是向下生长的，就不会与boot loader所在内存产生重叠。然后就可以调用bootmain函数，正式进入c程序阶段。</p>
<p>　　bootmain一般是不返回的，除非出现错误。这时候就可以在bootmain.S里编写一些错误处理或者日志汇报的代码。xv6并没有做多少这方面的工作，在向0x8a00这个IO接口写某些数据之后，主要就是进入一个死循环。</p>
<h4 id="bootmain-c"><a href="#bootmain-c" class="headerlink" title="bootmain.c"></a>bootmain.c</h4><p>　　这部分c代码的主要作用是加载内核文件到内存中。</p>
<h5 id="加载ELF头部与程序头表"><a href="#加载ELF头部与程序头表" class="headerlink" title="加载ELF头部与程序头表"></a>加载ELF头部与程序头表</h5><p>　　kernel是一个ELF格式的可执行文件，它遵守标准的ELF格式。我们暂时关心的就是ELF头部与程序头表，通过把它们从磁盘里加载到内存中，就可以让内核正式接管计算机了！</p>
<p>　　kernel文件的ELF头部从启动磁盘的第二个扇区开始。前面已经说到，第一个扇区512字节就是boot loader。ELF头部与程序头表大小是4KB。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">bootmain(void)</div><div class="line">&#123;</div><div class="line">  struct elfhdr *elf;</div><div class="line">  struct proghdr *ph, *eph;</div><div class="line">  void (*entry)(void);</div><div class="line">  uchar* pa;</div><div class="line"></div><div class="line">  elf = (struct elfhdr*)0x10000;  // scratch space</div><div class="line"></div><div class="line">  // Read 1st page off disk</div><div class="line">  readseg((uchar*)elf, 4096, 0);</div><div class="line"></div><div class="line">  // Is this an ELF executable?</div><div class="line">  if(elf-&gt;magic != ELF_MAGIC)</div><div class="line">    return;  // let bootasm.S handle error</div><div class="line"></div><div class="line">  // Load each program segment (ignores ph flags).</div><div class="line">  ph = (struct proghdr*)((uchar*)elf + elf-&gt;phoff);</div><div class="line">  eph = ph + elf-&gt;phnum;</div><div class="line">  for(; ph &lt; eph; ph++)&#123;</div><div class="line">    pa = (uchar*)ph-&gt;paddr;</div><div class="line">    readseg(pa, ph-&gt;filesz, ph-&gt;off);</div><div class="line">    if(ph-&gt;memsz &gt; ph-&gt;filesz)</div><div class="line">      stosb(pa + ph-&gt;filesz, 0, ph-&gt;memsz - ph-&gt;filesz);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Call the entry point from the ELF header.</div><div class="line">  // Does not return!</div><div class="line">  entry = (void(*)(void))(elf-&gt;entry);</div><div class="line">  entry();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　xv6把内核文件加载到物理内存0x10000开始的位置，也就是本文第一张图里的Extended memory部分，正好与low memory里的boot loader和堆栈区错开。bootmain函数首先加载ELF头部，从磁盘里加载ELF头部主要就是用的readseg()这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">readseg(uchar* pa, uint count, uint offset)</div><div class="line">&#123;</div><div class="line">  uchar* epa;</div><div class="line"></div><div class="line">  epa = pa + count;</div><div class="line"></div><div class="line">  // Round down to sector boundary.</div><div class="line">  pa -= offset % SECTSIZE;</div><div class="line"></div><div class="line">  // Translate from bytes to sectors; kernel starts at sector 1.</div><div class="line">  offset = (offset / SECTSIZE) + 1;</div><div class="line"></div><div class="line">  // If this is too slow, we could read lots of sectors at a time.</div><div class="line">  // We&apos;d write more to memory than asked, but it doesn&apos;t matter --</div><div class="line">  // we load in increasing order.</div><div class="line">  for(; pa &lt; epa; pa += SECTSIZE, offset++)</div><div class="line">    readsect(pa, offset);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这个函数的功能是从磁盘里某个扇区开始，把数据加载到内存的pa位置。从代码可以看出，是一个扇区一个扇区地按顺序读数据的。首先要保证pa在完整扇区的头部，如果不是，则通过对扇区头部的偏移量来计算出完整扇区头部的地址。这里读ELF头部时，是从磁盘第一个扇区的头部开始的，读4096字节。读某个扇区的数据由readsect()函数完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">readsect(void *dst, uint offset)</div><div class="line">&#123;</div><div class="line">  // Issue command.</div><div class="line">  waitdisk();</div><div class="line">  outb(0x1F2, 1);   // count = 1</div><div class="line">  outb(0x1F3, offset);</div><div class="line">  outb(0x1F4, offset &gt;&gt; 8);</div><div class="line">  outb(0x1F5, offset &gt;&gt; 16);</div><div class="line">  outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);</div><div class="line">  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors</div><div class="line"></div><div class="line">  // Read data.</div><div class="line">  waitdisk();</div><div class="line">  insl(0x1F0, dst, SECTSIZE/4);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　xv6作为精简的Unix操作系统，只针对IDE接口的磁盘读写，默认启动磁盘就是采用IDE接口的。要阐述从磁盘读数据的方法，先给出IDE的IO接口对应的寄存器参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">1F0        - 数据寄存器。读写数据都必须通过这个寄存器</div><div class="line"></div><div class="line">1F1        - 错误寄存器，每一位代表一类错误。全零表示操作成功。</div><div class="line"></div><div class="line">1F2        - 扇区计数。这里面存放你要操作的扇区数量</div><div class="line"></div><div class="line">1F3        - 扇区LBA地址的0-7位</div><div class="line"></div><div class="line">1F4        - 扇区LBA地址的8-15位</div><div class="line"></div><div class="line">1F5        - 扇区LBA地址的16-23位</div><div class="line"></div><div class="line">1F6 (低4位) - 扇区LBA地址的24-27位</div><div class="line"></div><div class="line">1F6 (第4位) - 0表示选择主盘，1表示选择从盘</div><div class="line"></div><div class="line">1F6 (5-7位) - 必须为1</div><div class="line"></div><div class="line">1F7 (写)    - 命令寄存器</div><div class="line"></div><div class="line">1F7 (读)    - 状态寄存器</div><div class="line"></div><div class="line">              bit 7 = 1  控制器忙</div><div class="line">              bit 6 = 1  驱动器就绪</div><div class="line">              bit 5 = 1  设备错误</div><div class="line">              bit 4        N/A</div><div class="line">              bit 3 = 1  扇区缓冲区错误</div><div class="line">              bit 2 = 1  磁盘已被读校验</div><div class="line">              bit 1        N/A</div><div class="line">              bit 0 = 1  上一次命令执行失败</div></pre></td></tr></table></figure>
<p>　　在读取扇区数据之前，先用waitdisk()函数检查磁盘是否准备好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">waitdisk(void)</div><div class="line">&#123;</div><div class="line">  // Wait for disk ready.</div><div class="line">  while((inb(0x1F7) &amp; 0xC0) != 0x40)</div><div class="line">    ;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline uchar</div><div class="line">inb(ushort port)</div><div class="line">&#123;</div><div class="line">  uchar data;</div><div class="line"></div><div class="line">  asm volatile(&quot;in %1,%0&quot; : &quot;=a&quot; (data) : &quot;d&quot; (port));</div><div class="line">  return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这里在c语言里调用了汇编命令来进行磁盘读写。读取IO接口0x1F7，检查IDE磁盘的状态寄存器高两位。如果最高为为0，高二位为1，说明磁盘准备好，可以读数据了。</p>
<p>　　磁盘就绪后，用LBA寻址方式来寻找扇区，offset变量就是表示第几个扇区，从第一个扇区开始，拷贝4KB数据到内存，一个一个扇区地拷贝。需要先向接口0x1F2,0x1F3,0x1F4,0x1F5,0x1F6写入扇区编号。然后向0x1F7写入命令0x20，代表读扇区。</p>
<p>　　等待磁盘再次准备好后，就可以用insl()函数读取扇区数据了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static inline void</div><div class="line">insl(int port, void *addr, int cnt)</div><div class="line">&#123;</div><div class="line">  asm volatile(&quot;cld; rep insl&quot; :</div><div class="line">               &quot;=D&quot; (addr), &quot;=c&quot; (cnt) :</div><div class="line">               &quot;d&quot; (port), &quot;0&quot; (addr), &quot;1&quot; (cnt) :</div><div class="line">               &quot;memory&quot;, &quot;cc&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这段代码仍然是调用了汇编命令，做了以下几件事：</p>
<ol>
<li>把DF寄存器清零。</li>
<li>把循环次数写进cx计数寄存器中。</li>
<li>循环执行insl指令，把IO接口0x1F0的数据读取并写到对应的内存区域上，每次读取4个字节。</li>
<li>每次循环会让cx计数寄存器的值减1，并更新DI寄存器的值，让它加4。</li>
<li>这样，在循环结束时候，刚好读取完1个扇区的所有数据。</li>
</ol>
<p>　　读取完ELF头部后，检查magic字段，看是否真的是一个ELF文件。</p>
<h5 id="加载内核程序"><a href="#加载内核程序" class="headerlink" title="加载内核程序"></a>加载内核程序</h5><p>　　ELF头部与程序头表加载到内存以后，下一步就是加载内核程序了。这里再引用一下bootmain()函数的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">bootmain(void)</div><div class="line">&#123;</div><div class="line">  struct elfhdr *elf;</div><div class="line">  struct proghdr *ph, *eph;</div><div class="line">  void (*entry)(void);</div><div class="line">  uchar* pa;</div><div class="line"></div><div class="line">  elf = (struct elfhdr*)0x10000;  // scratch space</div><div class="line"></div><div class="line">  // Read 1st page off disk</div><div class="line">  readseg((uchar*)elf, 4096, 0);</div><div class="line"></div><div class="line">  // Is this an ELF executable?</div><div class="line">  if(elf-&gt;magic != ELF_MAGIC)</div><div class="line">    return;  // let bootasm.S handle error</div><div class="line"></div><div class="line">  // Load each program segment (ignores ph flags).</div><div class="line">  ph = (struct proghdr*)((uchar*)elf + elf-&gt;phoff);</div><div class="line">  eph = ph + elf-&gt;phnum;</div><div class="line">  for(; ph &lt; eph; ph++)&#123;</div><div class="line">    pa = (uchar*)ph-&gt;paddr;</div><div class="line">    readseg(pa, ph-&gt;filesz, ph-&gt;off);</div><div class="line">    if(ph-&gt;memsz &gt; ph-&gt;filesz)</div><div class="line">      stosb(pa + ph-&gt;filesz, 0, ph-&gt;memsz - ph-&gt;filesz);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Call the entry point from the ELF header.</div><div class="line">  // Does not return!</div><div class="line">  entry = (void(*)(void))(elf-&gt;entry);</div><div class="line">  entry();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　利用ELF头部的phoff字段，找出程序头表的内存地址。然后用ELF头部的phnum字段找出一共有多少个程序入口。循环每个程序入口，用程序头表的paddr参数找出相应内核程序的位置。然后还是用readseg()函数把磁盘里的程序加载到内存中。filesz字段代表程序在文件中的长度，off代表程序在文件中的偏移量，可以通过该偏移量计算出程序在哪个扇区。</p>
<p>　　memsz字段代表程序在内存中的长度，如果在内存中长度比在文件中长，则要用stosb()函数在后面补0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static inline void</div><div class="line">stosb(void *addr, int data, int cnt)</div><div class="line">&#123;</div><div class="line">  asm volatile(&quot;cld; rep stosb&quot; :</div><div class="line">               &quot;=D&quot; (addr), &quot;=c&quot; (cnt) :</div><div class="line">               &quot;0&quot; (addr), &quot;1&quot; (cnt), &quot;a&quot; (data) :</div><div class="line">               &quot;memory&quot;, &quot;cc&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这个函数的循环逻辑类似insl()函数，循环地向内存中程序段后面填0，直到程序段大小与memsz一致。</p>
<p>　　在这些都加载完成后，就可以执行内核入口程序了！入口程序的物理地址记录在elf头部中。之后，就是内核接管计算机的时代了！bootstrap引导操作正式完成！</p>
<p>　　</p>
<p>　　
　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[xv6 shell实现源代码分析]]></title>
      <url>http://wjqwsp.github.io/2017/06/04/xv6-shell%E5%AE%9E%E7%8E%B0%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　xv6是x86处理器上用ANSI标准C重新实现的Unix第六版(Unix V6，通常直接被称为V6)，本文主要对xv6的shell实现部分的源代码进行分析，同时引申一些操作系统系统调用的内容，包括管道，重定向，进程等等基本概念。通过阅读这部分的源代码，也可以对现代操作系统的shell这个用户程序的核心实现有一个基本的认识。<br><a id="more"></a></p>
<h3 id="源代码获得"><a href="#源代码获得" class="headerlink" title="源代码获得"></a>源代码获得</h3><p>　　<a href="https://github.com/mit-pdos/xv6-public/blob/master/sh.c" target="_blank" rel="external">https://github.com/mit-pdos/xv6-public/blob/master/sh.c</a> 从github上可以获得xv6的源代码，非常精简，不到10000行，其中sh.c文件里就是shell实现的源代码。</p>
<h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><p>　　整体逻辑很清晰，主要就是三部分。入口程序首先做一些预处理，包括命令字符串的过滤和一些系统初始条件的验证。然后对命令字符串进行词法分析，根据命令的类型构造起一个链式的基本命令执行串，其实就是一个链式的自定义结构体。最后是命令的执行阶段，根据构造起的链式结构体串，递归地执行所有基本命令。</p>
<p><img src="/img/shell代码架构.png" alt="shell system structure"></p>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>　　预处理阶段就在入口函数里处理，逻辑比较简单，主要就是做两件事，一是验证标准输入，标准输出，标准错误是否正常开启；二是对cd命令单独处理。</p>
<h4 id="验证标准输入、标准输出及标准错误正常开启"><a href="#验证标准输入、标准输出及标准错误正常开启" class="headerlink" title="验证标准输入、标准输出及标准错误正常开启"></a>验证标准输入、标准输出及标准错误正常开启</h4><p>　　xv6是用文件描述符来抽象所有的文件、设备、管道等等概念，让它们全都以输入输出流的形式来与用户程序打交道，而掩盖了底层所有与硬件相关的操作。用户程序只需要对相应的文件描述符进行读写操作就行。每个进程都维护一个文件描述表，包含了所有已经打开的文件描述符。默认会开启0，1，2三个描述符，0代表标准输入，1代表标准输出，2代表标准错误。标准输出与标准错误都是输出到屏幕上。因此，shell启动之后第一件事就是验证这三个文件描述符是否正常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>((fd = open(<span class="string">"console"</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</div><div class="line">  <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;</div><div class="line">    close(fd);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>open()打开console文件。</li>
<li>如果标准输入、标准输出、标准错误都正常工作，那么新的文件描述符肯定大于3，从而得出判断。</li>
<li>关闭console文件</li>
</ol>
<p>　　利用xv6内核提供给用户的接口–系统调用，来实现打开与关闭某个文件的操作。以上open()和close()就是相应系统调用，除此之外还有一些其他的系统调用，用来处理各种与硬件相关的动作，后面还会介绍其他一些系统调用。xv6的系统调用都是精心设计的接口，也是现代unix系列操作系统的核心系统调用。用户程序会一直在用户空间与内核空间切换。</p>
<p><img src="/img/kernel-user-space.png" alt="kernel&amp;user space"></p>
<p>　　操作系统通过系统调用来连接用户空间与内核空间，从而让不同的用户程序能够共享硬件资源，并对硬件资源作保护，不直接暴露给用户。shell就是这么一个用户程序。</p>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>　　shell中的其他命令都是实现好的用户程序，shell只起到一个转发用户命令，调用实际用户程序这么一个功能，例如cat,rm,cp等等命令。而cd命令必须shell本身实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</div><div class="line">   <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">'c'</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">'d'</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">' '</span>)&#123;</div><div class="line">     <span class="comment">// Chdir must be called by the parent, not the child.</span></div><div class="line">     buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></div><div class="line">     <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</div><div class="line">       <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">"cannot cd %s\n"</span>, buf+<span class="number">3</span>);</div><div class="line">     <span class="keyword">continue</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</div><div class="line">     runcmd(parsecmd(buf));</div><div class="line">   wait();</div><div class="line"> &#125;</div><div class="line"> <span class="built_in">exit</span>();</div></pre></td></tr></table></figure>
<ol>
<li>shell进程读取标准输入到buf这个字符数组里。</li>
<li>判断输入的命令是不是cd。</li>
<li>如果是cd，则用系统调用chdir()切换当前进程的工作目录。</li>
<li>如果不是，则用系统调用fork()，派生一个子进程。</li>
<li>在子进程里进行命令构造与执行。</li>
<li>继续读取下一个标准输入的指令。</li>
</ol>
<p>　　fork()系统调用会复制父进程的所有内存空间，在该内存空间上创建一个新的进程。由于内存空间完全复制自父进程，那么代码段也自然是一样的，子进程也会执行相同的代码。fork()在父子进程里都会返回，在父进程返回的是子进程的pid；在子进程则返回0。</p>
<p>　　shell对每一次输入的命令都会派生一个子进程来执行，因此必须在父进程里先处理cd。因为每个进程的工作目录都不同，如果把cd放到子进程中，由外部用户程序来实现，那么只会修改子进程的工作目录，shell本身的工作目录还是得不到改变。</p>
<h3 id="命令构造器"><a href="#命令构造器" class="headerlink" title="命令构造器"></a>命令构造器</h3><p>　　从上面入口函数的代码段可以看到，命令构造实际上就是parsecmd这个函数，接收一个字符指针作为参数，该字符指针指向输入字符串的内存地址。先来看一下shell能够处理哪些命令类型。</p>
<h4 id="命令类型"><a href="#命令类型" class="headerlink" title="命令类型"></a>命令类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EXEC  1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIR 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE  3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST  4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BACK  5</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> cmd &#123;</div><div class="line">  <span class="keyword">int</span> type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> execcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;</div><div class="line">  <span class="keyword">char</span> *argv[MAXARGS];</div><div class="line">  <span class="keyword">char</span> *eargv[MAXARGS];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> redircmd &#123;</div><div class="line">  <span class="keyword">int</span> type;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line">  <span class="keyword">char</span> *file;</div><div class="line">  <span class="keyword">char</span> *efile;</div><div class="line">  <span class="keyword">int</span> mode;</div><div class="line">  <span class="keyword">int</span> fd;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> pipecmd &#123;</div><div class="line">  <span class="keyword">int</span> type;</div><div class="line">  <span class="keyword">struct</span> cmd *left;</div><div class="line">  <span class="keyword">struct</span> cmd *right;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> listcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;</div><div class="line">  <span class="keyword">struct</span> cmd *left;</div><div class="line">  <span class="keyword">struct</span> cmd *right;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> backcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>　　共有5种命令类型。</p>
<ol>
<li>execcmd，代表最基本的命令，包括命令名与参数，例如<code>cat y.sh</code>这样的命令。type类型取值范围就是最上面定义的5个宏。argv是参数列表，每个项都是一个字符指针，代表相应的字符串开始的内存位置。eargv的每个项也是一个字符指针，不过与argv相反，它代表的是每个字符串结束的内存位置，主要是作为字符串结束的标志。</li>
<li>redircmd，代表重定向命令。type的定义与execcmd相同。cmd是子命令，代表实际要执行的命令。file代表重定向的文件名在内存中的其实位置。efile代表文件名在内存中的结束位置。mode代表重定向文件打开的模式，包括只读、只写、读写等等。fd代表重定向要替换的文件描述符，可以取0或1，代表是输入重定向或者是输出重定向。</li>
<li>pipecmd，代表管道命令。它分成两部分，左命令是提供管道输入的命令，右命令是管道输出的命令。因此包含了两个cmd类型结构体。</li>
<li>listcmd，代表并列命令。可以把多个命令合成一个命令发送给shell，命令之间以;间隔，shell会分别执行。同样，也包含左右两个命令。例如echo hello; echo world这种形式的命令。</li>
<li>backcmd，代表后台命令。在命令的最后面加上&amp;，代表放到后台执行。也包含一个实际要执行的cmd命令。</li>
</ol>
<p>　　这里面有一个技巧，在命令构造的过程中，用到了递归的链式连接的形式构造命令。因为一个命令可能非常复杂，例如<code>ls &lt; y; ls | sort; who</code>这样的命令，这条命令就可以构造起如下这个链式的命令串：</p>
<p><img src="/img/cmd-seq.png" alt="cmd sequence"></p>
<p>　　为了统一接口，所有命令类型的子命令都采用了cmd类型，但实际可能是任何一种具体的命令类型。相当于在c语言里使用了类似面向对象的继承与多态的性质，所有的命令类型都继承自一个基础的结构体cmd。它们在实际命令执行的时候再根据type参数向下转型为真正的命令类型。这种技巧使代码变得非常简洁，命令的构造变得统一，构造命令时无需知道子命令是什么，便于递归构造命令串。</p>
<h4 id="命令构造流程"><a href="#命令构造流程" class="headerlink" title="命令构造流程"></a>命令构造流程</h4><p><img src="/img/cmd-construct.png" alt="cmd construct"></p>
<p>　　parsecmd()是命令构造函数，它简单地把工作转交给parseline()函数。</p>
<p>　　parseline顾名思义就是处理一行的输入字符串，把它转化成命令。这一行的概念有点抽象，实际上应该是可以视作一个命令整体的一行字符串，在这行字符串里可以包含各种命令，也就是<code>|&amp;&lt;&gt;();</code>这些字符都可以处理。所有需要处理全部类型字符的工作都可以交给parseline()完成。parseline()里还可以递归地调用parseline()。</p>
<p>　　parsepipe()用于处理管道命令，由于可能存在多个管道命令，因此parsepipe()可以递归调用自身。</p>
<p>　　parseblock()处理()内的命令，把()内的命令作为一个整体命令来处理，而忽略从左到右的执行优先级。</p>
<p>　　parseredirs()用于处理重定向命令，把子命令包裹成redircmd类型。</p>
<p>　　这些函数通过一连串的互相调用、递归调用，构建起链式的命令串。</p>
<h4 id="parsecmd"><a href="#parsecmd" class="headerlink" title="parsecmd()"></a>parsecmd()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">parsecmd(<span class="keyword">char</span> *s)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *es;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line"></div><div class="line">  es = s + <span class="built_in">strlen</span>(s);</div><div class="line">  cmd = parseline(&amp;s, es);</div><div class="line">  peek(&amp;s, es, <span class="string">""</span>);</div><div class="line">  <span class="keyword">if</span>(s != es)&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">"leftovers: %s\n"</span>, s);</div><div class="line">    panic(<span class="string">"syntax"</span>);</div><div class="line">  &#125;</div><div class="line">  nulterminate(cmd);</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　s就是输入的字符指针，es指向输入字符串的结尾位置。这里主要是把工作转交给parseline()，并在构造完成后判断是否到达输入字符串的末端，否则报错。这里的peek()函数的作用是检查输入字符串从头开始除空格外的第一个字符是否是给定的字符范围中的一个，返回true或者false，同时移动字符指针指向第一个非空格字符。multerminate()是构造命令的最后一步，在后面再介绍。</p>
<h4 id="parseline"><a href="#parseline" class="headerlink" title="parseline()"></a>parseline()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseline</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line"></div><div class="line">  cmd = parsepipe(ps, es);</div><div class="line">  <span class="keyword">while</span>(peek(ps, es, <span class="string">"&amp;"</span>))&#123;</div><div class="line">    gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cmd = backcmd(cmd);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(peek(ps, es, <span class="string">";"</span>))&#123;</div><div class="line">    gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cmd = listcmd(cmd, parseline(ps, es));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　先以管道为单位划分输入命令字符串，主要的工作都转交给parsepipe()完成。parsepipe()里可以处理<code>&lt;&gt;()</code>这几种字符，而<code>&amp;;</code>则在parseline()里完成，判断是否有并列命令与列表命令。这里处理字符有一个很关键的函数gettoken()，它是一个词法提取函数，用户提取每一个子命令，将在下面一节介绍。在构造listcmd的时候，采用了递归调用自身的方法，这种方式可以解决多个并列命令相连的情况，例如<code>echo hello;echo world;echo haha</code>。</p>
<h4 id="gettoken"><a href="#gettoken" class="headerlink" title="gettoken()"></a>gettoken()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> whitespace[] = <span class="string">" \t\r\n\v"</span>;</div><div class="line"><span class="keyword">char</span> symbols[] = <span class="string">"&lt;|&gt;&amp;;()"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">gettoken</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es, <span class="keyword">char</span> **q, <span class="keyword">char</span> **eq)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *s;</div><div class="line">  <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">  s = *ps;</div><div class="line">  <span class="keyword">while</span>(s &lt; es &amp;&amp; <span class="built_in">strchr</span>(whitespace, *s))</div><div class="line">    s++;</div><div class="line">  <span class="keyword">if</span>(q)</div><div class="line">    *q = s;</div><div class="line">  ret = *s;</div><div class="line">  <span class="keyword">switch</span>(*s)&#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="string">'|'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'('</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">')'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">';'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'&amp;'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">    s++;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">    s++;</div><div class="line">    <span class="keyword">if</span>(*s == <span class="string">'&gt;'</span>)&#123;</div><div class="line">      ret = <span class="string">'+'</span>;</div><div class="line">      s++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    ret = <span class="string">'a'</span>;</div><div class="line">    <span class="keyword">while</span>(s &lt; es &amp;&amp; !<span class="built_in">strchr</span>(whitespace, *s) &amp;&amp; !<span class="built_in">strchr</span>(symbols, *s))</div><div class="line">      s++;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(eq)</div><div class="line">    *eq = s;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(s &lt; es &amp;&amp; <span class="built_in">strchr</span>(whitespace, *s))</div><div class="line">    s++;</div><div class="line">  *ps = s;</div><div class="line">  <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这个词法提取函数会把一段字符串提取出来，一般是用来提取基本命令或者重定向的文件名。<em>q指向字符串的其实位置，</em>eq指向结尾位置。遇到<code>!();&amp;&lt;&gt;</code>等等则简单地忽略，把指针往后移动到下一个非空格字符；如果遇到实际命令，则返回’a’，代表这是一个真实的基本命令。</p>
<p>　　前面parseline()里的gettoken()只是简单地把代表并列命令的<code>;</code>以及后台命令的<code>&amp;</code>跳过，让字符指针指向下一个非空格字符，并没有抽取字符串。</p>
<h4 id="parsepipe"><a href="#parsepipe" class="headerlink" title="parsepipe()"></a>parsepipe()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parsepipe</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line"></div><div class="line">  cmd = parseexec(ps, es);</div><div class="line">  <span class="keyword">if</span>(peek(ps, es, <span class="string">"|"</span>))&#123;</div><div class="line">    gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cmd = pipecmd(cmd, parsepipe(ps, es));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　把命令以|分成两个个子命令，先构造左边的命令，右边的命令则通过递归调用自身来构造。通过递归调用，可以解析多个管道命令相连的情况，例如<code>{block_a} | {block_b} | {block_c} | {block_d}</code>。</p>
<h4 id="parseexec"><a href="#parseexec" class="headerlink" title="parseexec()"></a>parseexec()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseexec</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *q, *eq;</div><div class="line">  <span class="keyword">int</span> tok, argc;</div><div class="line">  <span class="keyword">struct</span> execcmd *cmd;</div><div class="line">  <span class="keyword">struct</span> cmd *ret;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(peek(ps, es, <span class="string">"("</span>))</div><div class="line">    <span class="keyword">return</span> parseblock(ps, es);</div><div class="line"></div><div class="line">  ret = execcmd();</div><div class="line">  cmd = (<span class="keyword">struct</span> execcmd*)ret;</div><div class="line"></div><div class="line">  argc = <span class="number">0</span>;</div><div class="line">  ret = parseredirs(ret, ps, es);</div><div class="line">  <span class="keyword">while</span>(!peek(ps, es, <span class="string">"|)&amp;;"</span>))&#123;</div><div class="line">    <span class="keyword">if</span>((tok=gettoken(ps, es, &amp;q, &amp;eq)) == <span class="number">0</span>)</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">if</span>(tok != <span class="string">'a'</span>)</div><div class="line">      panic(<span class="string">"syntax"</span>);</div><div class="line">    cmd-&gt;argv[argc] = q;</div><div class="line">    cmd-&gt;eargv[argc] = eq;</div><div class="line">    argc++;</div><div class="line">    <span class="keyword">if</span>(argc &gt;= MAXARGS)</div><div class="line">      panic(<span class="string">"too many args"</span>);</div><div class="line">    ret = parseredirs(ret, ps, es);</div><div class="line">  &#125;</div><div class="line">  cmd-&gt;argv[argc] = <span class="number">0</span>;</div><div class="line">  cmd-&gt;eargv[argc] = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这个函数主要用于构造最基本的命令。如果遇到()的话则把工作转交给parseblock()，否则说明是基本命令，用gettoken()函数把命令字符串提取出来，用<em>q和</em>eq来指定字符串的起始与结束位置，这两个指针将作为execcmd的参数。在解析完基本命令后，很可能还存在着重定向参数，于是把execcmd作为子命令传递给parseredirs()函数，看能不能构造redircmd。</p>
<h4 id="parseblock"><a href="#parseblock" class="headerlink" title="parseblock()"></a>parseblock()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseblock</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(!peek(ps, es, <span class="string">"("</span>))</div><div class="line">    panic(<span class="string">"parseblock"</span>);</div><div class="line">  gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">  cmd = parseline(ps, es);</div><div class="line">  <span class="keyword">if</span>(!peek(ps, es, <span class="string">")"</span>))</div><div class="line">    panic(<span class="string">"syntax - missing )"</span>);</div><div class="line">  gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">  cmd = parseredirs(cmd, ps, es);</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　每一个()里面的命令都可以看作一个整体命令，因此主要是递归地把工作转交给parseline()。只有在parseblock()函数里才能处理<code>)</code>字符，因此最后要判断一下是否存在该字符，否则不是一个完整的block。()内的整体命令可能跟着重定向参数，因此这里也需要用parseredirs()看能不能包装成redircmd。</p>
<h4 id="parseredirs"><a href="#parseredirs" class="headerlink" title="parseredirs()"></a>parseredirs()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseredirs</span><span class="params">(<span class="keyword">struct</span> cmd *cmd, <span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> tok;</div><div class="line">  <span class="keyword">char</span> *q, *eq;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(peek(ps, es, <span class="string">"&lt;&gt;"</span>))&#123;</div><div class="line">    tok = gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(gettoken(ps, es, &amp;q, &amp;eq) != <span class="string">'a'</span>)</div><div class="line">      panic(<span class="string">"missing file for redirection"</span>);</div><div class="line">    <span class="keyword">switch</span>(tok)&#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">      cmd = redircmd(cmd, q, eq, O_RDONLY, <span class="number">0</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, <span class="number">1</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:  <span class="comment">// &gt;&gt;</span></div><div class="line">      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, <span class="number">1</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　先判断是否有重定向参数，如果没有，则不作任何处理。如果有，则将子命令包装成listcmd。经过gettoken()的词法提取后，<em>q和</em>eq分别指向重定向文件名的起始与结束的内存位置，它们都作为参数构造器listcmd。</p>
<h4 id="nulterminate"><a href="#nulterminate" class="headerlink" title="nulterminate()"></a>nulterminate()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">nulterminate</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">struct</span> backcmd *bcmd;</div><div class="line">  <span class="keyword">struct</span> execcmd *ecmd;</div><div class="line">  <span class="keyword">struct</span> listcmd *lcmd;</div><div class="line">  <span class="keyword">struct</span> pipecmd *pcmd;</div><div class="line">  <span class="keyword">struct</span> redircmd *rcmd;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</div><div class="line">  <span class="keyword">case</span> EXEC:</div><div class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; ecmd-&gt;argv[i]; i++)</div><div class="line">      *ecmd-&gt;eargv[i] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">case</span> REDIR:</div><div class="line">    rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</div><div class="line">    nulterminate(rcmd-&gt;cmd);</div><div class="line">    *rcmd-&gt;efile = <span class="number">0</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">case</span> PIPE:</div><div class="line">    pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</div><div class="line">    nulterminate(pcmd-&gt;left);</div><div class="line">    nulterminate(pcmd-&gt;right);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">case</span> LIST:</div><div class="line">    lcmd = (<span class="keyword">struct</span> listcmd*)cmd;</div><div class="line">    nulterminate(lcmd-&gt;left);</div><div class="line">    nulterminate(lcmd-&gt;right);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">case</span> BACK:</div><div class="line">    bcmd = (<span class="keyword">struct</span> backcmd*)cmd;</div><div class="line">    nulterminate(bcmd-&gt;cmd);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在parsecmd()函数的最后一步，我们看到调用了nulterminate()这个函数。我们也看到，在execcmd里用eargv数组保存每一个命令参数的字符串结束位置；在redircmd里用efile保存了重定向文件名的字符串结束位置。nulterminate()就是给每一个结束位置指针指向的内存标识上字符串的结束标志\0。让这些参数都成为完整的字符串，那么在命令执行时候就能够正确处理。</p>
<h3 id="命令执行器"><a href="#命令执行器" class="headerlink" title="命令执行器"></a>命令执行器</h3><p>　　在经历了上述的命令构造阶段以后，我们获得了一个封装好的链式命令串，是一个cmd*类型的指针，通过把该指针传递给runcmd()，来执行命令。下面先来看看runcmd()的源代码，然后分析每一种命令是怎么被执行的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Execute cmd.  Never returns.</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> p[<span class="number">2</span>];</div><div class="line">  <span class="keyword">struct</span> backcmd *bcmd;</div><div class="line">  <span class="keyword">struct</span> execcmd *ecmd;</div><div class="line">  <span class="keyword">struct</span> listcmd *lcmd;</div><div class="line">  <span class="keyword">struct</span> pipecmd *pcmd;</div><div class="line">  <span class="keyword">struct</span> redircmd *rcmd;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</div><div class="line">    <span class="built_in">exit</span>();</div><div class="line"></div><div class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    panic(<span class="string">"runcmd"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">case</span> EXEC:</div><div class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</div><div class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</div><div class="line">      <span class="built_in">exit</span>();</div><div class="line">    exec(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</div><div class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">"exec %s failed\n"</span>, ecmd-&gt;argv[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">case</span> REDIR:</div><div class="line">    rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</div><div class="line">    close(rcmd-&gt;fd);</div><div class="line">    <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">"open %s failed\n"</span>, rcmd-&gt;file);</div><div class="line">      <span class="built_in">exit</span>();</div><div class="line">    &#125;</div><div class="line">    runcmd(rcmd-&gt;cmd);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">case</span> LIST:</div><div class="line">    lcmd = (<span class="keyword">struct</span> listcmd*)cmd;</div><div class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</div><div class="line">      runcmd(lcmd-&gt;left);</div><div class="line">    wait();</div><div class="line">    runcmd(lcmd-&gt;right);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">case</span> PIPE:</div><div class="line">    pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</div><div class="line">    <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</div><div class="line">      panic(<span class="string">"pipe"</span>);</div><div class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</div><div class="line">      close(<span class="number">1</span>);</div><div class="line">      dup(p[<span class="number">1</span>]);</div><div class="line">      close(p[<span class="number">0</span>]);</div><div class="line">      close(p[<span class="number">1</span>]);</div><div class="line">      runcmd(pcmd-&gt;left);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</div><div class="line">      close(<span class="number">0</span>);</div><div class="line">      dup(p[<span class="number">0</span>]);</div><div class="line">      close(p[<span class="number">0</span>]);</div><div class="line">      close(p[<span class="number">1</span>]);</div><div class="line">      runcmd(pcmd-&gt;right);</div><div class="line">    &#125;</div><div class="line">    close(p[<span class="number">0</span>]);</div><div class="line">    close(p[<span class="number">1</span>]);</div><div class="line">    wait();</div><div class="line">    wait();</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">case</span> BACK:</div><div class="line">    bcmd = (<span class="keyword">struct</span> backcmd*)cmd;</div><div class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</div><div class="line">      runcmd(bcmd-&gt;cmd);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">exit</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>判断cmd的type类型。</li>
<li>如果是EXEC，说明是基本命令，用系统调用exec()来执行该命令。基本命令都是一些写好的外部用户程序，以可执行文件的形式来给用户使用。exec()会根据该文件替换掉原进程的所有内存内容，然后执行该程序的代码。这些文件都是以一定的标准格式编写的，需要指定内存的代码区，数据区，堆栈区等等。</li>
<li>如果是REDIR，说明是重定向命令。所有用户程序都遵循一个标准，就是用文件描述符0作为输入，文件描述符1作为输出。那么要实现重定向，只需要关闭原来的0或1文件描述符，然后再用系统调用open()，让新打开的文件占用0或1文件描述符，再对子命令递归调用runcmd()函数即可。</li>
<li>如果是LIST，说明是并列命令。需要分别执行左右子命令。</li>
<li>如果是PIPE，说明是管道命令。也是分别执行左右子命令，对于每个执行子进程，都需要关闭0或1文件描述符，然后用系统调用dup()来让刚刚关闭的文件描述符指向管道某端的文件描述符，从而实现重定向。</li>
<li>如果是BACK，说明是后台命令。新派生一个子进程来执行子命令即可。</li>
</ol>
<p>　　从上面的命令执行过程可以知道，由于命令构造是用递归实现的，那么执行过程本身也是一个递归过程。通过递归调用，最终形成一个树状的执行链，每一个叶子就是一个基本命令。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[erlang二进制串深度解析及优化]]></title>
      <url>http://wjqwsp.github.io/2017/05/20/erlang-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%B2%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　erlang作为函数式与天生并发的语言，其内存管理与垃圾回收无疑便是重点话题。本文并不想详细解析其内存管理与垃圾回收机制，而关注的是与这个主题密切相关的二进制串型。二进制串型是erlang的一种数据类型，目的是用二进制数编码erlang的其他类型，通常是用做进程间的大数据量传输。其设计非常精妙，特别是erlang的R12B版本以后对其做了大幅度的优化，有必要分析一下它对于erlang内存管理方面的影响。<br><a id="more"></a></p>
<h3 id="erlang的内存管理模型"><a href="#erlang的内存管理模型" class="headerlink" title="erlang的内存管理模型"></a>erlang的内存管理模型</h3><p>　　具体展开分析二进制串型之前，先来看看erlang的内存管理模型</p>
<p><img src="/img/erlang-memory.png" alt="erlang memory"></p>
<p>　　这幅图是erlang比较经典的介绍内存管理的结构图。可以看到其内存可以大致分成4个区域。</p>
<ol>
<li>进程控制块。存储进程的一些元数据信息，例如进程PID，状态，注册名字等等。</li>
<li>栈。存储一些函数参数，本地参数等小于一个机器字的轻量数据。</li>
<li>堆。进程的主要存储区，存储进程的消息队列，复杂的数据，例如列表，元组，二进制串等等。</li>
<li>共享区域。所有进程共享的内存区，主要存储refc binary。</li>
</ol>
<p>　　这里不做过多展开，只需要注意两部分，就是堆中的二进制串与共享区域的refc binary。erlang的内存是分进程管理的，每个进程有自己的堆，绝大部分数据都存储在独立的进程堆中，进程间的消息通信一般不存在内存共享，都是采用复制式通信。这就包括所有小于64字节的二进制串型。但这种复制式通信有一个例外，就是大于64字节的二进制串型，如果全都采用复制式通信，会造成极大的内存与时间的消耗，因此把这些二进制串放在共享区域中，称为refc binary。</p>
<p>　　所有的refc binary都有一个元数据指针，称作ProcBin。它直接指向共享内存区的refc binary数据块，并且还包含了一些非常重要的元数据。当要在进程间传输refc binary时，不复制真正的数据块，而是把ProcBin复制一份，传送到其他进程。当然这个得在同一个erlang node中，否则还是会复制真正的数据块。</p>
<h3 id="4种类型的erlang二进制串"><a href="#4种类型的erlang二进制串" class="headerlink" title="4种类型的erlang二进制串"></a>4种类型的erlang二进制串</h3><p>　　初步认识了refc binary，知道了erlang二进制串虽然在开发人员看来只有一种数据类型，但其内部是分为不只一种的。其实内部实现共有4种，本文就是对这4种类型展开阐述。</p>
<h4 id="heap-binary"><a href="#heap-binary" class="headerlink" title="heap binary"></a>heap binary</h4><p>　　堆二进制串。所有小于64字节的二进制串型都作为进程私有堆中的数据存储。</p>
<h4 id="refc-binary"><a href="#refc-binary" class="headerlink" title="refc binary"></a>refc binary</h4><p>　　引用二进制串型。这种类型分为两部分，一部分是在共享区域中的真正数据，另一部分是在进程堆中的ProcBin指针。ProcBin还包含了数据块的实际大小信息。</p>
<h4 id="sub-binary"><a href="#sub-binary" class="headerlink" title="sub binary"></a>sub binary</h4><p>　　子二进制串。对于一个长串的二进制串，在数据处理时候经常需要匹配其中的一小部分。为了在时间与空间上更加轻量与廉价，对于子二进制串是不会复制再另外分配内存的，一般只是生成一个引用指向该原数据，该引用包含在原数据块中的大小与偏移量。</p>
<h4 id="match-context"><a href="#match-context" class="headerlink" title="match context"></a>match context</h4><p>　　匹配上下文。一般用在二进制串的模式匹配中，用于对子二进制串的优化。它维护一个指针直接指向原数据块，在绝非必要的情况下不会生成子二进制串。erlang R12B版本之后关于用match context进行子二进制串优化做了很多工作，会在后面阐述。</p>
<h3 id="构造二进制串"><a href="#构造二进制串" class="headerlink" title="构造二进制串"></a>构造二进制串</h3><p>　　R12B版本之后，构造二进制串有了大幅度的优化。</p>
<h4 id="优化原理"><a href="#优化原理" class="headerlink" title="优化原理"></a>优化原理</h4><p>　　在创建二进制串时，我们往往是采用分段拼接的方法。例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bin0 = &lt;&lt;<span class="number">0</span>&gt;&gt;,</div><div class="line">Bin1 = &lt;&lt;Bin0/binary, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;，</div><div class="line">Bin2 = &lt;&lt;Bin1/binary, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&gt;&gt;.</div></pre></td></tr></table></figure>
<p>　　erlang虚拟机会把Bin0作为heap binary在进程堆空间中分配内存。那么Bin1呢，是否会把Bin0复制一份再加上后面3个整数？Bin2呢？答案是,前者是肯定，后者是否定的。为了让构造二进制串更加轻量与廉价，在构造Bin1时，会把Bin0复制，生成一个refc binary，在后面接上<code>&lt;&lt;1, 2, 3&gt;&gt;</code>。但是，Bin1还会扩展内存，在实际数据后面加入一段空余空间。如果原数据的2倍小于256字节则refc binary会扩充空余空间直到256字节，否则扩充到原数据大小的2倍。这里，Bin1的有用数据大小是4字节，因此会扩充到256字节。因此，Bin1会分配256字节空间到共享内存区域，其ProcBin在进程私有堆空间中，保存了实际大小4字节的信息。在构造Bin2时，则会直接在空余空间中写入<code>&lt;&lt;4, 5, 6&gt;&gt;</code>。</p>
<p>　　此后，如果再向Bin2后面添加数据,只要数据块总大小不超过256字节，就直接在空余空间中写入，不会有复制动作。如果添加的数据耗尽了所有空余空间，则会重新分配内存，继续扩充空间到实际数据大小的2倍。</p>
<h4 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h4><p>　　还是有一些例外情况，使得构造二进制串必须采用复制，而不能直接在后面拼接。</p>
<p>　　仍然是之前的例子。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Bin0 = &lt;&lt;<span class="number">0</span>&gt;&gt;,                    <span class="comment">%% 1</span></div><div class="line">Bin1 = &lt;&lt;Bin0/binary,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&gt;&gt;,    <span class="comment">%% 2</span></div><div class="line">Bin2 = &lt;&lt;Bin1/binary,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&gt;&gt;,    <span class="comment">%% 3</span></div><div class="line">Bin3 = &lt;&lt;Bin2/binary,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&gt;&gt;,    <span class="comment">%% 4</span></div><div class="line">Bin4 = &lt;&lt;Bin1/binary,<span class="number">17</span>&gt;&gt;,       <span class="comment">%% 5 !!!</span></div><div class="line">&#123;Bin4,Bin3&#125;                      <span class="comment">%% 6</span></div></pre></td></tr></table></figure>
<p>　　Bin2和Bin3都是直接在空余空间中写入后续数据的，但Bin4不一样。Bin4是在Bin1后面写入，但我们知道，在构造了Bin2和Bin3之后，Bin1对应的数据块后面已经紧跟了<code>&lt;&lt;4, 5, 6, 7, 8, 9&gt;&gt;</code>。erlang具有函数式语言的引用透明性的特点，不能让Bin4在Bin1后面写入数据，否则会覆盖掉4，使得数据块变成<code>&lt;&lt;0, 1, 2, 3, 17, 5, 6, 7, 8, 9&gt;&gt;</code>。这时候，会对Bin1进行复制，在后面拼接17，并且重新分配空余空间。这种情况下复制是合理的，且是必须的。</p>
<p>　　另一种情况，是如果要把refc binary作为进程间消息进行传递，后续再进行拼接时必须对原数据进行复制。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bin1 = &lt;&lt;Bin0,...&gt;&gt;,</div><div class="line">PortOrPid ! Bin1,</div><div class="line">Bin = &lt;&lt;Bin1,...&gt;&gt;  <span class="comment">%% Bin1 will be COPIED</span></div></pre></td></tr></table></figure>
<p>　　Bin1发送给别的进程或者端口，这时候会触发原数据块的收缩，把空余空间全部砍掉，再复制ProcBin，发送给端口或者进程。</p>
<p>　　后续通过Bin1构造Bin时，则会复制一份Bin1，再分配空余空间，形成新的refc binary。</p>
<p>　　还有一种情况，是对refc binary进行模式匹配后，会触发原数据块的收缩，后续的拼接也会强制进行复制。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bin1 = &lt;&lt;Bin0,...&gt;&gt;,</div><div class="line">&lt;&lt;X,Y,Z,T/binary&gt;&gt; = Bin1,</div><div class="line">Bin = &lt;&lt;Bin1,...&gt;&gt;  <span class="comment">%% Bin1 will be COPIED</span></div></pre></td></tr></table></figure>
<p>　　最后，当进程长期持有某个refc binary时，垃圾回收器会对它进行收缩处理。如果之后要进行拼接，则会重新分配内存，在后面添加空余空间。</p>
<h3 id="二进制串匹配"><a href="#二进制串匹配" class="headerlink" title="二进制串匹配"></a>二进制串匹配</h3><p>　　R12B对二进制串匹配做了大量的优化。</p>
<h4 id="match-context如何工作"><a href="#match-context如何工作" class="headerlink" title="match context如何工作"></a>match context如何工作</h4><p>　　先来看看match context是如何工作的。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> Bits <span class="keyword">of</span></div><div class="line">    &lt;&lt;A:<span class="number">8</span>, <span class="number">1</span>:<span class="number">8</span>, X:<span class="number">8</span>, Bin/bits&gt;&gt; -&gt; cont1;</div><div class="line">    &lt;&lt;A:<span class="number">8</span>, <span class="number">2</span>:<span class="number">8</span>, X:<span class="number">16</span>, Bin/bits&gt;&gt; -&gt; cont2;</div><div class="line">    &lt;&lt;&gt;&gt; -&gt; cont3</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>　　erlang编译器会对这段代码展开，生成处理模式匹配的代码，下面看看生成的代码流程图：</p>
<p><img src="/img/R11B.png" alt="R11B"></p>
<p>　　先来看看里面涉及到的几个函数：</p>
<ol>
<li>create_matchstate。这个函数会对传入的二进制串生成match context，一开始指向第一个字节。</li>
<li>save_matchstate会存储当前的match context，以便将来恢复出二进制串。</li>
<li>get_integer会根据match context以及附加偏移量从二进制串中提取一个整型数据，并且更新match context的偏移量。</li>
<li>get_bitstring会根据match context生成sub binary。</li>
<li>restore_matchstate会根据之前save_matchstate存储的二进制串恢复当时的match context偏移量。</li>
<li>判断match context的偏移量是否等于二进制串的总长度，从而知道是否已经不能再匹配了。</li>
</ol>
<p>　　上述代码的整个匹配流程如下：</p>
<ol>
<li>对Bits这个变量调用create_matchstate，生成match context。</li>
<li>存储刚刚生成的match context。</li>
<li>对match context调用get_integer，传入偏移量8，生成integer作为变量A的值，并且更新match context，使其指向下一个字节。如果能得到整型，则进入左分支。否则调用restore_matchstate，恢复之前存储的match context，再调用end_of_bitstring判断是否已经到达二进制串的末尾，如果是，则原代码case语句匹配到最后一个子句，返回cont3。</li>
<li>如果进入左分支，再调用get_integer，传入偏移量8，生成integer，并更新match context。如果生成的整数是1，则进入下一个左分支；如果是2，则进入右分支。</li>
<li>如果进入下一个左分支，则再调用get_integer，传入偏移量8，生成integer作为变量X的值，更新match context，使其继续指向下一个字节。然后，对更新后的match context调用get_bitstring，把剩余的所有二进制串都传入，生成一个sub binary。此时，对应到原代码的子句一，返回cont1。</li>
<li>如果进入右分支，则调用get_integer，传入偏移量16，生成integer作为变量X的值，更新match context，使其指向后两个字节。然后，对更新后的match context调用get_bitstring，把剩余的所有二进制串都传入，生成一个sub binary。此时，对应到原代码的子句二，返回cont2。</li>
</ol>
<h4 id="R11B前的二进制串匹配"><a href="#R11B前的二进制串匹配" class="headerlink" title="R11B前的二进制串匹配"></a>R11B前的二进制串匹配</h4><p>　　先来看看R12B前，erlang对二进制串的处理有哪些性能不理想的地方，以及如何对其优化。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">sum1</span><span class="params">(Bits)</span> -&gt;</span></div><div class="line">    sum1(Bits, <span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="function"><span class="title">sum1</span><span class="params">(&lt;&lt;X,Rest/bits&gt;&gt;, Acc)</span> -&gt;</span></div><div class="line">    sum1(Rest, Acc+X);</div><div class="line"><span class="function"><span class="title">sum1</span><span class="params">(&lt;&lt;&gt;&gt;, Acc)</span> -&gt;</span> Acc.</div><div class="line"></div><div class="line"><span class="function"><span class="title">sum2</span><span class="params">(Bits)</span> -&gt;</span></div><div class="line">    sum2(Bits,<span class="number">0</span>,<span class="number">0</span>).</div><div class="line"></div><div class="line"><span class="function"><span class="title">sum2</span><span class="params">(Bits,N,Acc)</span> -&gt;</span></div><div class="line">    <span class="keyword">case</span> Bits <span class="keyword">of</span></div><div class="line">        &lt;&lt;_:N,X,Rest/bits&gt;&gt; -&gt;</div><div class="line">            sum2(Bits,N+<span class="number">8</span>,Acc+X);</div><div class="line">        &lt;&lt;_/bits&gt;&gt; -&gt;</div><div class="line">            Acc</div><div class="line">    <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>　　在R11B时，sum1/2函数的效率是很低的。来看看由上述sum1/2函数生成的内部代码流程图：</p>
<p><img src="/img/sum1-2.png" alt="sum1/2"></p>
<p>　　再每次递归调用时，都会生成一个match context和一个sub binary。这个sub binary在下一次递归调用时只用来生成下一个match context，而并没有其他作用。这样在N次递归调用后，会生成N个sub binary以及N+1个match context。</p>
<p>　　在R12B前，可以用sum2/3函数来优化这个累加的过程。来看看sum2/3函数生成的内部代码流程图：</p>
<p><img src="/img/sum2-3.png" alt="sum2/3"></p>
<p>　　sum2/3函数自己维护一个偏移量N，而不把Rest传递给下一个递归调用。这样就不会由match context生成sub binary。但是每次递归调用仍然会创建一个match context。N次递归调用后，仍然会生成N+1个match context。</p>
<h4 id="R12B的二进制匹配优化"><a href="#R12B的二进制匹配优化" class="headerlink" title="R12B的二进制匹配优化"></a>R12B的二进制匹配优化</h4><p>　　R12B提供了对match context延迟生成sub binary的优化，看看sum1/2函数优化后的内部代码流程图：</p>
<p><img src="/img/R12B.png" alt="R12B"></p>
<p>　　erlang编译器会自动检测Rest是否会被用作其他用途，如果单纯只是用在下一个递归中，则不会生成sub binary，也不会在每次递归调用中生成match context，会一直保存match context，并把match context传给下一个递归调用。直到当编译器发现要传进来的二进制串及match context需要用作其他用途，例如传递给除自身递归函数以外的函数，则会延迟生成一个sub binary。</p>
<p>　　这样，N次递归调用只会生成一个match context。</p>
<h4 id="编译器无法优化"><a href="#编译器无法优化" class="headerlink" title="编译器无法优化"></a>编译器无法优化</h4><p>　　前面说到，只有当erlang编译器能明确知道match context不需要用作其他用途，才不会生成sub binary。但有些时候，编译器比较笨，使得优化失败。但我们不需要自己判断什么时候无法优化，而可以利用erlang的输出信息来检测。</p>
<p>　　第一个方法，是在编译时候加入bin_opt_info参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erlc +bin_opt_info Mod.erl</div></pre></td></tr></table></figure>
<p>　　还可以修改环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export ERL_COMPILER_OPTIONS=bin_opt_info</div></pre></td></tr></table></figure>
<p>　　这样，在涉及到编译器无法优化或者可以优化二进制串匹配时候，就会输出日志信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./efficiency_guide.erl:60: Warning: NOT OPTIMIZED: sub binary is used or returned</div><div class="line">./efficiency_guide.erl:62: Warning: OPTIMIZED: creation of sub binary delayed</div></pre></td></tr></table></figure>
<p>　　并且，除了warning信息以外，如果无法优化，还会有相应的info信息告诉你为什么无法优化，需要怎么调整代码。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　根据以上几点R12B对二进制串的优化，我们写代码时候可以注意一下几点：</p>
<ol>
<li>在进行二进制串构造时，把原二进制串放在前面，附加数据放在后面，这样可以利用空余空间，而不需要进行内存复制。</li>
<li>在递归处理二进制串匹配时，注意除了自身递归调用函数以外，不要在其他地方共享match context。这样就会延迟生成sub binary。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SSH协议基本原理及用法]]></title>
      <url>http://wjqwsp.github.io/2017/05/02/SSH%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　SSH是linux系统远程登录及命令操作的常用协议与指令，基本用法非常简单。最近在做持续集成工作时候，在SSH上面遇到一些坑，因此在这里总结一下。<br><a id="more"></a></p>
<h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3><p>　　SSH远程登录有两种方式，分别是口令登录及公钥登录。</p>
<h4 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h4><h5 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h5><p>　　口令登录即在登录时候输入远程主机的用户名及密码。其流程如下：</p>
<ol>
<li>远程主机收到用户的登录请求，把自己公钥发给用户。</li>
<li>用户用远程主机的公钥将登录密码加密，发给远程主机。</li>
<li>远程主机用自己的私钥解密登录密码，判断是否正确，决定是否让用户登录。</li>
</ol>
<h5 id="known-hosts"><a href="#known-hosts" class="headerlink" title="known_hosts"></a>known_hosts</h5><p>　　上面用户收到远程主机的公钥后，如果是第一次连接该远程主机，则一般会先在shell里打印出公钥指纹，询问用户是否继续连接，如果选择继续则会把公钥加入到known_hosts文件里。如果要做自动化构建和部署的话，则不能用这种询问模式。解决办法有两种：</p>
<ol>
<li>在用户的~/.ssh/config文件或/etc/ssh/ssh_config里加入这一行：<code>StrictHostKeyChecking no</code></li>
<li>提前获知远程主机的公钥，事先手动写入known_hosts文件中。</li>
</ol>
<p>　　在写入known_hosts文件以后，之后再次登录就不会再询问了，而是在获取远程主机公钥后与known_hosts文件进行比对。如果远程主机更改了公钥，导致不一致了，则会产生异常。这时需要删除known_hosts里对应那一行的公钥信息，重新获取并写入。如果不想用known_hosts保存远程主机的公钥，则可以修改/etc/ssh/ssh_config，加入这一行：<code>UserKnownHostsFile=/dev/null</code></p>
<p>　　~/.ssh/config是针对特定用户的配置文件，/etc/ssh/ssh_config和/etc/ssh/sshd_config都是公共的配置文件，其中前者针对ssh客户端，后者针对服务器端。</p>
<h4 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h4><p>　　公钥登录不需要输入密码，是自动化技术的必备武器。需要事先将客户机的公钥拷贝到远程主机的~/.ssh/authorized_keys文件里。一般是用ssh-copy-id指令实现，可以用-i参数指定公钥文件。ssh-copy-id实际上相当于使用了这条指令：<code>ssh user@host &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></p>
<h5 id="主要流程-1"><a href="#主要流程-1" class="headerlink" title="主要流程"></a>主要流程</h5><p>　　流程如下：</p>
<ol>
<li>远程主机收到登录请求，向用户发送一段随机字符串。</li>
<li>用户用自己的私钥加密发到远程主机里。</li>
<li>远程主机再用事先存好的公钥解密。如果成功，则直接允许登录。</li>
</ol>
<p>　　即便是公钥登录，客户机仍然会收到远程主机的公钥数据，并加到known_hosts中。</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>　　有几种情况可能导致使用了ssh-copy-id但仍提示需要输入登录密码：</p>
<ul>
<li>远程主机/etc/ssh/sshd_config这个文件下面几行注释没有去掉：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RSAAuthentication yes</div><div class="line">PubkeyAuthentication yes</div><div class="line">AuthorizedKeysFile .ssh/authorized_keys</div></pre></td></tr></table></figure>
<p>　　其中主要是第三行，前两行即便注释了默认都是yes。</p>
<ul>
<li>远程主机~/.ssh/authorized_keys权限不足。需要让所有者用户可读写，可以用chmod解决：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 600 ~/.ssh/authorized_keys</div></pre></td></tr></table></figure>
<ul>
<li>远程主机~目录和.ssh目录不能让除了该用户其余的人具有写权限，这个需要格外注意。</li>
<li>出于某种原因，客户机的ssh-agent高速缓存内没有该私钥的信息。可以用<code>ssh-add -l</code>查看。如果的确没有，则要ssh-add进去。其中~/.ssh/id_rsa会自动加进去，一般不需要手动添加，但其他私钥需要手动添加。这个是放在内存里的临时缓存，重启后需要重新ssh-add私钥进去。</li>
</ul>
<h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p>　　前面提到过，客户机会收到远程主机的公钥后，会在shell打印出其指纹。因为在用户发出登录请求后，如果有第三方截获了该请求，并冒充远程主机将伪造的公钥发给用户，那么用户就会把远程主机的密码用伪造公钥加密发给第三方，从而被它获得远程主机的登录密码，使得这个过程存在着极高的风险。</p>
<p>　　客户机只要用返回的指纹和远程主机公示的指纹签名进行比对，就可以确定是否伪造了。</p>
<h3 id="创建公钥私钥对"><a href="#创建公钥私钥对" class="headerlink" title="创建公钥私钥对"></a>创建公钥私钥对</h3><p>　　ssh-keygen命令可以创建。-N输入私钥密码，-f指定文件名，-C输入备注，-t指定加密算法，默认是rsa。</p>
<p>　　需要用ssh-add加入ssh-agent高速缓存内才有效。ssh-agent同时也可以作为自动化免去私钥密码的一项技术。事先将私钥加入ssh-agent，这时候要输入私钥密码。以后用ssh指令的时候就只会在缓存中直接调用私钥，不需要再输入密码了。</p>
<h3 id="管理多个SSH-key"><a href="#管理多个SSH-key" class="headerlink" title="管理多个SSH key"></a>管理多个SSH key</h3><p>　　最简单的就是上面那样用ssh-add把私钥都放到高速缓存中，客户端在用ssh指令的时候会按照一定的策略轮流尝试。但因为是放在内存中的，每次重启都会清空，有点不方便。</p>
<p>　　最正常的做法是放到~/.ssh/config文件中，配置示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Host github.com</div><div class="line">    HostName github.com</div><div class="line">    User git</div><div class="line">    IdentityFile ~/.ssh/id_rsa_a</div><div class="line"></div><div class="line">Host git.oschina.net</div><div class="line">    HostName git.oschina.net</div><div class="line">    User git</div><div class="line">    IdentityFile ~/.ssh/id_rsa_b</div></pre></td></tr></table></figure>
<p>　　config文件有很多种写法，还支持通配符。不仅可以用来管理ssh key，还可以用来省略输入用户名，简化hostname使得便于记忆等等。管理ssh key最常见的就是管理github和gitlab多个账户。
　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gitlab CI 对erlang应用进行自动测试]]></title>
      <url>http://wjqwsp.github.io/2017/03/20/Gitlabb-CI-%E5%AF%B9erlang%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h3 id="Common-Test测试框架"><a href="#Common-Test测试框架" class="headerlink" title="Common Test测试框架"></a>Common Test测试框架</h3><p>　　common test是erlang自带的一个测试框架，对于复杂，大规模，特别是分布式的测试场景，它尤为合适。我们将先用它来编写测试计划，然后再编写gitlab ci的测试脚本来调用这些测试计划，从而实现自动测试。</p>
<a id="more"></a>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>　　common test由内而外可分为四层。最内层，也即粒度最小的结构，是test case。它们是一个个函数，每一个函数都作为一个测试用例来测试一个小的功能点。包裹一组test case的模块是test suite，他们把一些针对系统同一部件的测试组织在一起。许多test suite组成test object directory。所有test object directory都在test root目录里。由此从内而外，由下而上，一层一层地搭建起针对整个erlang系统的测试，力求覆盖系统的方方面面。</p>
<h4 id="基本测试方法"><a href="#基本测试方法" class="headerlink" title="基本测试方法"></a>基本测试方法</h4><p>　　我们一般针对test suite来运行测试。为了简化测试的过程，更好地组织起对多个test suite的测试计划，common test还有一个非常强大的测试工具：test spec。对于复杂特别是分布式的测试场景，我们一般使用test spec。它实际上就是让我们编写一个配置文件，利用提供的一些配置元组来配置我们的测试计划。除了erlang原生的一些执行common test的指令外，rebar3也对common test有很好的支持，下面来总结一下erlang原生自带的和rebar3下分别是如何执行common test测试的。</p>
<h5 id="erlang原生"><a href="#erlang原生" class="headerlink" title="erlang原生"></a>erlang原生</h5><h6 id="针对test-suite进行测试"><a href="#针对test-suite进行测试" class="headerlink" title="针对test suite进行测试"></a>针对test suite进行测试</h6><p>　　linux shell下直接运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ct_run -suite *****_SUITE</div></pre></td></tr></table></figure>
<p>　　erl shell里运行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ct:run_test([&#123;suite, *****_SUITE&#125;])</div></pre></td></tr></table></figure>
<h6 id="运行test-spec"><a href="#运行test-spec" class="headerlink" title="运行test spec"></a>运行test spec</h6><p>　　linux shell下直接运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ct_run -spec ****.spec</div></pre></td></tr></table></figure>
<p>　　erl shell里运行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ct:run_test([&#123;spec, <span class="string">"****.spec"</span>&#125;])</div></pre></td></tr></table></figure>
<p>　　但是，对于需要执行分布式测试的test spec，则只能在erl shell里运行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ct_master:run(<span class="string">"****.spec"</span>)</div></pre></td></tr></table></figure>
<h5 id="rebar3"><a href="#rebar3" class="headerlink" title="rebar3"></a>rebar3</h5><h6 id="针对test-suite进行测试-1"><a href="#针对test-suite进行测试-1" class="headerlink" title="针对test suite进行测试"></a>针对test suite进行测试</h6><p>　　如果应用是用rebar3建立的，那么运行测试非常简单。只需要执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rebar3 ct</div></pre></td></tr></table></figure>
<p>　　会自动运行应用内test文件夹下所有的test suite文件。还可以指定执行哪些test suite：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rebar3 ct -suite=***_SUITE</div></pre></td></tr></table></figure>
<h6 id="运行test-spec-1"><a href="#运行test-spec-1" class="headerlink" title="运行test spec"></a>运行test spec</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rebar3 ct -spec=***.spec</div></pre></td></tr></table></figure>
<p>　　可以用上述方法指定执行哪一个或那几个spec文件。但是，如果spec文件执行的是分布式测试，那么测试会忽略掉。目前，分布式测试只找到用erlang原生的函数来执行的办法。</p>
<h3 id="Gitlab-CI进行erlang分布式测试"><a href="#Gitlab-CI进行erlang分布式测试" class="headerlink" title="Gitlab CI进行erlang分布式测试"></a>Gitlab CI进行erlang分布式测试</h3><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><h5 id="Gitlab-CI-service不能更改hostname"><a href="#Gitlab-CI-service不能更改hostname" class="headerlink" title="Gitlab CI service不能更改hostname"></a>Gitlab CI service不能更改hostname</h5><p>　　如果要搭建多个虚拟主机的erlang分布式自动测试环境，必须利用Gitlab CI service功能，它底下是用docker link实现对多个docker container的通信，一个service就是一个docker container，即一个虚拟主机。但目前Gitlab CI还不能更改service的hostname。hostname默认是由service的image名字决定，这样就使得一个镜像只能创建一个service，难以创建多个erlang结点。</p>
<p>　　虽然已经有很多Gitlab CI用户反映需要有更改hostname的需求，Gitlab社区版也有了相应的merge request，并且Gitlab官方人员貌似有意在不久的将来把这个功能加进去，但目前还是难以实现。Gitlab CI service的初衷应该主要是一个协助主测试环境的一个单独的虚拟服务器，例如数据库服务器。对于搭建这种分布式环境目前恐怕仍是支持不足。</p>
<h5 id="erlang的docker镜像默认执行的启动指令返回值非0"><a href="#erlang的docker镜像默认执行的启动指令返回值非0" class="headerlink" title="erlang的docker镜像默认执行的启动指令返回值非0"></a>erlang的docker镜像默认执行的启动指令返回值非0</h5><p>　　erlang的docker镜像在启动以后，会默认执行指令erl，即开启一个erl shell。但这个指令返回值不是0，而Gitlab CI是利用返回值是否为0判断是否出错。如果启动一个erlang的service，系统会报错，使得service启动失败。</p>
<h4 id="目前的解决方案"><a href="#目前的解决方案" class="headerlink" title="目前的解决方案"></a>目前的解决方案</h4><p>　　通过在同一个虚拟主机里创建多个虚拟结点的方法来搭建分布式环境，而不把分布式环境搭在多个虚拟主机里。</p>
<h4 id="简单的erlang程序自动测试例子："><a href="#简单的erlang程序自动测试例子：" class="headerlink" title="简单的erlang程序自动测试例子："></a>简单的erlang程序自动测试例子：</h4><p>　　.gitlab-ci.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="attr">image:</span> erlang:<span class="number">18.3</span><span class="number">.4</span></div><div class="line"></div><div class="line"><span class="attr">stages:</span></div><div class="line"><span class="bullet">  -</span> test</div><div class="line"></div><div class="line"><span class="attr">compile:</span></div><div class="line"><span class="attr">  stage:</span> test</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> mkdir ebin</div><div class="line"><span class="bullet">    -</span> mkdir logs</div><div class="line"><span class="bullet">    -</span> cd ebin</div><div class="line"><span class="bullet">    -</span> erlc ../src/meeting.erl</div><div class="line"><span class="bullet">    -</span> erl -noshell -sname ct -run ct_master run <span class="string">"../test/spec.spec"</span> -s init stop</div><div class="line"><span class="bullet">    -</span> vLines=$(grep -vc <span class="string">'&lt;font color=\"red\"&gt;'</span> ../logs/ct_run.c*/index.html)</div><div class="line"><span class="bullet">    -</span> all=$(cat ../logs/ct_run.c*/index.html | wc -l)</div><div class="line"><span class="bullet">    -</span> status1=$(($all-$vLines))</div><div class="line"><span class="bullet">    -</span> vLines=$(grep -vc <span class="string">'&lt;font color=\"red\"&gt;'</span> ../logs/ct_run.d*/index.html)</div><div class="line"><span class="bullet">    -</span> all=$(cat ../logs/ct_run.d*/index.html | wc -l)</div><div class="line"><span class="bullet">    -</span> status2=$(($all-$vLines))</div><div class="line"><span class="bullet">    -</span> status=$(($status1+$status2))</div><div class="line"><span class="bullet">    -</span> exit $status</div></pre></td></tr></table></figure>
<p>　　spec.spec文件：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;node, c, 'c@localhost'&#125;.</div><div class="line">&#123;node, d, 'd@localhost'&#125;.</div><div class="line"></div><div class="line"></div><div class="line">&#123;init, [c,d], [&#123;node_start, [&#123;monitor_master, true&#125;, &#123;erl_flags, <span class="string">"-pa /builds/wangjiasheng/ct-test/ebin/"</span>&#125;]&#125;]&#125;.</div><div class="line"></div><div class="line">&#123;alias, meeting, <span class="string">"./meeting/"</span>&#125;.</div><div class="line">&#123;logdir, all_nodes, <span class="string">"../logs/"</span>&#125;.</div><div class="line">&#123;logdir, master, <span class="string">"../logs/"</span>&#125;.</div><div class="line">&#123;suites, [c,d], meeting, all&#125;.</div></pre></td></tr></table></figure>
<p>　　这里在本机建立两个erlang结点c@localhost和d@localhost。这两个结点都会运行相同的test suite。其中最核心的执行测试的指令就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -noshell -sname ct -run ct_master run &quot;../test/spec.spec&quot; -s init stop</div></pre></td></tr></table></figure>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="更改docker-container的hostname"><a href="#更改docker-container的hostname" class="headerlink" title="更改docker container的hostname"></a>更改docker container的hostname</h5><p>　　在编写spec文件时候，需要指定启动哪些erlang结点，需要知道该结点的sname。然而，Gitlab CI默认的hostname是一长串字符，类似runner-ff7494da-project-564-concurrent-0这种，是运行时动态生成的，并且对该虚拟主机的访问只能通过这个hostname，localhost也是不能用的。因此我们需要自定义一个固定的hostname。</p>
<p>　　只需要在Gitlab CI服务器里修改/srv/gitlab-runner/config/config.toml文件，在相应的gitlab runner配置信息里加上hostname，例如这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[[runners]]</div><div class="line">  name = "ct-runner"</div><div class="line">  url = "http://gitlab.local/ci"</div><div class="line">  token = "ff7494dabc6a295333f685a90a7198"</div><div class="line">  executor = "docker"</div><div class="line">  [runners.docker]</div><div class="line">    hostname = "localhost"</div><div class="line">    tls_verify = false</div><div class="line">    image = "erlang:18.3.4"</div><div class="line">    privileged = false</div><div class="line">    disable_cache = false</div><div class="line">    volumes = ["/cache"]</div><div class="line">    extra_hosts = ["gitlab.local:10.106.128.234"]</div><div class="line">  [runners.cache]</div></pre></td></tr></table></figure>
<h5 id="自行判断测试是否通过"><a href="#自行判断测试是否通过" class="headerlink" title="自行判断测试是否通过"></a>自行判断测试是否通过</h5><p>　　如果在单结点环境下进行测试，无论运行test suite还是test spec，测试正确状态码都是0，错误都是1。这样Gitlab CI的运行结果是能正确体现测试结果的。但如果运行分布式测试，Gitlab CI的运行结果只反映是否连通其他结点。只要连通了，无论测试结果如何状态码都是0。这就需要我们自己判断测试是否通过。</p>
<p>　　每次运行完测试，common test都会生成html格式的报告文件。如果有错误的话，会有错误次数显示，并用红色标注。因此，我们可以通过检索每个结点相应的html文件里是否出现<code>&lt;font color=&quot;red&quot;&gt;</code>这个关键字，来判断测试是否通过。</p>
<p>　　可以用grep命令提取关键字出现的次数，但要注意grep命令如果找不到关键字的话，其返回码是1！！会导致Gitlab CI崩溃。这就与我们找不到关键字代表结果正确这个需求恰恰相反了。所以如果用这个命令来做匹配，需要绕点弯，像上面例子那样，多做几步操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ruby语言特性总结]]></title>
      <url>http://wjqwsp.github.io/2016/12/22/ruby%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　之前在做Gitlab源代码的扩展工作，一直没有时间总结一下Ruby和Rails的内容。最近在看《Effective Ruby》，顺便总结一下Ruby的一些语言特性与进阶内容。此博文将持续不定期更新。<br><a id="more"></a></p>
<h3 id="Ruby最基础的语法特性"><a href="#Ruby最基础的语法特性" class="headerlink" title="Ruby最基础的语法特性"></a>Ruby最基础的语法特性</h3><h4 id="true和false"><a href="#true和false" class="headerlink" title="true和false"></a>true和false</h4><p>　　在Ruby中，一切皆是对象。这个“一切”的概念很广，除了一般面向对象语言的对象概念以外，像class也是对象，true，false，nil等也都是对象。Ruby里用到的==，&gt;=等比较操作符，统统都是对象方法。</p>
<p>　　在其他语言中，true和false往往是关键字。但在Ruby中，它们是不遵循命名规范和赋值规范的全局变量，它们的行为和全局对象一样，只是不以字符$开头，也不能放在赋值语句的左半边。他们都是TrueClass和FalseClass的实例对象。在Ruby中，除了false和nil，一切都是真值，都能让表达式为真，所以true的存在只是方便，是冗余的。</p>
<p>　　凡是某表达式返回false或nil都不成立，其他值都成立。但这样也有一个问题，就是不好区分false和nil方法。最简单的区分方法是用nil?方法，另一种是用==方法，false是方法的调用者。因为Object#==方法会比较方法调用者和参数是否属于同一对象。但要注意false要放在==左边作为方法的调用者，因为如果其他对象放在==左边，相当于调用它们的==方法，而这些对象很可能覆盖了Object#==方法，造成诡异的返回。</p>
<h4 id="留心nil对象"><a href="#留心nil对象" class="headerlink" title="留心nil对象"></a>留心nil对象</h4><p>　　在方法调用过程中，很可能产生nil对象，也很可能传入的参数本身就是nil。对这些对象调用方法往往会抛出nil:NilClass的NoMethodError错误。所以我们在处理对象是要十分小心。</p>
<p>　　最普通的方法是用nil?方法判断一下。或者用to_s，to_i，to_a等方法将对象进行转换。意思是，假如你某个对象是String类的对象，在调用方法前先用to_s处理一下，如果是正常对象则返回本身，如果是nil则返回””，这样在调用方法时就不会抛异常。同理，如果你要处理的对象正常情况下是Integer或Array对象，则可以用to_i，to_a方法转换一下。</p>
<p>　　Array#compact方法还能去除Array里所有nil元素。</p>
<h4 id="避免古怪的语法"><a href="#避免古怪的语法" class="headerlink" title="避免古怪的语法"></a>避免古怪的语法</h4><p>　　由于受Perl语言的影响，Ruby的部分语法显得非常古怪，难以阅读，我们应有意识地避免这些用法。</p>
<p>　　String#=~方法匹配函数右边的正则表达式，返回匹配到的位置或者nil。同时，会将匹配到的结果设置到几个全局变量中，$1，$2，$3等等。但是，这些全局变量非常特殊，它们的作用域仅限于当前进程的当前方法内，相当于全局变量的局部变量，非常容易引起歧义，令人费解。我们可以用String#match方法代替，它会返回一个MatchData的对象的类数组对象，用数组的索引方法取得相应的匹配结果。还有一些其他的有关正则表达式的用法也会设置$1，$2，$3这些值，我们都要尽量避免。</p>
<p>　　Ruby用require来引入其他文件，它用一个全局变量$:来表示一个包含所有库的目录的数组，可见这种奇怪的变量非常难以理解，我们可以用$LOAD_PATH来代替。除此之外，还有$;，$/等类似的古怪变量，这些全局变量我们可以通过require(‘English’)来用一些更有描述性的别名来代替。具体的别名完整列表可以查阅English模块的文档。</p>
<p>　　Kernel#readline方法会从标准输入中读取一行，存储在变量$<em>中。并且，如果Kernel#print没有参数调用时，会自动打印$</em>变量的内容。Regexp#~试图使用右边的正则表达式匹配$_的内容，如果匹配成功返回位置索引否则返回nil。这种语法同样十分难以理解。我们应尽量避免。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>　　Ruby中的常量是可变的，改变常量的值会有warning，但不会报错。我们在使用常量时应用freeze方法将其冻结。</p>
<p>　　所有以大写字母开头的标识符都是常量，类和模块的名字自然也是常量。我们可以用freeze方法冻结常量所在的类或者模块，则该模块内的常量也不会被改变。</p>
<p>　　要冻结数组，还必须冻结数组内的每一个元素。</p>
<h4 id="充分利用警告信息"><a href="#充分利用警告信息" class="headerlink" title="充分利用警告信息"></a>充分利用警告信息</h4><p>　　警告分为编译时警告和运行时警告。我们在开发时建议把两种警告都开启。尤其是编译阶段警告非常重要。</p>
<p>　　Ruby允许在方法调用时不带空格，这样有时候会产生模糊代码，会有警告信息输出。这时候需要Ruby解释器去猜测你的意图，虽然暂时不影响程序的正确性，但最好还是规避这种情况。而且不带括号，会难以分清哪些是关键字哪些是方法调用。</p>
<p>　　还有一些警告是定义了变量没有使用，或者同一作用域内重复定义了相同的变量名。这些情况很可能是你在程序里有某些疏忽产生，所以警告信息非常有用。</p>
<p>　　在运行ruby时加上-w参数可以开启编译和运行时警告。或者直接设置环境变量RUBYOPT为-w。设置全局变量$VERBOSE为true开启运行时警告，为false关闭运行时警告。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h4><p>　　当调用方法时，会从该对象的继承体系中寻找该方法。由该对象的类开始，沿着继承链上溯。在继承体系中还有一个单例类的概念，相当于匿名类，当我们include模块时会生成一个单例类插入继承体系中。寻找方法时后include的模块先寻找，相当于以压栈的方式把模块一个个插进去。我们可以单独定义某个对象的方法，这个方法为这个对象所独有的，也会作为单例类的方法插入继承体系中。前面说到，类也是一个对象，因此类方法也是作为该类的的单例类方法插入继承体系中的。</p>
<p>　　当继承体系中找不到该方法时，就会从起点开始搜索method_missing方法。</p>
<h4 id="关于super"><a href="#关于super" class="headerlink" title="关于super"></a>关于super</h4><p>　　在子类中如果要调用基类重载的方法，就要用super关键字。如果调用时不加括号和参数，就会将子类的所有参数都传进基类方法中。如果基类方法不含参数，也要用空括号。</p>
<p>　　对于构造器方法也需要显式调用super来进行基类的初始化。</p>
<h4 id="getter与setter"><a href="#getter与setter" class="headerlink" title="getter与setter"></a>getter与setter</h4><p>　　Ruby允许我们在方法末尾使用3个特殊符号：?，!，=。?和!只是规范与美学上的需要，但=的作用就非常大了。假如在类内有一个@value的实例变量，通过定义两个方法value和value=便相当于定义了getter与setter方法。并且，在使用value=方法时，Ruby解析器允许我们在=两边加入空格，显得像是直接赋值语句一样。</p>
<p>　　Ruby解析器解析=时，只有当有显式的方法接收者，才会解析成setter方法的调用，否则当成普通的赋值语句。因此，如果在类内部调用setter方法需要加上self。getter方法则方便很多，Ruby解析器现在作用域内寻找是否有同名变量，如果没有则解析为方法调用。</p>
<h4 id="轻量化的类结构往往比哈希更好"><a href="#轻量化的类结构往往比哈希更好" class="headerlink" title="轻量化的类结构往往比哈希更好"></a>轻量化的类结构往往比哈希更好</h4><p>　　我们可能比较喜欢用哈希来实现结构化数据。但如果我们对数据的封装性有更高的需求，或者需要一些更像类的特性时，用Struct类往往是更好地选择。</p>
<p>　　通过Struct.new把返回值赋给一个常量，就可以像类一样使用这个常量，它有getter和setter方法，并且initialize方法能初始化每个属性的值。我们还可以传入一个block，里面定义一些类方法和实例方法。</p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>　　为了防止相同名字的类产生冲突，Ruby用module作为命名空间来隔离。我们知道，module也是一种常量，而Ruby寻找常量使用两种技术：当前词法作用域以及继承体系。如果在当前词法作用域内无法找到该常量，就会沿着继承体系寻找。因此，有时候常量需要加上module限定符。module可以视作顶级常量，所有顶级常量都会存在Object类中，因此可以通过继承体系寻找到该常量。可以用::来限定顶级常量。</p>
<p>　　让命名空间结构与目录结构一致。</p>
<p>　　这里补充一下，常量可以在继承体系中寻找，类变量也可以。但实例变量是不继承的。</p>
<h4 id="比较符"><a href="#比较符" class="headerlink" title="比较符"></a>比较符</h4><p>　　Ruby中所有运算符都是方法，例如==，&gt;，&lt;，&gt;=等等。首先从表示等价开始谈起。</p>
<p>　　Ruby表示等价有4种方法：</p>
<ol>
<li>equal?是比较是否是同一对象，具有相同的object_id才为真。</li>
<li>==的默认实现与equal?相同，但我们一般用它来表示对象实际的值相等。基本类型的==实现往往有隐含的类型转换，我们自己重载的话可以考虑是否实现转换。</li>
<li>eql?的默认行为也是和equal?一样，一般用来比较哈希的键是否相同。如果你定义的类有可能作为哈希的键，那么就要实现这个方法，同时还要实现hash方法。在比较两个对象是否表示相同键时，先比较它们的hash方法返回值是否相等，如果相等在比较eql?的返回值。我们在重载这两个方法时，往往是用实例变量或基本类型的这两个方法来代理实现。</li>
<li>===的默认实现是传给==。case语句相当于让每个when语句的操作数作为调用者调用===方法。Regexp定义了===函数，如果正则表达式与字符串参数匹配成功，则返回真。类和模块也定义了类方法版本的===操作符，如果右操作数是左操作数的一个实例，也返回真。如果我们有必要考虑自己定义的类对象用在case语句里的when语句，那么可以考虑重载===。</li>
</ol>
<p>　　与==不同，其他比较符没有默认的继承。但&lt;=&gt;会从Object默认继承，只是没有按我们要求实现而已。我们需要当接收者和参数的比较没有意义时返回nil；接收者较小时，返回-1；较大时返回1；相等时返回0。在重载了&lt;=&gt;以后，通过引入Comparable模块，我们就实现了各种比较操作符的重载，我们一般用这种方法来实现重载比较符，包括==。如果我们需要让==额外包含类型转换功能，可以自己再手动重载。</p>
<p>　　Array的sort方法实际上用到了&lt;=&gt;。</p>
<p>　　这些重载一般是让类里的实例变量来代理实现的。</p>
<h4 id="protected方法"><a href="#protected方法" class="headerlink" title="protected方法"></a>protected方法</h4><p>　　Ruby里子类可以继承父类的私有方法，protected方法的用处是便于同类或有同一超类的两个对象共享私有状态用的。</p>
<h4 id="优先使用类实例变量"><a href="#优先使用类实例变量" class="headerlink" title="优先使用类实例变量"></a>优先使用类实例变量</h4><p>　　我们可能考虑用类变量来实现单例模式。但类变量是与类绑定在一起的，超类中的类变量会被所有子类共享，任何这些类的实例变量都可以改变类变量。所以我们应该用类实例变量来代替。类也是对象，在类级别定义的和在类方法下定义的叫做类实例变量。它们的访问权限与一般对象的实例变量一样，也当然不会被子类继承。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="复制作为参数的集合"><a href="#复制作为参数的集合" class="headerlink" title="复制作为参数的集合"></a>复制作为参数的集合</h4><p>　　Ruby的对象作为参数传递进方法是采用引用传递的方式，这与Java是一样的。意味着改变传入的参数也会同时改变原对象。建议在不想改变原对象时用dup或clone方法进行复制。其中clone方法有两点不同于dup方法，一是复制时不改变冻结性，二是如果存在单例方法也会复制单例类。所以一般dup方法用得更多。</p>
<p>　　但是，如果对集合对象进行复制，只是浅复制，如果改变集合里的元素，仍然会影响原集合里的元素。如果是自己实现的类，可以重写initialize_copy方法，但如果是已有的集合类，则只能用Marshal来对集合进行序列化和反序列化来复制。但这样消耗的内存会更多，而且有些对象是无法序列化的。</p>
<h4 id="用Array方法将函数参数转换成数组"><a href="#用Array方法将函数参数转换成数组" class="headerlink" title="用Array方法将函数参数转换成数组"></a>用Array方法将函数参数转换成数组</h4><p>　　由于Ruby变量不显示指定类型，在传入方法时有时候跟预期不一样。例如希望传入一个数组，但只传入一个变量或者nil。这时候，可以调用Array方法将参数转换成数组。nil将转换成nil，单个变量将转换成只含它本身的数组，原本是数组则简单地转发出去。</p>
<h4 id="使用集合类"><a href="#使用集合类" class="headerlink" title="使用集合类"></a>使用集合类</h4><p>　　高效地查找数据我们倾向于使用哈希而非数组。但如果我们的需求仅仅是判断容器内是否包含某元素，哈希的功能显得有点冗余了，而且由数组转换成哈希时不够美观。Set类可以满足我们的需求。它的内部是用哈希实现的，可以传入一个数组来直接用Set.new来初始化，形式较简洁。之后就可以用include?方法来判断是否包含某元素了。</p>
<p>　　但如果查找的次数极少，相对于初始化来说几乎次数差不多，那么用Set或哈希其实时间上优化不是很明显，因为初始化仍然需要把原数组遍历一遍。</p>
<p>　　使用Set需要显式require，因为它在Ruby标准库而不是核心库中。</p>
<p>　　插入Set的对象当做哈希的键，因此如果要保存的是自定义的类，之前的eql?和hash方法在这里也能应用得上。</p>
<h4 id="reduce方法"><a href="#reduce方法" class="headerlink" title="reduce方法"></a>reduce方法</h4><p>　　集合的reduce方法非常好用，它接受一个初始值和一个block作为参数。它会遍历集合，对每一个元素调用block，并且block里有一个累加器参数。这个累加器参数会保留上一次块调用的返回值，第一次调用的话则是reduce方法传入的初始值参数。</p>
<p>　　reduce方法允许省略初始值参数，这时会使用集合的第一个元素作为初始值而从第二个元素开始遍历。如果原始集合为空则会返回nil。所以最好都要带上初始值。并且要记住block的返回。</p>
<p>　　很多涉及集合的操作都可以用reduce重构，会使代码更简练。</p>
<h4 id="考虑使用哈希的默认值"><a href="#考虑使用哈希的默认值" class="headerlink" title="考虑使用哈希的默认值"></a>考虑使用哈希的默认值</h4><p>　　可以用Hash.new方法传入一个参数作为默认值，当访问不存在的键时会返回默认值，并且不会修改哈希对象。但是如果默认值是可修改的，例如数组，那么很可能会修改默认值，造成很多错误。建议传入的参数是一个块，它的返回值会作为默认值，并且不会修改默认值。但用块的话访问一个不存在的键会将这个键存入哈希。</p>
<p>　　正确检查一个哈希是否包含某个键使用has_key?方法。因为设置了默认值的哈希不会返回nil，不能用hash[key]的返回值来判断。这时候设置默认值需要十分谨慎。用Hash#fetch方法会更加安全。</p>
<h4 id="使用代理而不是继承"><a href="#使用代理而不是继承" class="headerlink" title="使用代理而不是继承"></a>使用代理而不是继承</h4><p>　　我们可能想要实现一个改良版的集合类或者其他核心类，这时候应该优先使用代理，这可以给我们带来更大的灵活性。通过require(‘forwardable’)并且继承Forwardable类，我们可以使用def_delegators方法实现代理。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="使用定制的异常"><a href="#使用定制的异常" class="headerlink" title="使用定制的异常"></a>使用定制的异常</h4><p>　　当raise直接传字符串时，抛出RuntimeError，这个异常有点表意不明，推荐使用其他特定的异常类或者自定义的异常类作为参数传给raise。这样能抛出更有用的信息。自定义异常类需要继承StandardError，并且类名要以Error结尾。</p>
<p>　　如果自定义的异常类重写了initialize方法，需要确保其调用了super方法，最好以错误信息作为参数。在initialize方法中再次设置错误信息，会覆盖在initialize中设置的。</p>
<p>　　raise方法可以传入类对象或者实例对象作为参数，这两种方法没有什么不同。</p>
<h4 id="捕获具体的异常"><a href="#捕获具体的异常" class="headerlink" title="捕获具体的异常"></a>捕获具体的异常</h4><p>　　以白名单法捕获异常，即捕获知道怎么处理的异常，尽量不捕获不知道如何处理的异常。如果在rescue中又抛出了另一个异常，此时会离开原来的作用域，前一个异常信息会被丢弃，新异常会被抛出。可以在rescue中执行一个特殊方法，以异常对象作为参数，在方法中执行rescue，把原异常抛出。</p>
<h4 id="通过块和ensure管理资源"><a href="#通过块和ensure管理资源" class="headerlink" title="通过块和ensure管理资源"></a>通过块和ensure管理资源</h4><p>　　ensure用来执行异常处理后的清理工作，但如果处处都有ensure就显得比较笨重，我们可以进行一下封装。将一个块与类方法绑定起来，在这个方法里调用块，并且执行一些清理工作。在方法里还可以用block_given?来判断是否传入块，用这种方法使得清理工作变得非常灵活且自动化。</p>
<h4 id="不在ensure里使用return"><a href="#不在ensure里使用return" class="headerlink" title="不在ensure里使用return"></a>不在ensure里使用return</h4><p>　　在rescue里使用return会忽略掉所有StandardError异常，在ensure里使用return会忽略掉所有异常，必须避免。ensure里使用next和break也会丢弃异常。</p>
<h4 id="限制retry的次数"><a href="#限制retry的次数" class="headerlink" title="限制retry的次数"></a>限制retry的次数</h4><p>　　如果需要在rescue里重试，可以使用retry关键字。避免可能无限重试，添加一个计数器来限制retry次数，并且等待一定的时间再重试。但延时有可能会加剧问题，可以用指数退避算法等方法来调整等待时间。</p>
<p>　　如果retry过程中又抛出了另一个异常，那么原始异常信息就会丢失。建议在日志里记录一下retry的信息。</p>
<h4 id="throw控制流程"><a href="#throw控制流程" class="headerlink" title="throw控制流程"></a>throw控制流程</h4><p>　　throw比raise更适合用来控制流程，可以搭配catch和throw来跳出作用域。但如果滥用，会使得调用栈十分复杂，应尽量用简单的办法来控制流程，例如方法调用和return，代替catch和throw。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简析Docker的存储策略与网桥通信机制]]></title>
      <url>http://wjqwsp.github.io/2016/11/28/%E7%AE%80%E6%9E%90Docker%E7%9A%84%E5%AD%98%E5%82%A8%E7%AD%96%E7%95%A5%E4%B8%8E%E7%BD%91%E6%A1%A5%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　Docker作为容器是越来越被广泛使用了，里面的知识也比较庞杂，但关于Docker Engine最核心的就是存储和网络了。这篇文章主要围绕这两个方面，做一些简单的总结。<br><a id="more"></a></p>
<h3 id="Docker解决了什么"><a href="#Docker解决了什么" class="headerlink" title="Docker解决了什么"></a>Docker解决了什么</h3><p>　　做开发的时候，配环境总是最头疼的。需要安装各种程序，各种库，同时还要注意不让不同的应用之间互相影响，例如文件覆盖，配置信息冲突等等。我们需要的是让某个特定方向的开发环境或部署环境单独运行在一个独立的环境里，最奢侈的情况就是一台机器只跑一个应用。例如某Java Web应用的开发环境，或者某Ruby应用的部署环境，等等，统统放在不同的实体机里。</p>
<p>　　在实际生产环境中我们也许是可以这么干的，但如果我们的产品还在测试阶段呢？虚拟机或许是一种解决办法。但一个虚拟机跑一个应用总觉得这个系统太重了，资源有点浪费。于是，我们开始寻求一种轻量级的隔离机制，Docker便应运而生了。</p>
<p>　　Docker作为轻量级的容器，能够把一个个安装有特定库和依赖，运行特定应用的环境相互隔离，同时相比虚拟机能更充分地使用硬件资源，在许多场合里往往是不二法门。</p>
<h3 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h3><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>　　Docker的存储内容非常多，这篇文章涉及的只是很少的一部分，但都比较核心和重要。为了讲清楚这一套概念，我们得先从镜像谈起。</p>
<p>　　Docker里的镜像与我们安装系统的镜像，或者虚拟机的镜像类似。我们可以根据这个镜像，安装或者恢复出整个操作系统。不一样的是，Docker的镜像不只是操作系统镜像。我们可以在某操作系统的基础上安装某些库或者应用程序，然后再创建出一个特定的镜像。例如java镜像（安装了Java虚拟机），tomcat镜像（安装了Java虚拟机和Tomcat），postgres镜像（安装了postgres数据库及其各种依赖）等等。</p>
<p>　　Docker官方制作了一批镜像，同时很多软件公司或者互联网公司都发布了很多官方镜像，任何注册了的开发者也都可以制作自己的镜像。这些镜像都放在Docker Hub里，我们可以在上面挑选我们需要的镜像作为我们容器的基础镜像，或者以这个镜像为基础制作自己的镜像。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>　　我们使用Docker，就是建立各种容器，容器里面运行不同的镜像。我们可以用Docker运行任何镜像，Docker会为我们生成容器，即一个个相互隔离的干净的文件系统。容器相当于一个轻量级的虚拟机。</p>
<h4 id="镜像层"><a href="#镜像层" class="headerlink" title="镜像层"></a>镜像层</h4><p>　　镜像是用层来划分与存储的。上面所说的镜像由一层一层的镜像层以栈的方式堆积起来的。Docker制作镜像是由Dockerfile这个文件来控制生成的，下面是这个文件的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FROM docker/whalesay:latest</div><div class="line">RUN apt-get -y update &amp;&amp; apt-get install -y fortunes</div><div class="line">CMD /usr/games/fortune -a | cowsay</div></pre></td></tr></table></figure>
<p>　　这个镜像大概的意思是由docker/whalesay最新版为基础镜像建立，更新apt-get并且安装fortunes这个应用程序。CMD这一行是指定运行这个镜像时默认会执行的指令，这里的意思是运行fortune这个应用并且把输出传给cowsay这个应用。</p>
<p>　　基础镜像可能包含有一层或多层镜像层，后面的每行指令都会对镜像产生的文件系统有影响，都会产生一层image layer。</p>
<p>　　每一个镜像层都默认使用缓存，即如果系统中如果已经运行过这个Dockerfile,产生了这几层镜像层，那么重新运行的话不会产生新的镜像层，而是会使用旧的镜像层来创建镜像。</p>
<p>　　我们运行起来的容器，也会在原有镜像的基础上新建一个新的镜像层，所有对文件系统的改变都会写到这个镜像层里。</p>
<h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>　　由上所述，docker的存储是由镜像层组成的。它的存储策略使用docker存储驱动来实现的，具体的驱动有很多种，其具体实现也各不相同，但其思想是统一的，就是写时复制策略。</p>
<p>　　我们可以用同一个镜像运行多个容器。当容器运行时，它会复用该镜像的所有镜像层，而不会另外复制这些镜像层。这些源自镜像的镜像层都是只读的，不能被修改。除了这些被复用的镜像层以外，容器还会生成一层薄的，空的镜像层，这个是每个容器专有的镜像层，是可读写的，所有对容器文件系统的更改都会写到这个容器镜像层内。</p>
<p>　　所谓的写时复制，即当用docker修改文件时，会把该文件从原镜像的某个镜像层里读出，复制一份到容器镜像层里；当创建新文件时，直接写在容器镜像层上；当读取文件时，则不会发生复制动作。</p>
<p>　　这种策略可以让多次建立的容器充分利用原镜像的文件，而不用在启动时耗费时间去做大量的复制动作，又极大地节省了存储空间，只有在发生写操作时才做复制。</p>
<h4 id="Device-Mapper-存储驱动"><a href="#Device-Mapper-存储驱动" class="headerlink" title="Device Mapper 存储驱动"></a>Device Mapper 存储驱动</h4><p>　　host主机使用不同的操作系统，其docker的存储驱动也可能有所不同。下面以centos操作系统里docker较常用的device mapper存储驱动为例，介绍一下它具体是怎么实现写时复制策略的。</p>
<p>　　device mapper会首先创建一个pool，这个pool是从raw block或者稀疏文件上建立起来的，负责发生写操作时分配存储空间。device mapper的写时复制是针对block进行，而不是对文件。</p>
<p>　　在这个pool上面，docker创建一个base device，这相当于一个空的文件系统，所有镜像层都是在这个base device的基础上打快照再进行新的改动而生成的。</p>
<p>　　base device上面就是一层一层的镜像层。</p>
<p>　　发生读操作时，由于container最上层的容器镜像层并不实际存储镜像的文件，但会维护所有block的指针，让读操作可以定位到下面某个镜像层的某个block中，从而读出真实数据。</p>
<p>　　发生写操作时，利用最底层的pool以block为单位分配空间，每个block为64kb。当写操作的内容小于64kb，也必须分配一整个block。写操作会写在容器镜像层中，以后读取就直接在容器镜像层上读。</p>
<h4 id="数据卷与挂载"><a href="#数据卷与挂载" class="headerlink" title="数据卷与挂载"></a>数据卷与挂载</h4><p>　　由存储驱动管理的docker存储空间一般是定在host主机的/var/lib/docker/…里的，读写操作都是由存储驱动负责。当容器删除时，新建的容器镜像层也会被删除。而且，对容器镜像层进行大量的写操作会不断地搜索镜像层以及进行复制，性能上也不是很理想。</p>
<p>　　为了解决大量数据写操作以及数据的持久化存储与共享，docker提供了挂载数据卷的服务。</p>
<p>　　挂载数据卷实际上是以host主机的某个文件或某个目录为挂载点，与docker容器的某个文件或目录挂载起来，使得数据在host主机和docker容器里可以共享与同步。</p>
<p>　　这种数据卷的存储是独立于镜像层以及存储驱动的，其读写是由host主机直接实现的。具体的用法可以参考官网。</p>
<h3 id="网桥驱动"><a href="#网桥驱动" class="headerlink" title="网桥驱动"></a>网桥驱动</h3><p>　　docker容器默认的网络连接方式就是网桥。在默认情况下，所有运行的容器都属于172.17.0.1/16这个网络内。我们也可以借助网桥驱动创建自己的网络，以此来划分不同的网络来隔离不同的容器。容器与容器的通信方式一般有两种，一种是host主机端口映射，另一种是docker link。</p>
<h4 id="host主机端口映射"><a href="#host主机端口映射" class="headerlink" title="host主机端口映射"></a>host主机端口映射</h4><p>　　docker容器如果不做端口映射，外网是不能访问它的，但它可以通过masquerade的方式来借助host主机访问外网。如果要作为服务器，则需要让容器的某个端口与host主机的某个端口绑定在一起，以DNAT的方式来与外网通信，那么外网就可以访问docker容器了。</p>
<p>　　不同的容器也可以借助host主机的端口来相互通信。</p>
<h4 id="docker-link"><a href="#docker-link" class="headerlink" title="docker link"></a>docker link</h4><p>　　有时候我们希望让容器之间能通过容器名来访问彼此，docker link就可以帮我们实现。当我们建立了docker link，实际上会从环境变量和/etc/hosts两个部分来修改连接的容器，使得容器之间能通过环境变量和/etc/hosts文件两个部分建立联系信息，帮助他们借助容器名来进行通信。具体的用法可以查看官网。</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gitlab CI 与 Docker 的配置与整合流程]]></title>
      <url>http://wjqwsp.github.io/2016/11/23/Gitlab-CI-%E4%B8%8E-Docker-%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%95%B4%E5%90%88%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="什么是Gitlab-CI"><a href="#什么是Gitlab-CI" class="headerlink" title="什么是Gitlab CI"></a>什么是Gitlab CI</h3><p>　　Gitlab CI是一个持续集成的工具，目前已经与Gitlab完美整合在一起。它提供一个虚拟的代码测试、打包的环境，这个环境与Gitlab Repo勾连在一起，让每一次的push或者merge request触发这个虚拟环境的创建，自动运行测试与打包的脚本，得出脚本的运行结果呈现在Gitlab 的web页面上，然后再销毁这个虚拟的环境。并且，它能与我们的真正的产品部署环境连接起来，让我们能在Gitlab的web页面上看到部署环境的一些结果，让整个代码的生产线变得完整。通过Gitlab CI与Gitlab的整合，源代码开发、自动测试、自动打包、自动部署成为一条流水线，能极大地加快产品的迭代速度。<br><a id="more"></a></p>
<h3 id="Gitlab-Runner-与-Docker"><a href="#Gitlab-Runner-与-Docker" class="headerlink" title="Gitlab Runner 与 Docker"></a>Gitlab Runner 与 Docker</h3><p>　　Gitlab Runner是一个为我们创建上述Gitlab CI虚拟环境的一个程序，我们选择把这个程序所需的环境用Docker来安装，作为一个Docker Daemon Container来配置好Gitlab Runner运行的环境。每一个Gitlab project都可以注册一个或多个runner,这些runner就是负责跑我们上述的虚拟环境的，它们的注册，创建以及运行都是由Gitlab Runner这个程序来控制的。这些runner实际上都是docker container，由Gitlab Runner这个程序自动创建，它们与Gitlab Runner所处的container是同等关系而不是从属关系。使用docker来建立runner，使得每一个虚拟环境都干净、轻量，相互隔离，互不影响。</p>
<p>　　下面我主要讲一下在服务器上安装docker，通过docker安装Gitlab Runner，以及通过Gitlab Runner注册runner的步骤。</p>
<h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>　　第一步先要在服务器上把Docker装起来，服务器环境是Centos，安装流程非常简单，完全参照Docker官网即可：<a href="https://docs.docker.com/engine/installation/linux/centos/#/install-docker-engine" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/centos/#/install-docker-engine</a></p>
<p>　　这样安装好以后，每次运行docker指令都要加sudo，十分不方便，可以把用户加到docker group里面，便可以省去sudo了，参考：<a href="https://docs.docker.com/engine/installation/linux/centos/#/create-a-docker-group" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/centos/#/create-a-docker-group</a></p>
<h4 id="Gitlab-Runner的安装与注册"><a href="#Gitlab-Runner的安装与注册" class="headerlink" title="Gitlab Runner的安装与注册"></a>Gitlab Runner的安装与注册</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>　　我们用docker来配置一个container给Gitlab Runner程序运行。安装指令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d --name gitlab-runner --add-host gitlab.local:10.106.128.234 --restart always \</div><div class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</div><div class="line">  -v /srv/gitlab-runner/config:/etc/gitlab-runner \</div><div class="line">  gitlab/gitlab-runner:latest</div></pre></td></tr></table></figure>
<p>　　上述指令主要是根据gitlab/gitlab-runner这个docker镜像运行一个docker container，这个镜像里安装好了gitlab-runner这个程序来为我们创建测试用的虚拟环境。我们把这个container用–name参数命名为gitlab-runner。-v指令代表挂载，我们将host服务器主机的/var/run/docker.sock和/srv/gitlab-runner/config这两个文件或文件夹与gitlab-runner这个container内部的/var/run/docker.sock和/etc/gitlab-runner这两个文件或文件夹挂载在一起。/var/run/docker.sock是用来创建docker container的，都过挂载host的/var/run/docker.sock，使得gitlab-runner container可以利用host服务器的docker来创建container，而不需要使用docker-in-docker。/etc/gitlab-runner/里面则有一个config.toml文件，我们通过这个文件来设置一些runner的参数，挂载在host的/srv/gitlab-runner/config里使得我们可以通过修改host主机的这个文件来设置runner的参数。</p>
<p>　　还有一个比较重要的参数是–add-host。这个参数在Gitlab CI官网上是找不到的，但对于我们是必须的。因为gitlab.local是一个内网的gitlab服务器，不能通过公共的DNS来查找到，这个参数会把gitlab.local加到gitlab-runner container的host文件里。这个是docker提供的一个参数，当然我想如果host服务器的host文件里如果有gitlab.local的信息，通过上面说的挂载host主机上的/etc/hosts的方法也可以实现我们的需求。所以，如果gitlab服务器建在内网（我觉得是大多数情况），都需要通过这种方法解决。</p>
<h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><p>　　下面是为我们需要测试的Gitlab项目注册runner：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">docker exec -it gitlab-runner gitlab-runner register</div><div class="line"></div><div class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</div><div class="line">https://gitlab.com</div><div class="line">Please enter the gitlab-ci token for this runner</div><div class="line">xxx</div><div class="line">Please enter the gitlab-ci description for this runner</div><div class="line">my-runner</div><div class="line">INFO[0034] fcf5c619 Registering runner... succeeded</div><div class="line">Please enter the executor: shell, docker, docker-ssh, ssh?</div><div class="line">docker</div><div class="line">Please enter the Docker image (eg. ruby:2.1):</div><div class="line">ruby:2.1</div><div class="line">INFO[0037] Runner registered successfully. Feel free to start it, but if it&apos;s</div><div class="line">running already the config should be automatically reloaded!</div></pre></td></tr></table></figure>
<p>　　其中url填写gitlab服务器的域名，gitlab-ci token是每个project特有的，填写你需要测试的project的token即可。关于runner的更详尽的信息可以参照：<a href="https://docs.gitlab.com/ce/ci/runners/README.html" target="_blank" rel="external">https://docs.gitlab.com/ce/ci/runners/README.html</a></p>
<p>　　注册成功以后，我们还需要修改一个配置。因为我们执行测试的runner本身是一个docker container，执行测试时候runner需要从gitlab服务器里fetch gitlab repo,所以我们也需要确保它们也可以对gitlab.local这个域名进行解析。它们的配置信息通过挂载可以在host服务器主机的/srv/gitlab-runner/config/config.toml里查看和修改，下面是一个runner的配置例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[[runners]]</div><div class="line">  name = "simple uasg"</div><div class="line">  url = "http://gitlab.local/ci"</div><div class="line">  token = "f37c2425b506aeb658e91eea4219f4"</div><div class="line">  executor = "docker"</div><div class="line">  [runners.docker]</div><div class="line">    tls_verify = false</div><div class="line">    image = "centos:6.8"</div><div class="line">    privileged = false</div><div class="line">    disable_cache = false</div><div class="line">    volumes = ["/cache"]</div><div class="line">    extra_hosts = ["gitlab.local:10.106.128.234"]</div><div class="line">  [runners.cache]</div></pre></td></tr></table></figure>
<p>　　这段配置信息除了extra_hosts这一项，其他都是注册成功后自动生成的。我们需要加上extra_hosts来确保gitlab.local可以得到正确的解析。</p>
<h3 id="简述-gitlab-ci-yml"><a href="#简述-gitlab-ci-yml" class="headerlink" title="简述.gitlab-ci.yml"></a>简述.gitlab-ci.yml</h3><p>　　最后简述一下.gitlab-ci.yml这个文件。</p>
<p>　　当我们把代码push到gitlab上，或者提交了merge request，会自动触发gitlab ci进行测试。gitlab ci控制测试是通过project repo里面根目录的.gitlab-ci.yml这个文件来进行的，开发者在开发的同时也需要撰写这个文件并放到到repo的根目录下，才能触发自动测试。</p>
<p>　　下面以一个我自己开发的仿微博的java web项目的.gitlab-ci.yml为例，简单说明一下整个结构，可以对照这个文件来看。下面附上代码：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="attr">image:</span> java:<span class="number">8</span></div><div class="line"></div><div class="line"><span class="attr">services:</span></div><div class="line"><span class="attr">  - postgres:</span><span class="number">9.5</span></div><div class="line"></div><div class="line"><span class="attr">stages:</span></div><div class="line"><span class="bullet">  -</span> build</div><div class="line"><span class="bullet">  -</span> test</div><div class="line"><span class="bullet">  -</span> package</div><div class="line"><span class="bullet">  -</span> deploy</div><div class="line"></div><div class="line"><span class="attr">variables:</span></div><div class="line"><span class="attr">  POSTGRES_DB:</span> weibo</div><div class="line"><span class="attr">  POSTGRES_USER:</span> postgres</div><div class="line"><span class="attr">  POSTGRES_PASSWORD:</span> <span class="string">"gdzqzxwjs95"</span></div><div class="line"></div><div class="line"><span class="attr">compile:</span>    </div><div class="line"><span class="attr">  stage:</span> build</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> mkdir classes</div><div class="line"><span class="bullet">    -</span> javac -d classes -cp <span class="string">"web/WEB-INF/lib/*:classes"</span> src/weibo/tool/*</div><div class="line"><span class="bullet">    -</span> javac -d classes -cp <span class="string">"web/WEB-INF/lib/*:classes"</span> src/weibo/filter/*</div><div class="line"><span class="bullet">    -</span> javac -d classes -cp <span class="string">"web/WEB-INF/lib/*:classes"</span> src/weibo/servlet/*</div><div class="line"><span class="attr">  artifacts:</span></div><div class="line"><span class="attr">    name:</span> classes-files</div><div class="line"><span class="attr">    paths:</span></div><div class="line"><span class="bullet">    -</span> classes/</div><div class="line"></div><div class="line"><span class="attr">connect:</span></div><div class="line"><span class="attr">  stage:</span> test</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> apt-get update &amp;&amp; apt-get install -y postgresql-client</div><div class="line"><span class="bullet">    -</span> export PGPASSWORD=$POSTGRES_PASSWORD</div><div class="line"><span class="bullet">    -</span> psql -h <span class="string">"postgres"</span> -U <span class="string">"$POSTGRES_USER"</span> -d <span class="string">"$POSTGRES_DB"</span> -f database/status.sql</div><div class="line"><span class="bullet">    -</span> psql -h <span class="string">"postgres"</span> -U <span class="string">"$POSTGRES_USER"</span> -d <span class="string">"$POSTGRES_DB"</span> -f database/subscriber.sql</div><div class="line"><span class="bullet">    -</span> psql -h <span class="string">"postgres"</span> -U <span class="string">"$POSTGRES_USER"</span> -d <span class="string">"$POSTGRES_DB"</span> -f database/the_insertion_of_status.sql</div><div class="line"><span class="bullet">    -</span> java -cp <span class="string">"classes:web/WEB-INF/lib/*"</span> org.junit.runner.JUnitCore weibo.servlet.SignUpAndLoginTest</div><div class="line"></div><div class="line"><span class="attr">package:</span></div><div class="line"><span class="attr">  stage:</span> package</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> cp -r classes web/WEB-INF/classes</div><div class="line"><span class="bullet">    -</span> cd web</div><div class="line"><span class="bullet">    -</span> jar -cvf weibo.war *</div><div class="line"><span class="bullet">    -</span> cd ../</div><div class="line"><span class="bullet">    -</span> mkdir binaries</div><div class="line"><span class="bullet">    -</span> cp web/weibo.war binaries/</div><div class="line"><span class="attr">  artifacts:</span></div><div class="line"><span class="attr">    name:</span> weibo-war</div><div class="line"><span class="attr">    paths:</span></div><div class="line"><span class="bullet">    -</span> binaries/</div><div class="line"></div><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  image:</span> tomcat:<span class="number">7</span></div><div class="line"><span class="attr">  stage:</span> deploy</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> cp binaries/weibo.war /usr/local/tomcat/webapps</div><div class="line"><span class="bullet">    -</span> apt-get update &amp;&amp; apt-get install -y postgresql-client</div><div class="line"><span class="bullet">    -</span> export PGPASSWORD=$POSTGRES_PASSWORD</div><div class="line"><span class="bullet">    -</span> psql -h <span class="string">"postgres"</span> -U <span class="string">"$POSTGRES_USER"</span> -d <span class="string">"$POSTGRES_DB"</span> -f database/status.sql</div><div class="line"><span class="bullet">    -</span> psql -h <span class="string">"postgres"</span> -U <span class="string">"$POSTGRES_USER"</span> -d <span class="string">"$POSTGRES_DB"</span> -f database/subscriber.sql</div><div class="line"><span class="bullet">    -</span> psql -h <span class="string">"postgres"</span> -U <span class="string">"$POSTGRES_USER"</span> -d <span class="string">"$POSTGRES_DB"</span> -f database/the_insertion_of_status.sql</div><div class="line"><span class="bullet">    -</span> wget -P /opt/ http://www.gtlib.gatech.edu/pub/apache//jmeter/binaries/apache-jmeter<span class="bullet">-3.0</span>.tgz</div><div class="line"><span class="bullet">    -</span> cp test\ plan/simple-test.jmx /tmp/</div><div class="line"><span class="bullet">    -</span> cd /opt</div><div class="line"><span class="bullet">    -</span> tar -zxvf apache-jmeter<span class="bullet">-3.0</span>.tgz</div><div class="line"><span class="bullet">    -</span> catalina.sh start</div><div class="line"><span class="bullet">    -</span> sleep <span class="number">30</span></div><div class="line"><span class="bullet">    -</span> cd /opt/apache-jmeter<span class="bullet">-3.0</span>/bin</div><div class="line"><span class="bullet">    -</span> ./jmeter -n -t /tmp/simple-test.jmx -l report.xml</div><div class="line"><span class="bullet">    -</span> cat report.xml</div></pre></td></tr></table></figure>
<h4 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h4><ul>
<li><p>image代表虚拟环境的基础镜像，这个镜像是docker镜像，我们可以根据项目需求在docker hub里挑选想要的镜像，作为基础的环境。因为weibo项目是用java开发的，因此这里选了java:8这个镜像。</p>
</li>
<li><p>services也是一些镜像，它们和我们主要的这个虚拟测试环境是同等的，都运行在一个独立的docker container中。这些service其实主要是用来运行数据库的，它们与主测试环境，即这里的java:8镜像建立的container，是通过docker link建立通信的。</p>
</li>
<li><p>variables是一些gitlab ci的变量，通过它们可以配置一些测试需要用到的参数，相当于是docker内的环境变量，并且可以给services共享。这里主要是配置postgres的用户，密码以及数据库，根据我们项目需求配置即可。后面我们就可以用这些参数来连接service了。这些参数的名字一般docker hub的image介绍里都会提及，我们可以根据具体的应用去查阅，看看我们需要用到哪些参数，极大地方便了我们的配置。</p>
</li>
<li><p>stage是测试的阶段，是人为划分的，只有在上一个stage正确通过以后才会运行后面的测试。</p>
</li>
<li><p>compile,connect,package,deploy都是job的名字，每个job都是独立运行在一个干净的docker container里面的，在运行结束时候自动销毁环境。其中同一个stage的job可以并行运行。每个job必须含有script，里面写我们执行测试的脚本即可。</p>
</li>
<li><p>artifacts保存我们需要在job和stage间共享的文件，如果测试成功，这些文件同时可以在gitlab的web页面上下载。</p>
</li>
</ul>
<h4 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h4><ol>
<li>compile这个job主要用javac这个指令来把.java源文件编译成.class文件，这些.class文件放在artifacts里给下一个stage使用。</li>
<li>connect这个job是进行单元测试的，我们要先下一个postgres的客户端去连接postgres这个service，进行一些数据库的初始化工作，再用junit这个库运行单元测试文件。</li>
<li>package这个job是把weibo这个工程打成war包，放在artifacts里给后面测试部署环境使用。</li>
<li>deploy这个job是基于tomcat:7这个基础镜像的，我们把上面的war包部署在tomcat里，把tomcat启动起来，然后下载安装jmeter来进行压力测试，并在屏幕上打印测试结果。</li>
</ol>
<p>　　其实.gitlab-ci.yml还有很多配置的知识，上面所述只不过冰山一角，要针对自己的项目编写这个文件，必须阅读gitlab ci的文档。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java的解释执行过程及Tomcat部署]]></title>
      <url>http://wjqwsp.github.io/2016/11/20/java%E7%9A%84%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%8F%8ATomcat%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　最近做Gitlab CI的自动测试方面的工作，用简单的Java工程来做测试，在学习Gitlab CI和Docker的过程中又回顾了一下Java的编译，解释，执行的过程。以前做Java的项目多是借助IDE，有种感觉就是离开IDE就不会做Java开发了。这次因为Docker自动测试无法使用IDE，被迫回顾了一下如何用命令行去运行Java程序，以及如何部署在Tomcat上，挺有意义的。<br><a id="more"></a></p>
<h3 id="编译成-class文件"><a href="#编译成-class文件" class="headerlink" title="编译成.class文件"></a>编译成.class文件</h3><p>　　严格来说Java不算纯粹的解释性语言，我觉得是介乎编译与解释性语言的一种。因为它在解释执行之前需要先编译成字节码。这种字节码就是.class文件。我们平常写的源代码都是.java文件，要执行它们，首先得编译成.class文件。</p>
<p>　　编译成字节码很简单，只需用javac指令。看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -d classes -cp &quot;web/WEB-INF/lib/*:classes&quot; src/weibo/servlet/*</div></pre></td></tr></table></figure>
<p>　　这行指令最核心的就是第一个词javac以及最后一个目录结构src/weibo/servlet/*。javac是编译成字节码的程序，最后面的目录结构下的文件就是待编译的.java文件。上例就是要把src/weibo/servlet/目录下的所有文件编译成字节码。我们还注意到，除了javac以及目标.java文件以外，中间还有一些参数。这些参数主要是用于提供.java文件里import的其他java类。</p>
<p>　　如果待编译的.java文件没有额外引用其他类，或者引用的只是java核心包里的类，中间的这些参数可以统统省掉。但如果用到其他类，则必须提供这些类的.class文件或者所属的jar包。jar包实际上是把一些.class文件打包成一个文件。</p>
<p>　　因此编译成.class文件也是有先后顺序的，必须先把待编译的类引入的其他类编译好。</p>
<p>　　我们来看一看中间的这些参数。-d后面跟的目录便是我们希望的编译好的.class文件存放的地方。-cp后面跟的参数指定classpath，即引入的.class文件或jar包的目录。如果有多个目录，则在linux系统下用:分隔，windows系统下用;分隔。</p>
<h3 id="解释执行-class文件"><a href="#解释执行-class文件" class="headerlink" title="解释执行.class文件"></a>解释执行.class文件</h3><p>　　很多人认为Java是解释性语言，就是因为它是在运行时边执行边用java虚拟机解释.class文件的字节码。多次运行同一段代码则需要多次解释，不像编译性语言一样预先编译成机器语言。解释执行.class文件只需用java指令。看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp &quot;classes:web/WEB-INF/lib/*&quot; org.junit.runner.JUnitCore weibo.servlet.SignUpAndLoginTest</div></pre></td></tr></table></figure>
<p>　　上例的意思是我们要用org.junit.runner.JunitCore这个类对weibo.servlet.SignUpAndLoginTest这个类进行单元测试。没有接触过单元测试的只需简单地理解为我们需要执行org.junit.runner.JunitCore这个类，同时需要传入参数，这个参数是weibo.servlet.SignUpAndLoginTest这个类。如果这些类的.class文件不在当前目录下，则需要用-cp指定它们所在的classpath。我们指定类必须完整写出package结构，package结构与目录结构是等同的，上例相当于我们要找的类分别是classes/weibo/servlet/SignUpAndLoginTest和web/WEB-INF/lib/junit-4.11.jar里的org/junit/runner/JunitCore。package目录结构必须与.class存放的目录结构一致。</p>
<h3 id="打成jar包"><a href="#打成jar包" class="headerlink" title="打成jar包"></a>打成jar包</h3><p>　　有时候我们需要将编译好的.class文件打包，便于迁移，管理与部署。打包很简单，用jar指令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jar -cvfe ../binaries/Server.jar buptchat.server.Server buptchat/server/*</div></pre></td></tr></table></figure>
<p>　　我们先指定打出来的包要放在哪个目录下，以及叫什么名字，上例则是存放在../binaries里的Server.jar。-e指令指定入口类，即运行jar包时执行的main方法所在的类，上例是bupt.server.Server，最后一个参数是指定那些文件需要被打包。</p>
<h3 id="Tomcat部署"><a href="#Tomcat部署" class="headerlink" title="Tomcat部署"></a>Tomcat部署</h3><p>　　Tomcat是一个java web container，核心功能是用于处理jsp以及servlet，以及内置了http服务器，拥有处理http请求和回应的功能。</p>
<h4 id="打成war包"><a href="#打成war包" class="headerlink" title="打成war包"></a>打成war包</h4><p>　　将开发好的java web程序部署在Tomcat上，最简单的方法是将其打成war包，然后扔在tomcat的webapps目录下，tomcat启动时候会自动将其解压，便可以访问里面的jsp和servlet了。</p>
<p>　　war包是有一定网络扩展功能的jar包。打成war包非常简单，与打jar包一样，都是用jar指令。如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jar -cvf weibo.war *</div></pre></td></tr></table></figure>
<p>　　将当前目录及其子目录的所有文件打成weibo.war这个包，并存放在当前目录下。</p>
<h3 id="war包内的目录结构"><a href="#war包内的目录结构" class="headerlink" title="war包内的目录结构"></a>war包内的目录结构</h3><p>　　工程目录必须满足一定的目录结构。根目录一般放jsp和一些资源文件，例如css和javascript文件。也可以把jsp文件放在某个目录内。根目录下有一个固定的WEB-INF目录，里面有web.xml文件，主要是首页和servlet以及filter的一些映射配置。</p>
<p>　　一般我们还需要在WEB-INF目录下建两个文件夹，分别是lib和classes，存放服务器要用到的java字节码。lib放jar包，classes放编译好的.class文件。</p>
<p>　　只要满足这个目录结构，Tomcat便知道怎么用我们这个工程了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gitlab扩展--开发，打包，部署配置指南及注意事项]]></title>
      <url>http://wjqwsp.github.io/2016/11/02/Gitlab%E6%89%A9%E5%B1%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="Gitlab扩展"><a href="#Gitlab扩展" class="headerlink" title="Gitlab扩展"></a>Gitlab扩展</h3><p>　　Gitlab扩展即对官方的Gitlab源代码进行二次开发，在原有Gitlab的基础上定制属于自己的项目与代码管理的工具。Gitlab是开源项目，其源代码在官网上可以查阅，我们一般使用的是免费的Gitlab社区版，即Gitlab-CE。下面将从开发，打包，部署三个部分谈谈从源代码到部署成自己的应用是一个怎么样的流程，整个环境的搭建需要注意些什么。<br><a id="more"></a></p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>　　一般来说只要把Gitlab-CE的代码仓库clone到本地，就可以在上面修改代码了。这个是Gitlab-CE的地址：<a href="https://gitlab.com/gitlab-org/gitlab-ce/" target="_blank" rel="external">https://gitlab.com/gitlab-org/gitlab-ce/</a> 。但是，只有源代码是不能够直接在本地上跑起来的，整个开发环境还需要安装很多依赖，以及配置数据库。Gitlab为了方便开发者，提供了一个Gitlab开发工具Gitlab-Development-Kit，其地址是：<a href="https://gitlab.com/gitlab-org/gitlab-development-kit" target="_blank" rel="external">https://gitlab.com/gitlab-org/gitlab-development-kit</a> 。Gitlab-Development-Kit可以帮助开发者很方便地在本地搭建起开发环境，并且把Gitlab跑起来。它本身就有很详细的文档教你怎么使用，下面我就简单概括一下怎么利用Gitlab-Development-Kit搭建开发环境。</p>
<h4 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h4><p>　　理论上Gitlab-Development-Kit网站上列出的系统按照它的步骤都可以成功安装。但我试过在Centos 7下安装，官网上的例子只提供Centos 6.5，关于postgresql的一些下载地址都是有误的，需要自己修改一点目录，而且下下来的postgresql的库不全，导致后面安装Gitlab-Development-Kit时候有种种错误。再者它的依赖安装步骤除了列出的一些指令以外，还需要自己再装一些其他的依赖，感觉不够细致，很可能会产生环境错误。</p>
<p>　　相对而言，它对Ubuntu的支持就比较好了，首先安装指令简单，而且不需要额外操作。其他系统我没有试过。后面的步骤都是在Ubuntu 16.04上做的，我也推荐使用Ubuntu作为开发环境。</p>
<h4 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h4><p>　　就是跟着这篇guideline做：<a href="https://gitlab.com/gitlab-org/gitlab-development-kit/blob/master/doc/prepare.md" target="_blank" rel="external">https://gitlab.com/gitlab-org/gitlab-development-kit/blob/master/doc/prepare.md</a> 。下面是我的步骤整理，对照着官网的看。</p>
<h5 id="利用RVM安装Ruby"><a href="#利用RVM安装Ruby" class="headerlink" title="利用RVM安装Ruby"></a>利用RVM安装Ruby</h5><p>　　Gitlab的源代码是用Ruby on Rails写的，因此先要安装Ruby以及RubyGem。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3</div><div class="line">$ \curl -sSL https://get.rvm.io | bash -s stable</div><div class="line">$ source ~/.bashrc</div><div class="line">$ source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>　　上面这些就可以把Ruby版本管理工具RVM安装好了。</p>
<p>　　安装Ruby（Gitlab-Development-Kit要求2.3.1或更高版本）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvm install 2.3.1</div></pre></td></tr></table></figure>
<p>　　使用Ruby：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvm use 2.3.1</div></pre></td></tr></table></figure>
<p>　　验证是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -v</div></pre></td></tr></table></figure>
<h5 id="安装Bundler"><a href="#安装Bundler" class="headerlink" title="安装Bundler"></a>安装Bundler</h5><p>　　gem是Ruby的包管理工具，Rails框架就是一个gem包，Bundler是用于自动安装Rails项目所需要的gem包的一个工具，其本身也是一个gem包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install bundler</div></pre></td></tr></table></figure>
<h5 id="Ubuntu系统上的依赖安装"><a href="#Ubuntu系统上的依赖安装" class="headerlink" title="Ubuntu系统上的依赖安装"></a>Ubuntu系统上的依赖安装</h5><p>　　按照官网的指令一步步做就行，可能会在这一步有点问题：npm install phantomjs-prebuilt@2.1.12 -g ，提示你找不到npm指令。这时候只要手动安装npm就行：sudo apt-get install npm 。应该都没什么太大问题，这些步骤主要为了安装Gitlab项目用到的一些非gem依赖，大多是gem包要用到的系统软件依赖。</p>
<h4 id="正式安装Gitlab-Development-Kit"><a href="#正式安装Gitlab-Development-Kit" class="headerlink" title="正式安装Gitlab-Development-Kit"></a>正式安装Gitlab-Development-Kit</h4><p>　　跟着这篇文档做就行：<a href="https://gitlab.com/gitlab-org/gitlab-development-kit/blob/master/doc/set-up-gdk.md" target="_blank" rel="external">https://gitlab.com/gitlab-org/gitlab-development-kit/blob/master/doc/set-up-gdk.md</a> 。需要注意是建议不要直接把官网的Gitlab-CE工程clone下来，而是先把源代码fork一份到自己的账户里，再把自己的这个项目clone下来。我觉得Gitlab-Development-Kit这个项目主要是帮助你管理Rails应用和数据库配置的，预先把Gitlab要用到的数据库配置好，并且把Gitlab项目依赖的一些其他Git项目clone下来，例如：Gitlab-Shell和Gitlab-workhorse。</p>
<p>　　安装成功后运行gdk run就可以把Gitlab启起来了，用本机浏览器可以访问localhost:3000。</p>
<h4 id="源代码的update与push"><a href="#源代码的update与push" class="headerlink" title="源代码的update与push"></a>源代码的update与push</h4><p>　　我们在进行开发时候需要经常进行update与push。update是指从Gitlab-CE官网获取官方的更新，gdk update指令可以帮助我们从官方仓库里拉取更新，并运行数据库的迁移进行数据库修改。但这种方式是强制进行Fast-forward形式的merge，如果我们本地仓库做出了自己的修改，那么就会有冲突，gdk update会失败。这时候我们需要切换到gitlab-development-kit目录下的gitlab目录，手动运行git pull命令，然后自己解决了冲突以后再进行git pull。之后再切换到gitlab-development-kit目录，运行gdk update指令。</p>
<p>　　如果官方进行了数据库方面的更新，那么你在运行gdk update时候必须保证数据库已经运行起来，否则仍会失败。我们在运行gdk run之后数据库是启动起来的，如果某些数据库改动要求我们把gitlab下线操作的话（关于下线参照：<a href="https://docs.gitlab.com/ce/development/what_requires_downtime.html" target="_blank" rel="external">https://docs.gitlab.com/ce/development/what_requires_downtime.html</a> ），我们可以先把gitlab应用停止，然后单独运行gdk run db。</p>
<p>　　我们修改了源代码，就要把它push到远端仓库，方面后面的打包使用。直接切换到gitlab目录运行git push origin master就好。</p>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>　　由于需要打出rpm包，打包环境选择Centos 7，要打deb包的话则要在Ubuntu下打包。</p>
<p>　　Gitlab官方是用omnibus-gitlab这个工程进行打包的，我们自己打包也得用这个工具，下面是Gitlab官方给开发者提供的自己打包的指导：<a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/build/README.md" target="_blank" rel="external">https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/build/README.md</a> 。下面是我的步骤整理。</p>
<h4 id="打包环境配置"><a href="#打包环境配置" class="headerlink" title="打包环境配置"></a>打包环境配置</h4><p>　　运行以下shell脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">set -e</div><div class="line">set -u</div><div class="line"></div><div class="line"># Install the Chef client</div><div class="line">curl -L https://www.chef.io/chef/install.sh | sudo bash</div><div class="line"></div><div class="line"># Download the gitlab-omnibus-builder cookbook using Git and run its &apos;default&apos; recipe</div><div class="line">chef_root=/tmp/gitlab-omnibus-builder.$$</div><div class="line">mkdir &quot;$chef_root&quot;</div><div class="line">cd &quot;$chef_root&quot;</div><div class="line">mkdir cookbooks</div><div class="line">git clone https://gitlab.com/gitlab-org/gitlab-omnibus-builder.git cookbooks/gitlab-omnibus-builder</div><div class="line">git clone https://gitlab.com/gitlab-cookbooks/gitlab-attributes-with-secrets.git cookbooks/gitlab-attributes-with-secrets</div><div class="line">/opt/chef/bin/chef-client -z -r &apos;recipe[gitlab-omnibus-builder::default]&apos;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>　　官网说先要安装fakeroot这个库并且运行起来再运行上面的脚本，但我操作时候仍然在某步操作时候会报没有权限的错误，因此建议直接以root账户运行上面脚本。强烈建议翻墙运行脚本，因为某些依赖会下得特别慢，包括下面的打包过程，也应该翻墙了进行。</p>
<h4 id="开始打包"><a href="#开始打包" class="headerlink" title="开始打包"></a>开始打包</h4><p>　　按照官网的指示到运行bin/omnibus build gitlab这一步应该都没有问题。在运行这一步之前，我们先要修改clone下来的omnibus-gitlab下的.custom_sources.yml文件。仿照官网给出的模板：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">gitlab-rails:</span></div><div class="line"><span class="attr">  remote:</span> <span class="string">"https://gitlab.com/gitlab-org/gitlab-ce.git"</span></div><div class="line"><span class="attr">gitlab-rails-ee:</span></div><div class="line"><span class="attr">  remote:</span> <span class="string">"https://gitlab.com/gitlab-org/gitlab-ee.git"</span></div><div class="line"><span class="attr">gitlab-shell:</span></div><div class="line"><span class="attr">  remote:</span> <span class="string">"https://gitlab.com/gitlab-org/gitlab-shell.git"</span></div><div class="line"><span class="attr">gitlab-workhorse:</span></div><div class="line"><span class="attr">  remote:</span> <span class="string">"https://gitlab.com/gitlab-org/gitlab-workhorse.git"</span></div><div class="line"><span class="attr">gitlab-pages:</span></div><div class="line"><span class="attr">  remote:</span> <span class="string">"https://gitlab.com/gitlab-org/gitlab-pages"</span></div><div class="line"><span class="attr">config_guess:</span></div><div class="line"><span class="attr">  remote:</span> <span class="string">"git://git.savannah.gnu.org/config.git"</span></div><div class="line"><span class="attr">omnibus:</span></div><div class="line"><span class="attr">  remote:</span> <span class="string">"https://gitlab.com/gitlab-org/omnibus.git"</span></div></pre></td></tr></table></figure>
<p>　　其他都不需要改动，只需要把第一项gitlab-rails的地址改成我们自己fork下来的仓库地址就行，omnibus-gitlab在打包时候会自动从上面地址上拉取仓库。</p>
<p>　　还有一个很坑的问题，我在运行bin/omnibus build gitlab的时候有一个readline的库的下载地址貌似是无效的，一直下不下来，导致打包无法进行。我觉得这有可能是一个bug，我在omnibus-gitlab官网上提了一个issue，以后有可能官方会改掉。如果没有改，那么就自己修改本地omnibus-gitlab仓库config/software/readline.rb文件，把 “<a href="https://ftp.gnu.org/gnu/readline/" target="_blank" rel="external">https://ftp.gnu.org/gnu/readline/</a>“ 改成 “ftp://ftp.cwru.edu/pub/bash” 。</p>
<p>　　之后就可以运行bin/omnibus build gitlab了，应该就没有问题，可以成功打包了。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>　　部署环境是Centos 7。部署环境与打包环境必须分开，因为都会改动/opt/gitlab这个文件夹，会相互影响。</p>
<h4 id="第一次安装Gitlab"><a href="#第一次安装Gitlab" class="headerlink" title="第一次安装Gitlab"></a>第一次安装Gitlab</h4><p>　　如果部署机器以前没有装过Gitlab，那么非常方便，直接安装即可：rpm -i gitlab-ce.xx.rpm。其中xx是要安装的rpm包的版本号。安装成功运行sudo gitlab-ctl reconfigure即可。这时候Gitlab已经成功部署了。更多对Gitlab的配置，例如域名或者防火墙的设置，请参照Gitlab官网。</p>
<h4 id="在已有Gitlab上update"><a href="#在已有Gitlab上update" class="headerlink" title="在已有Gitlab上update"></a>在已有Gitlab上update</h4><p>　　这个才是我们一般的使用场景。运行rpm -Uvh gitlab-ce.xx.rpm。如果提示之前已经安装过或者有files confilct错误，那么运行rpm -Uvh –force gitlab-ce.xx.rpm，会强制安装rpm包。update不需要担心数据库会丢失。</p>
<p>　　有时候你如果修改了源代码的assets文件夹，修改了一些css或者js文件，或者添加了某些打包了assets的gem包，update以后有可能会不生效。这时候只需要把/opt/gitlab/embedded/service/gitlab-rails/public/assets文件夹删除，再重新运行rpm -Uvh –force gitlab-ce.xx.rpm命令，便会正常更新assets文件夹。</p>
<p>　　update命令成功后，我们便可以在部署的Gitlab上看到相应的更新了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 160 Intersection of Two Linked Lists 题解]]></title>
      <url>http://wjqwsp.github.io/2016/09/24/LeetCode-160-Intersection-of-Two-Linked-Lists-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　　Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>　　Notes:</p>
<ul>
<li>If the two linked lists have no intersection at all, return null.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.<a id="more"></a>
</li>
</ul>
<h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>　　由于两个链表在尾部可能存在相同的部分，如果将其中一条链表的尾部连到另一条链表的头部，那么就可以构造一个环。题目就转化为求环的入口结点。下面先对环的几个概念作出分析。</p>
<h5 id="单链表是否存在环？"><a href="#单链表是否存在环？" class="headerlink" title="单链表是否存在环？"></a>单链表是否存在环？</h5><p>　　解答这个问题，只需要设置快慢指针即可。慢指针一次走一步，快指针一次走两步。如果存在环，那么快指针终会赶上慢指针。设想一下，假如快指针追到慢指针身后一步，那么慢指针走一步，快指针走两步后，下一次就会相遇。如果快指针落后慢指针两步或者三步，再多走一次或两次两者就会达到只差一步的情况。所以两个指针终将相遇。</p>
<h5 id="求环的长度。"><a href="#求环的长度。" class="headerlink" title="求环的长度。"></a>求环的长度。</h5><p>　　从快慢指针相遇结点开始，让一个指针每次走一步，那么下次回到这个结点所走过的路程，就是环的长度。</p>
<h5 id="求存在环的单链表的环的入口结点。"><a href="#求存在环的单链表的环的入口结点。" class="headerlink" title="求存在环的单链表的环的入口结点。"></a>求存在环的单链表的环的入口结点。</h5><p>　　设单链表头结点到入口结点的距离为ａ，入口结点到快慢指针相遇结点的距离为ｘ，单链表总长度为L，环长为r。当快慢指针相遇时，设慢指针走的步数是s，则快指针走的步数是2s。</p>
<p><pre><code><br>s = a + x;<br>2s = s + nr;<br>a + x = nr = (n-1)r + r = (n-1)r + L - a;<br>a = (n-1)r + L - a - x;<br></code></pre><br>　　所以，设置两个指针，起点分别是链表头结点和快慢指针相遇结点，同时前进，每次走一步。那么总会相遇在入口结点处。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123;</div><div class="line"> *         val = x;</div><div class="line"> *         next = null;</div><div class="line"> *     &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        ListNode temp = headA;</div><div class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;</div><div class="line">            temp = temp.next;</div><div class="line">        &#125;</div><div class="line">        temp.next = headB;</div><div class="line">        ListNode slow = headA;</div><div class="line">        ListNode fast = headA;</div><div class="line">        do&#123;</div><div class="line">            <span class="keyword">if</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</div><div class="line">                slow = slow.next;</div><div class="line">                fast = fast.next.next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                temp.next = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">while</span>(slow != fast);</div><div class="line">        slow = headA;</div><div class="line">        <span class="keyword">while</span>(slow != fast)&#123;</div><div class="line">            slow = slow.next;</div><div class="line">            fast = fast.next;</div><div class="line">        &#125;</div><div class="line">        temp.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> slow;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这个解法实际上就是求存在环的单链表的环的入口结点。</p>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>　　这两个链表有一个特点，就是相同的地方必定在尾部。但是由于两条链表长度不一定相等，如果同时遍历的话，很难让相同的结点对齐。因此，这个解法用了一个小技巧，让两个链表在按顺序从头到尾遍历的时候，能够做到尾部对齐。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123;</div><div class="line"> *         val = x;</div><div class="line"> *         next = null;</div><div class="line"> *     &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        ListNode p1 = headA;</div><div class="line">        ListNode p2 = headB;</div><div class="line">        <span class="keyword">boolean</span> flagA = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">boolean</span> flagB = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</div><div class="line">            p1 = p1.next;</div><div class="line">            p2 = p2.next;</div><div class="line">            <span class="keyword">if</span>(p1 == <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(flagA == <span class="keyword">true</span> &amp;&amp; flagB == <span class="keyword">true</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    flagA = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                p1 = headB;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(p2 == <span class="keyword">null</span>)&#123;</div><div class="line">                p2 = headA;</div><div class="line">                flagB = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　一开始仍然让两链表从头开始遍历，每次走一步。链表A遍历到末端回到链表B的头部，链表B遍历到末端也回到链表A的头部。这样当两个遍历指针都到达另一个链表的时候，恰好可以让尾部对齐，消除掉长度差的影响。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 203 Remove Linked List Elements 题解]]></title>
      <url>http://wjqwsp.github.io/2016/09/24/LeetCode-203-Remove-Linked-List-Elements-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　　Remove all elements from a linked list of integers that have value val.</p>
<p>　　Example</p>
<p>　　Given: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6</p>
<p>　　Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5<br><a id="more"></a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　　这道题非常简单，但很好地体现了单链表的特点。单链表每个结点只能引用下一个结点，因此删除结点时，也只能立足于一个不需要被删除的结点，去判断是否需要删除下一个结点。</p>
<p>　　由于删除时候需要遍历链表，但遍历的开始必须是头结点，而头结点如果要删除就要额外处理了。这里我们在头结点之前再插入一个临时结点，以统一处理整个链表。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        head = dummy;</div><div class="line">        <span class="keyword">while</span>(head.next != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(head.next.val == val)&#123;</div><div class="line">                head.next = head.next.next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                head = head.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　代码里删除只针对紧邻的下一个结点。当下一个结点的值是需要删除的值时，则删除下一个结点，再判断新的下一个结点是否需要删除；如果下一个结点不需要删除，则移动到下一个结点，再观察后面的结点是否需要删除。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 234 Palindrome Linked List 题解]]></title>
      <url>http://wjqwsp.github.io/2016/09/24/LeetCode-234-Palindrome-Linked-List-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　　Given a singly linked list, determine if it is a palindrome.</p>
<p>　　Follow up:</p>
<p>　　Could you do it in O(n) time and O(1) space?</p>
<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>　　判断一个链表是否是回文链表。</p>
<p>　　所谓回文，即从左往右和从右往左读都是一样的。例如：</p>
<p>　　“abcdefgfedcba”</p>
<p>　　1-&gt;2-&gt;3-&gt;3-&gt;2-&gt;1</p>
<p>　　我们现在要做的，就是判断给定的链表是否满足这个特性。</p>
<p>　　这题还有一个难点，就是时间复杂度与空间复杂度的限制。特别是空间复杂度限制太严格了。<br><a id="more"></a></p>
<h3 id="思路与代码"><a href="#思路与代码" class="headerlink" title="思路与代码"></a>思路与代码</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>　　这题我第一反应是开辟一个数组，把链表倒着存进去，然后逐一和原链表的的值比对，看是否都一致。但这种思路需要的空间复杂度是o(n)。</p>
<p>　　因此，我就想怎么能节省空间复杂度呢？就想到用递归。其实递归有点作弊的意思，因为虽然局部变量的空间复杂度只有o(1)，但程序运行时的函数调用栈需要消耗的栈空间是o(n)，这与直接在局部变量定义一个栈来做是一样的，只是会逃过空间复杂度的检查。</p>
<p>　　下面是递归的思路：</p>
<ol>
<li>求链表的中点。</li>
<li>递归的终止条件是到达链表的中点返回，如果没有到达中点则继续寻找下一个结点。</li>
<li>假设有链表：n1-&gt;n2-&gt;n3…-&gt;nk-&gt;nl…-&gt;nm-&gt;nn…-&gt;ny-&gt;nz。假如链表nl…nm是回文的，那么nk到nn回文当且仅当nk.val == nn.val。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mid = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">        ListNode temp = head;</div><div class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</div><div class="line">            length++;</div><div class="line">            temp = temp.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> mid = (length+<span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.mid = mid;</div><div class="line">        ListNode result = isEqual(head,<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(result != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">isEqual</span><span class="params">(ListNode node,<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(mid == index &amp;&amp; length % <span class="number">2</span> == <span class="number">1</span>)&#123;</div><div class="line">             <span class="keyword">if</span>(node.next != <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="keyword">return</span> node.next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid == index &amp;&amp; length % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(node.val == node.next.val)&#123;</div><div class="line">                    <span class="keyword">if</span>(node.next.next != <span class="keyword">null</span>)&#123;</div><div class="line">                        <span class="keyword">return</span> node.next.next;</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        <span class="keyword">return</span> node.next;</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            ListNode result = isEqual(node.next,(index+<span class="number">1</span>));</div><div class="line">            <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.val == result.val)&#123;</div><div class="line">                <span class="keyword">if</span>(result.next != <span class="keyword">null</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> result.next;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> result;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这里找中点直接用了遍历这个链表的方法。在递归算法里，如果子链表是回文的，则返回子链表最后一个结点的引用。子链表返回的引用的下一个结点就是父链表的最后一个结点。此时判断父链表的第一个结点与最后一个结点的值是否相等就可以判断父链表是否是回文的了。</p>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>　　这个解法我觉得比递归的好很多，是网上比较权威的一个解法，这里记录一下。</p>
<p>　　单链表最令人郁闷的，就是只能引用下一个结点，不能引用上一个结点，遍历路径是单向的。但很多时候，我们希望遍历的顺序往往是反着的。像这题这个判断回文，如果能反着遍历链表，就很容易判断了。于是，很自然的，我们就想着能不能将链表逆转。后面的逆转链表算法，十分经典，非常值得借鉴。</p>
<p>　　解法步骤：</p>
<ol>
<li>获得链表中点的结点。</li>
<li>将后半段链表逆转。</li>
<li>分别遍历前半段和后半段链表，逐个比较每个结点的值，如果全部相等，则是回文的；有一个不相等，则不是回文的。</li>
</ol>
<p>　　其中寻找中点的算法，是判断链表是否有环算法的变形，用到了快慢指针，也非常经典。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        ListNode mid = findMiddle(head);</div><div class="line">        mid.next = revert(mid.next);</div><div class="line">        ListNode p1 = head;</div><div class="line">        ListNode p2 = mid.next;</div><div class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span> &amp;&amp; p1.val == p2.val)&#123;</div><div class="line">            p1 = p1.next;</div><div class="line">            p2 = p2.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p2 == <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">findMiddle</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">        ListNode slow = head;</div><div class="line">        ListNode fast = head.next;</div><div class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</div><div class="line">            slow = slow.next;</div><div class="line">            fast = fast.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> slow;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">revert</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">        ListNode prev = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">            ListNode temp = head.next;</div><div class="line">            head.next = prev;</div><div class="line">            prev = head;</div><div class="line">            head = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　找单链表中点算法，主要是设置了一个慢指针，一个快指针。慢指针每次循环前进一步，快指针则前进两步。不难看出，在整个循环过程中，快指针的位置始终是慢指针的两倍，那么当快指针将要跑出链表时，慢指针则刚好在中点位置。</p>
<p>　　逆转链表算法就非常简单了，只是单纯的遍历。维护前后两个链表，每次循环把后链表的一个结点给前链表，前链表是已经逆转的链表，后链表则还保持原来的顺序。当遍历到最后一个结点时，则整个链表都被逆转了。</p>
<p>　　
　　</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 237 Delete Node in a LinkedList 题解]]></title>
      <url>http://wjqwsp.github.io/2016/09/24/LeetCode-237-Delete-Node-in-a-LinkedList-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　　Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>　　Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.<br><a id="more"></a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　　单链表要删除，必须知道要删除结点的前一个结点。但此题困难在于只给了要删除结点的引用，而无法获知该g结点的前一个结点，因此按传统方法无法删除。</p>
<p>　　但这题其实非常简单，换种思路，我们把删除该结点改为删除该结点的下一个结点，但在删除之前把下一个结点的值覆盖此结点的值。因此，虽然物理上删除的是下一个结点，但实际上该结点的值已经被删除了，而下一个结点的值仍然保留下来。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> ListNode first;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</div><div class="line">        node.val = node.next.val;</div><div class="line">        node.next = node.next.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java异常处理总结]]></title>
      <url>http://wjqwsp.github.io/2016/09/22/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　这一讲抽取Java异常处理的核心内容与基本思想，作一个总结，既作为个人笔记，也可供读者参考。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li>降低错误处理代码的复杂度，让程序实际的逻辑实现与错误处理相分离，使代码的阅读，编写和调试工作更加井井有条。</li>
<li>在能处理时捕捉异常，不能处理时则将异常传给其他地方处理。</li>
<li>将异常分类，用异常类的名字或携带的信息标识异常类别与详细信息，一般只用名字标识即可。在处理时不针对异常抛出点处理，只对异常类型处理，简化了异常处理的代码。<a id="more"></a>
</li>
</ul>
<h3 id="异常对象的类型"><a href="#异常对象的类型" class="headerlink" title="异常对象的类型"></a>异常对象的类型</h3><h4 id="必检异常与非必检异常"><a href="#必检异常与非必检异常" class="headerlink" title="必检异常与非必检异常"></a>必检异常与非必检异常</h4><p>　　我们指的异常类都是Exception类型或者继承了Exception类型的子类。这些异常类可以分为两大部分，一部分是必检异常，另一类是非必检异常。只有RuntimeException及其子类是非必检异常，其余都是必检异常。</p>
<p>　　非必检异常对象由Java虚拟机自行管理，当异常发生时，会自动在堆中new一个异常对象。如果非必检异常始终不捕捉，则会沿着方法调用栈一直往上冒泡，直到控制台，并且自动调用prinStackTrace()方法输出异常信息。而必检异常必须手动在堆中创建，然后用关键字throw抛出，且必须在程序的某一处进行捕捉处理。如果不处理，则需在main方法里声明抛出异常，将异常抛给控制台，让异常信息在控制台输出。</p>
<h4 id="RuntimeException的使用场景"><a href="#RuntimeException的使用场景" class="headerlink" title="RuntimeException的使用场景"></a>RuntimeException的使用场景</h4><p>　　我的理解是，必检异常都是用户在当前环境下直接产生的异常。而RuntimeException及其子类则代表编程错误。所谓编程错误，有两种含义：</p>
<ol>
<li>在程序员编程时应该进行检查的低级错误，如数组越界异常ArrayIndexOutOfBoundsException，空指针异常NullPointerException等，它们都是RuntimeException的子类。</li>
<li>某些间接的或者不是由方法调用者所能掌控的错误。例如别的地方传来的空指针引用，或者与该方法本身无直接关联的错误。</li>
</ol>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>　　所有继承了Exception或其子类的类，都是自定义异常类。我们可以根据自己的业务需要创建新的异常类。</p>
<h3 id="异常对象的处理方式"><a href="#异常对象的处理方式" class="headerlink" title="异常对象的处理方式"></a>异常对象的处理方式</h3><h4 id="抛出"><a href="#抛出" class="headerlink" title="抛出"></a>抛出</h4><p>　　如果方法里获得了一个异常对象，但不知道怎么处理，或者在该方法的作用域内没有办法处理，则必须将异常对象往方法调用栈的上一级抛出，让别的地方处理。</p>
<p>　　我们在设计方法的时候，必须声明该方法可能会抛出什么异常，在方法名的后面跟throws再加上可能抛出的异常类表示。所有可能抛出的必检异常都必须声明，且调用该方法时候要么在调用该方法的方法签名上再进行抛出声明，要么用try…catch语句捕捉处理异常。否则产生编译错误。</p>
<h4 id="捕捉"><a href="#捕捉" class="headerlink" title="捕捉"></a>捕捉</h4><p>　　catch作用域就是异常处理程序代码所在地，对捕捉到的异常进行处理。如果同时捕捉多个异常，且这些异常存在继承关系，则必须将继承链里相对最后的子类异常放在前面，并按继承链的顺序由子类到父类依次排列。这是因为异常捕捉只要捕捉到相应类型的异常则终止，后面的捕捉块都不会起作用。而Java里支持多态，所以如果父类异常放前面，则子类异常永远不会被捕捉到。</p>
<h3 id="无法处理的异常"><a href="#无法处理的异常" class="headerlink" title="无法处理的异常"></a>无法处理的异常</h3><p>　　无法处理的异常需要抛出，但如果我们一直不知道如何处理该异常，那应该怎么办呢？特别对于必检异常，强制我们进行捕获或继续上抛，如果始终不捕捉，那么异常对象会怎么样呢？</p>
<h4 id="空处理"><a href="#空处理" class="headerlink" title="空处理"></a>空处理</h4><p>　　千万不能为了应付编译，捕捉了异常，而进行空处理。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    <span class="comment">//do nothing</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这样的话，即便发生了异常，我们也无从得知程序有错，因为异常信息被吞没了。</p>
<h4 id="输出异常信息"><a href="#输出异常信息" class="headerlink" title="输出异常信息"></a>输出异常信息</h4><p>　　即便为了应付编译，我们也得输出异常信息，这样我们可以定位错误，以便在需要的时候修改异常处理的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　Exception类继承自Throwable类，Throwable类有3个关于异常输出的方法：</p>
<ul>
<li>printStackTrace()</li>
<li>printStackTrace(PrintStream)</li>
<li>printStackTrace(java.io.PrintWriter)</li>
</ul>
<p>　　printStackTrace()会把异常抛出点往上的所有方法调用栈信息输出到标准错误流。除了输出到标准错误流，也可以指定参数，指定输出到由PrintStream流或者PrintWriter包装的一个流。</p>
<h4 id="只能部分处理异常"><a href="#只能部分处理异常" class="headerlink" title="只能部分处理异常"></a>只能部分处理异常</h4><p>　　对于某些异常，可能在当前方法内捕捉可以处理一部分问题，但还有其他问题需要由其他方法继续处理。这种情况，我们可以先捕捉，进行处理，然后重新在catch代码块里抛出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    <span class="keyword">throw</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　但重新抛出产生了一个问题，即重新抛出的异常仍然保留的是原来调用栈的信息，在别的地方再进行捕捉时，printStackTrace()方法打印的仍然是第一次抛出时的方法调用栈。如果需要更新调用栈信息，则需要用fillInStackTrace()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    <span class="keyword">throw</span> (Exception)e.fillInStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　fillInStackTrace()方法会返回一个更新了调用栈信息的Throwable类型对象。</p>
<h4 id="main方法抛出异常"><a href="#main方法抛出异常" class="headerlink" title="main方法抛出异常"></a>main方法抛出异常</h4><p>　　如果异常一直抛出到main方法仍然无法处理，那么可以声明main方法抛出异常，异常会直接传给控制台输出调用栈信息。</p>
<h4 id="将必检异常转换为非必检异常"><a href="#将必检异常转换为非必检异常" class="headerlink" title="将必检异常转换为非必检异常"></a>将必检异常转换为非必检异常</h4><p>　　我们可以用e.printStackTrace()的形式，在不知道怎么处理异常时捕捉异常并单纯输出异常信息。然而，捕捉就意味着处理，如果我们不处理只捕捉，则违背了异常处理的初衷。对于无法处理的异常，我们应始终抛出。而RuntimeException及其子类，都是非必检异常，可以自动沿调用链抛出直至控制台。我们可以利用这种特性，让必检异常转换为非必检异常，让它们抛出到控制台而始终不捕捉。等以后知道怎么处理之后，再修改代码。</p>
<h5 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h5><p>　　要了解异常类型转换，必须先介绍异常链。</p>
<p>　　异常链的产生也是源自重新抛出。要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，就被称为异常链。构造异常链，我们需要在堆里new一个新的异常对象，并且把原始异常对象传入该新的对象里。对于Error,Exception,RuntimeException，其构造函数就接收一个异常对象。但对于其他类型的异常，必须用initCause(Exception)方法传入异常对象。</p>
<p>　　其后，我们可以捕捉新的异常对象，原始异常对象的信息也会保存在里面。</p>
<h5 id="转换为RuntimeException"><a href="#转换为RuntimeException" class="headerlink" title="转换为RuntimeException"></a>转换为RuntimeException</h5><p>　　了解了异常链，这种转换就非常简单了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　以IOException为例，它是必检异常，通过传入RuntimeException的构造函数，就可以转换为非必检异常抛出了。</p>
<p>　　我觉得对于暂时不知道怎么处理的异常，这种处理方式是最佳的方式。</p>
<h3 id="资源清理"><a href="#资源清理" class="headerlink" title="资源清理"></a>资源清理</h3><p>　　Java只负责内存清理，所有与内存无关的清理工作，都需要手动清理，例如一些IO资源，数据库连接资源等。</p>
<p>　　资源清理一般在finally代码块里实现。</p>
<p>　　对于某些资源，如果在创建对象时就失败，就不需要清理了。可以用嵌套的try…catch语句实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"Cleanup.java"</span>));</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            in.close();</div><div class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　建议在所有创建资源对象的语句前后加上嵌套的try…catch语句。</p>
<p>　　当然，我们也可以不用这种嵌套，但必须在每次清理之前判断资源对象是否为null。</p>
<p>　　Java7还引入了一个新特性：try-with-resource。所有实现了java.lang.AutoCloseable的对象，都被视为资源。如果这些资源在try块内，则会在块结束之后自动被清理，不需要finally块，也不用显式地调用释放语句。</p>
<h3 id="使用finally的问题"><a href="#使用finally的问题" class="headerlink" title="使用finally的问题"></a>使用finally的问题</h3><ul>
<li>使用finally容易造成异常丢失。如果在catch前出现了finally语句，且finally语句内又抛出了异常，那么原try块内的异常会被取代，不会被捕捉。前一个异常还未处理，又抛出新异常，原异常会丢失。</li>
<li>如果在抛出异常时，finally内有return，则异常也会丢失。</li>
</ul>
<h3 id="异常处理的限制"><a href="#异常处理的限制" class="headerlink" title="异常处理的限制"></a>异常处理的限制</h3><ul>
<li>子类覆写的方法，抛出的异常必须在基类方法声明抛出的异常的范围内。</li>
<li>子类的构造器方法声明抛出的异常，必须含有父类构造器方法声明的异常。因为子类构造器必然会调用父类的某个构造器，无论是显式还是隐式。</li>
</ul>
<p>　　这种限制，也是源于Java的多态机制。因为子类对象会被向上转型为基类对象，必须保证在使用基类时能捕获子类所有的异常。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　要把异常处理好，需要很丰富的经验。以上只是异常处理的最基本知识。</p>
<p>　　</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从面向对象看JavaScript（五）—— 继承]]></title>
      <url>http://wjqwsp.github.io/2016/09/14/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BJavaScript%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94-%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h3 id="继承的本质"><a href="#继承的本质" class="headerlink" title="继承的本质"></a>继承的本质</h3><p>　　继承的初衷是复用。即已经有一个原始的类，希望在保留原始类的所有属性和方法的前提下，进行扩展或修改，以最大限度地降低开发成本。JavaScript实现继承，也是源自这个思想，即想办法让新的引用类型能够访问别的引用类型的所有属性和函数。<br><a id="more"></a></p>
<h3 id="原型链实现继承"><a href="#原型链实现继承" class="headerlink" title="原型链实现继承"></a>原型链实现继承</h3><p>　　回顾一下原型对象。原型对象与普通对象本质上没有任何区别，只是可以被对应实例对象的[[prototype]]指针指向，从而让所有实例对象都可以访问原型对象的属性和函数。而正是这一个特点，与继承的本质完全一致。换一个角度看，我们可以认为，实例对象继承了原型对象，所以可以访问它的所有属性和函数。</p>
<p>　　所以，我们甚至可以说，对象与对象的原型关系，就是继承关系。</p>
<p>　　那么，怎么让某一个新定义的引用类型继承另一个已经定义好的引用类型呢？很简单，只需要让他们建立原型关系。下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue());</div></pre></td></tr></table></figure>
<p>　　当调用SubType构造函数以后，会创建一个SubType实例对象，它存有SubType原型对象的指针，该原型对象默认是一个不含属性和函数的空对象。现在我们手动修改SubType构造函数的prototype指针，让它指向一个创建好的SuperType实例对象，从而通过SubType构造函数创建的实例对象的原型对象都是一个SuperType的实例对象，因此所有SubType实例对象都可以访问同一个SuperType实例对象的实例属性和方法，以及SuperType实例对象的原型对象的属性和方法。SubType原型对象的原型，就是SuperType的原型。继承就是这样实现的。</p>
<p>　　之前我们说过，所有引用类型都继承Object类型，JavaScript原生又是怎么实现这个继承关系的呢？跟上面的继承方式一样。在创建函数的时候，都会创建一个原型对象，这个原型对象初始是空白的，没有任何属性和函数，但是它却有[[prototype]]这个内部属性，指向同一个Object对象。所以，所有原型对象默认的原型都是Object。</p>
<p>　　这种原型的原型，就构成了原型链。通过不断延伸原型链，我们便可以实现多重继承。只要能够沿着原型链找到的引用类型，都可以通过instanceof操作符返回true，从而判断对象的类型。</p>
<h3 id="分离实例属性与原型属性"><a href="#分离实例属性与原型属性" class="headerlink" title="分离实例属性与原型属性"></a>分离实例属性与原型属性</h3><p>　　继承实际上是让原型对象的[[prototype]]指向下一个原型对象。回到前面几讲，我们希望让所有公共的属性与函数，都放在原型上，让所有各不相同的属性都定义在实例上。在进行原型链的构造时，为了满足这个需求，我们需要对实例属性和原型属性进行分离。下面给出继承的一般方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype  = object(superType.prototype);</div><div class="line">    prototype.constructor = subType;</div><div class="line">    subType.prototype = prototype;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.color = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">inheritPrototype(SubType,SuperType);</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　我们构造一个对象让它继承SuperType.prototype,然后让这个对象作为SubType的原型，从而构造了一条原型链。而让原来在SuperType实例上定义的所有属性都定义在SubType的实例上，而方法则全部定义在原型上，从而实现了实例属性与原型属性的分离。</p>
<h3 id="再看垃圾回收机制的标志清除策略"><a href="#再看垃圾回收机制的标志清除策略" class="headerlink" title="再看垃圾回收机制的标志清除策略"></a>再看垃圾回收机制的标志清除策略</h3><p>　　我们介绍了两条链，一条作用域链，一条原型链。回顾标志清除策略，其实搜索对象就是分别沿着这两条链寻找。通过作用域链，找到执行环境中的所有变量与函数。而通过原型链，则找到执行环境中的变量引用的所有变量与函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　实现继承，关键在于让被继承的引用类型的原型对象插入到原型链中。继承关系，实质上就是一个原型对象到另一个原型对象通过[[prototype]]指针的连接关系。</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从面向对象看JavaScript（四）—— 内存管理]]></title>
      <url>http://wjqwsp.github.io/2016/09/14/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BJavaScript%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　与java类似，JavaScript也有两种垃圾回收方式，分别是标记清除和引用计数。目前基本上都是使用标记清除的方式，引用计数存在循环引用的问题，实际中很少使用，但IE中的BOM和DOM对象却是用引用计数方式来做垃圾回收，非常容易造成内存泄漏。<br><a id="more"></a></p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>　　垃圾回收器会给所有存储在内存中的变量都打上标记，然后去掉所有在执行环境中的变量，以及被环境中的变量所引用的变量的标记。剩下还有标记的变量就是垃圾回收器将会回收的变量。</p>
<p>　　对比java中的标记清除策略，java会从堆栈和静态存储区开始，遍历所有引用，对每一个引用，再追踪它引用的每个对象，然后对每个对象再追踪它引用的下一层对象。如此层层深入，最终能遍历所有“活”的对象，其余对象则在下一次垃圾回收器工作时被回收。</p>
<p>　　不难看出，这两种语言的标记清除策略是一回事。JavaScript执行环境中的变量就相当于java堆栈和静态存储区的变量。</p>
<p>　　如果采用这种回收策略，我们基本不用担心内存泄漏的问题。因为只要函数作用域结束了，自然会退出执行环境。只要变量不在执行环境中，即便存在循环引用，也会被垃圾回收器回收。只有全局环境下的变量和函数在程序运行的整个周期都不会被回收，如果不用的话，需要手动设为null。另外，闭包由于会保留其上级函数的变量对象，使得垃圾回收器无法清除相关的变量和函数，因此会占用较多的内存，所以使用闭包时要注意。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>　　对内存中的每一个对象都记录其引用数，只要其引用数为0，则会被垃圾回收。但是如果存在循环引用，则会造成内存泄漏：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    <span class="keyword">var</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    objectA.someOtherObject = objectB;</div><div class="line">    objectB.anotherObject = objectA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　我们记problem函数里定义的两个对象为对象A和对象B。如果调用problem函数，则在函数结束前，对象A和对象B的引用数均为2。在执行结束后，objectA和objectB这两个引用由于存在堆栈里，会马上被释放。但对象A仍然被对象B的anotherObject属性引用；对象B也仍然被对象A的someOtherObject属性引用。所以这两个对象将永远不会被释放。</p>
<p>　　如果大量调用problem函数，那么将会导致大量内存不能被回收。</p>
<p>　　值得开心的事，这种引用计数方式已经基本不被采用。但IE的BOM和DOM对象仍然是用这种策略来进行垃圾回收的。因此使用BOM和DOM对象时要加倍小心，防止循环引用的发生。下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</div><div class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">myObject.element = element;</div><div class="line">element.someObject = myObject;</div></pre></td></tr></table></figure>
<p>　　element是DOM元素，它和myObject存在循环引用问题。在使用完毕DOM或BOM对象后，要记住将它们的引用设为null。</p>
<h3 id="闭包的循环引用问题"><a href="#闭包的循环引用问题" class="headerlink" title="闭包的循环引用问题"></a>闭包的循环引用问题</h3><p>　　如果同时使用闭包和DOM或BOM对象，那么更加要留心循环引用的问题了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</div><div class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(element.id);</div><div class="line">    &#125;；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　元素的点击事件函数的内存属性[[scope]]指向的作用域链里保存了assignHandler的活动对象，该活动对象里存在element的引用。同时。element的onclick属性也引用了点击事件函数。不难看出，闭包的循环引用往往是由其作用域链产生的。</p>
<p>　　我们可以这样修改代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</div><div class="line">    <span class="keyword">var</span> id = element.id;</div><div class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(id);</div><div class="line">    &#125;；</div><div class="line">    element = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　谨记及时将DOM或BOM的引用手动设为null。</p>
<h3 id="gc-root"><a href="#gc-root" class="headerlink" title="gc root"></a>gc root</h3><p>　　javascript的垃圾收集从gc root开始。gc root的核心包括当前执行环境的所有对象，可以沿着作用域链找到所有在当前环境的对象。然后从这些对象开始，沿着原型链一层一层地寻找引用的对象。这个过程类似函数执行的变量查找策略。也是先查作用域链，获得寻找的对象，然后查找该对象的原型链，获得要查找的属性。这是一种二维作用域链查找方式。这里的对象包括函数，因为在javascript里函数也是对象。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>　　在实际开发中，容易造成内存泄漏的主要有以下方面：无用的全局变量，闭包以及脱离dom tree的dom元素。</p>
<h4 id="不用的变量及时赋null"><a href="#不用的变量及时赋null" class="headerlink" title="不用的变量及时赋null"></a>不用的变量及时赋null</h4><p>　　养成好习惯，在函数执行过程中将用完的变量设为null，使得对象脱离执行环境。</p>
<h4 id="注意闭包"><a href="#注意闭包" class="headerlink" title="注意闭包"></a>注意闭包</h4><p>　　闭包往往使得原本应该脱离执行环境的变量仍然保留在闭包函数的[[scope]]中而不能被释放，在使用闭包时应该谨慎，留意内存泄漏的发生，将作用域链里无用的变量设为null。</p>
<h4 id="不要保留dom元素的引用"><a href="#不要保留dom元素的引用" class="headerlink" title="不要保留dom元素的引用"></a>不要保留dom元素的引用</h4><p>　　当我们保留了某子元素的引用时，即便其父元素脱离了文档，整个父元素及其所有子元素的内存都不会释放。而且当处理dom元素和其回调函数时要注意不要将元素对象作为参数传入回调函数中，这样容易造成循环引用。虽然现代浏览器普遍已经不使用引用计数法，这个问题不大，但养成好习惯总是好的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　关于JavaScript的内存管理，只需要掌握两种垃圾回收策略即可。特别要注意闭包和DOM,BOM对象，注意循环引用。及时手动切断引用与DOM,BOM对象，全局环境下的对象的联系。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从面向对象看JavaScript（三）—— 属性权限管理]]></title>
      <url>http://wjqwsp.github.io/2016/09/14/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BJavaScript%EF%BC%88%E4%B8%89%E2%80%94%EF%BC%89%E2%80%94%E2%80%94-%E5%B1%9E%E6%80%A7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="对象的私有成员"><a href="#对象的私有成员" class="headerlink" title="对象的私有成员"></a>对象的私有成员</h3><p>　　原文再续，书接上一回。第一讲里我们提到怎么定义类，怎么创建对象。但在这些对象上创建的属性与方法，都是能被直接访问的，JavaScript并没有提供private,public,protected等属性的权限管理机制。但是，利用闭包我们完全可以实现对象属性和方法的私有化管理。<br><a id="more"></a></p>
<h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>　　在讲私有化管理之前，我们必须再讲一下作用域有关的知识。JavaScript只有全局作用域与函数作用域，而没有块级作用域。但我们可以用匿名函数来模仿块级作用域。</p>
<p>　　在任意作用域中，我们可以用以下代码实现一个短暂的函数作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>　　只要闭包不作为返回值返回，它的变量对象，执行环境与作用域链就会在执行后销毁。而匿名函数也没有被任何标识符引用，因此在退出执行环境后函数对象也会被垃圾回收。上面的代码在定义了匿名函数的同时马上执行，就能够模拟块级作用域的效果。</p>
<p>　　这种技术经常用在全局作用域中，避免向全局作用域添加过多的变量和函数。</p>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>　　由第二讲知道，某个执行环境中不能访问其作用域链以外的变量和函数。根据这个特点，我们可以把变量放在一个只能由公共接口函数访问的作用域中，这些变量便自然只能被特定的公共接口访问，而不能被直接访问，从而实现了私有化。看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        privateVariable++;</div><div class="line">        <span class="keyword">return</span> privateFunction();</div><div class="line">    &#125;;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　publicMethod函数作为闭包，可以访问privateVarialbe以及privateFunction，但其他函数和变量由于无法看到MyObject这个作用域，所以只能通过publicMethod间接访问，由此实现了私有变量，私有函数以及公共接口。但由于publicMethod是定义在实例上而不是在原型上，因此每创建一个实例都会创建一个publicMethod方法。</p>
<h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><p>　　通过将公共接口定义在原型上，可以实现静态私有变量，让所有实例都共享同一个私有变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">""</span>;</div><div class="line">    Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>　　也是利用了闭包的作用域链的特点，实现静态私有变量，只不过是把公共接口定义在原型对象上。但这样的话私有变量必须被所有实例对象共享，还是要根据需求来选择定义私有变量或者静态私有变量。</p>
<h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>　　以上说的都是自定义类型的私有变量和公共方法。但有时候我们不想定义新的类型，在整个系统中只需要对象的一个实例。那么我们可以用模块模式来定义单例对象的私有变量和公共方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</div><div class="line">    object.publicProperty = <span class="literal">true</span>;</div><div class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        privateVariable++;</div><div class="line">        <span class="keyword">return</span> privateFunction();</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>　　也是通过一个模仿块级作用域里定义的私有变量，私有方法以及闭包来实现的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　闭包是实现对象私有变量和私有函数的最重要的技术。关键在于把要保护的变量和函数放在一个特定的作用域内，而这个作用域只存在于公共接口函数的作用域链中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从面向对象看JavaScript（二）]]></title>
      <url>http://wjqwsp.github.io/2016/09/13/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BJavaScript%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h3><p>　　原文再续，书接上一回。话说讲到JavaScript对象里拥有属性与函数，上一讲介绍了属性，这一讲重点讲一讲函数。JavaScript的函数与Java的方法还是有很多不一样的地方，最主要的一点是，JavaScript的函数也是对象。它也可以拥有自己的属性与方法，它可以作为值像一般属性一样传递，成为其他函数的参数或者返回值。<br><a id="more"></a></p>
<h3 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a>函数的定义方式</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　相当于创建了一个函数对象，名字为sum的引用作为指针指向这个函数对象。与后面函数表达式的定义方式表示的意义完全等同。</p>
<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>　　这种方式定义有一个缺点。如果用函数声明定义函数，那么JavaScript解释器会进行函数声明提升，即在代码开始执行前，把所有函数声明提到所有代码的前面，因此，即便函数调用在函数声明之前，也能正确执行，不会出错。但采用函数表达式定义函数，则没有提升的效果。</p>
<h4 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h4><p>　　在JavaScript里，函数是一种原生对象类型，Function类型。可以用上一讲我们介绍的构造函数方式创建对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>,<span class="string">"num2"</span>,<span class="string">"return num1 + num2"</span>);</div></pre></td></tr></table></figure>
<p>　　最后一个参数是函数体，前面的全部作为函数的传入参数。不推荐用这种方式定义函数，因为会导致两次解析代码，影响性能。第一次解析常规的JavaScript代码，第二次解析字符串。</p>
<h3 id="函数传递与函数调用"><a href="#函数传递与函数调用" class="headerlink" title="函数传递与函数调用"></a>函数传递与函数调用</h3><p>　　如果在函数名后面加上()，则代表调用这个函数。如果没有这个括号，则表明将函数作为对象值传递，可以作为其他函数的参数值传入其他函数，也可以作为其他函数的返回值返回函数。</p>
<p>　　当函数作为值时，与其他对象属性没有任何区别，可以赋值给其他引用，也可以将函数引用设为null，提示内存的垃圾回收系统将其清理。</p>
<h3 id="两种函数对象"><a href="#两种函数对象" class="headerlink" title="两种函数对象"></a>两种函数对象</h3><p>　　定义的函数对象，与被调用后的函数对象，在JavaScript里是两个概念，是两个不同的对象。我们一般说的函数对象，是指用上面方法定义的函数。但是，当我们调用函数时，还会另外产生一个对象，通常称为变量对象，当其正被调用时，也称为活动对象。下面，我将分两大部分，分别介绍这两种对象。</p>
<h4 id="定义好的函数对象"><a href="#定义好的函数对象" class="headerlink" title="定义好的函数对象"></a>定义好的函数对象</h4><p>　　这种函数对象，就是一般我们能访问的函数对象，拥有与其他普通对象一样的特性，可以有自己的属性与函数，并且能够直接访问这些属性和函数。</p>
<h5 id="常用的属性"><a href="#常用的属性" class="headerlink" title="常用的属性"></a>常用的属性</h5><h6 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h6><p>　　类数组对象，每个函数都有这个对象，函数被定义后，初始值为null。当函数被调用时，传入函数的参数全部推入这个arguments对象里，可以按数组的索引方式访问所有传入参数。当函数调用结束后，arguments又被设为null。</p>
<p>　　可以用arguments.length得到传入参数的个数。</p>
<p>　　在定义函数时，我们往往会指定一些参数的名字，我们称为命名参数。命名参数只是arguments相应位置的参数的别名。因此，命名参数的个数与实际调用时可以传递的参数数目完全无关，只是方便引用传入参数而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　仍以sum函数为例。num1,num2是两个命名参数，但实际调用时，我们可以传入任意数量的参数，也可以不传入参数。我们可以用arguments[0]代替num1,用arguments[1]代替num2，也可以用arguments[3],argument[4]等引用更多传入的参数。</p>
<p>　　正是由于这个特性，JavaScript不存在函数重载，因为命名参数根本不能起到标识函数的作用。如果试图进行重载，那么只有最后一个函数才生效，其余都被覆盖。这是因为函数也是对象，相当于将同一个函数引用先后指向多个对象，显然只有最后一次赋值才是最终的值。</p>
<p>　　arguments.callee指向拥有该arguments对象的函数。如果是递归调用函数的话，可以用arguments.callee代替函数名，达到函数的执行与函数名解耦合的效果。但在严格模式下，访问arguments.callee会出错。</p>
<h6 id="length"><a href="#length" class="headerlink" title="length"></a>length</h6><p>　　length属性表示函数的命名参数的个数。</p>
<h6 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h6><p>　　原型属性，每一个函数都有的一个属性，指向其原型对象。</p>
<h6 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h6><p>　　保存着调用当前函数的函数的引用。如果在全局环境中调用函数，则为null。caller初始值为null，调用后也为null，只有在调用时才有值。</p>
<h6 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h6><p>　　则是函数对象的两个方法，当调用这两个方法时，函数会被调用，并且把this设置为指定的值，这个指定的值是在这两个方法的传入参数里指定的。这两个方法的具体用法就不详细说明了，非常简单，有兴趣可以另外查阅资料。this也是一个函数属性，但是是变量对象里的属性，不是定义好的函数属性。这我放在后面再介绍。</p>
<h6 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h6><p>　　不同函数可能会自己定义一些方法，例如上一讲提到的Object.defineProperty，Object.getOwnPropertyDescriptor等，都是在Object构造函数上定义的函数。</p>
<h4 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h4><p>　　当执行调用函数指令之后，内存里会产生一个变量对象，相当于从定义好的函数对象中激活出来一个新的特殊的函数对象。需要说明的是，变量对象并不都是函数对象，例如全局环境的window对象等，后面会再稍微提及一下。但变量对象的确主要是函数对象。要认识变量对象，先得从作用域链说起。</p>
<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>　　JavaScript只有全局作用域和函数作用域，没有块作用域。每个作用域都由一个变量对象表示。作用域链就相当于函数的调用栈。下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> tempColor = anotherColor;</div><div class="line">        anotherColor = color;</div><div class="line">        color = tempColor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    swapColor();</div><div class="line">&#125;</div><div class="line"></div><div class="line">changeColor();</div></pre></td></tr></table></figure>
<p>　　每个定义好的函数都有一个[[scope]]的内部属性，用来保存该函数调用前的作用域链。作用域链保存的就是变量对象。每个变量对象都维护一个作用域。</p>
<p>　　changeColor()调用前，它本身的变量对象还没有创建，没有被加入它的作用域链中，[[scope]]里只包含全局变量对象window。</p>
<p><img src="/img/scope1.jpg" alt="scope"></p>
<p>　　当调用changeColor后，调用swapColor前，会为changeColor创建一个执行环境，并复制changeColor的[[scope]]属性，赋值给该执行环境的作用域链，并在作用域链的前端插入由changeColor激活的一个变量对象。同时定义好的swapColor函数对象的[[scope]]内部属性，也会创建一个新的作用域链，包含全局作用域以及changeColor函数作用域。</p>
<p><img src="/img/scope2.jpg" alt="scope"></p>
<p>　　我们看到，在changeColor函数里定义的所有变量和函数都作为变量对象的属性和函数保存。changeColor的执行环境里可以直接访问changeColor变量对象的所有属性和方法，而不用以“changeColor变量对象.属性”或“changeColor变量对象.函数”的方式访问。实际上，除了window对象以外，JavaScript也不允许我们访问变量对象，只有解析器能够在后台访问它。由于changeColor的作用域中也包含全局变量对象，因此可以直接访问全局对象的所有属性和方法，而不用显式地用window.属性或window.函数来访问。</p>
<p>　　changeColor的变量对象也包含arguments对象，由于changeColor是window对象的函数，因此this指向window对象。这里再回顾一下上面提到的call和apply方法，调用定义好的函数的这两个方法，可以在创建变量对象时让this指向特定的对象，而不是默认地指向该函数所属的对象。如此，可以让方法与对象完全解耦合。</p>
<p>　　当swapColor函数调用之后，它也会从swapColor的内部属性[[scope]]中复制作用域链，并且创建一个变量对象，插入到作用域链的前端。swapColor函数内可以直接访问其本身的变量对象，changeColor变量对象以及全局变量对象的所有属性与方法。</p>
<p><img src="/img/scope3.jpg" alt="scope"></p>
<p>　　需要说明一点，swapColor的this指向的是window对象，它本身是changeColor变量对象的函数，但除window以外的变量对象是不能被访问的，它又不属于其他普通对象，因此仍被视为由window调用。</p>
<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>　　一般函数调用结束后，它的执行环境和作用域链都会被销毁，它的变量对象也会被销毁。但闭包是一个例外。</p>
<p>　　在JavaScript中，闭包是指有权访问另一个函数作用域中的变量的函数。通俗来说，就是在函数里面定义的函数。当闭包作为值被函数返回到再上一级的作用域时，由于它的[[scope]]仍然引用着上一级函数的变量对象，因此这个变量对象不会被销毁。下面修改一下上面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> tempColor = anotherColor;</div><div class="line">        anotherColor = color;</div><div class="line">        color = tempColor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    swapColor();</div><div class="line">    <span class="keyword">return</span> swapColor;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> swap = changeColor();</div></pre></td></tr></table></figure>
<p>　　本来，当changeColor执行结束以后，它的变量对象会被销毁。但由于swapColor的[[scope]]指向的作用域链引用了changeColor的变量对象，而swapColor还被window对象的swap属性引用了，因此不会被销毁，而只销毁changeColor本身的作用域链以及执行环境。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　这一讲主要介绍了函数对象，并重点分析了函数变量对象，以及引申出的作用域链以及闭包等知识点。下一讲将继续总结闭包的知识，总结一下怎么利用闭包与函数作用域来实现对象属性与方法的私有化，从而达到像java或c++的private权限控制的效果。欲知后事如何，请看下回分解。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从面向对象看JavaScript（一）]]></title>
      <url>http://wjqwsp.github.io/2016/09/13/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BJavaScript%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　JavaScript作为一种脚本语言，语法简单（求其），易上手，适合开发；同时，作为当今前端编程方面占据垄断地位，甚至逐步向后端发展的强势语言，它的前景十分美好，功能足够强大。既然是脚本语言，自然没有c,c++,Java等传统语言的严谨，但是利用它仍然可以基本覆盖其他语言能做到的高级功能。</p>
<p>　　下面我就从面向对象的角度，整合JavaScript里函数，对象，引用类型，原型，闭包，作用域链等知识点，去探讨JavaScript是如何定义对象，构造类，设置属性和函数的私有公有权限，实现继承，利用作用域以及管理内存的。下面的代码例子基本都出自《JavaScript高级程序设计》。<br><a id="more"></a></p>
<h3 id="创建单个对象"><a href="#创建单个对象" class="headerlink" title="创建单个对象"></a>创建单个对象</h3><p>　　与Java类似，JavaScript的所有对象都继承自Object类，我们可以在Object类的基础上扩展对象的属性与函数，从而创建出一个新的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"Nicholas"</span>;</div><div class="line">person.age = <span class="number">29</span>;</div><div class="line">person.job = <span class="string">"Software Engineer"</span>;</div><div class="line"></div><div class="line">person.sayName() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>　　对象包含属性与函数，可以直接在Object类对象上扩展。</p>
<p>　　用对象字面量的方式，可以更简单地定义对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    name: <span class="string">"Nicholas"</span>,</div><div class="line">    age: <span class="number">29</span>,</div><div class="line">    job: <span class="string">"Software Engineer"</span></div><div class="line"></div><div class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4><p>　　对象包含属性与函数，其中函数在JavaScript里也可以视为一种特殊的属性，会在下一节重点讲述。这里先总结一下属性，属性可以分为数据属性与构造器属性。</p>
<h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>　　JavaScript里的每一个属性都有一些特征，相当于是属性的属性，用于JavaScript底层维护属性。数据属性有4个特性，分别是Configurable,Enumerable,Writable与Value，规范里记为[[Configurable],[[Enumerable]],[[Writable]],[[Value]]。这些特性是不能直接访问的。</p>
<ul>
<li>[[Configurable]]：能否通过delete删除属性，能否修改属性特性，能否把属性修改为访问器属性。如果像上面直接在对象上创建属性，则默认为true。</li>
<li>[[Enumerable]]：能否通过for-in语法循环返回属性，默认为true。</li>
<li>[[Writable]]：能否修改属性的值，默认为true。</li>
<li>[[Value]]：属性的数据值，默认为undefined，像上面创建属性后就保存属性的值。</li>
</ul>
<p>　　除了直接在对象上创建属性以外，还可以通过Object.defineProperty()方法创建属性。这个方法接收3个参数，分别是属性所在对象，属性的名字，以及一个描述符对象。描述符对象的属性必须是configurable,enmuerable,writable和value。通过这个描述符对象，则可以定义属性的一或多个特性。在这种情况下，configurable,enumerable和writable默认为false。</p>
<p>　　这里要注意一点是，当把configurable设置为false，则不能再设置属性的特性，包括不能将configuralble重新设为true。</p>
<h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>　　访问器属性也具有[[Configurable]]和[[Enumerable]]特性，但没有[[Writable]]和[[Value]]，而替换为[[Get]],[[Set]]。[[Get]]和[[Set]]保存相应的函数，默认为undefined。当用一般的JavaSript读写该属性时，则会分别调用[[Get]]和[[Set]]里保存的函数，从而返回或写入相应的值。这就相当于Java里的getter和setter方法。只定义getter则不能写，只定义setter则不能读。访问器属性只能通过Object.defineProperty方法定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    _year: <span class="number">2004</span>,</div><div class="line">    edition: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>)&#123;</div><div class="line">            <span class="keyword">this</span>._year = newValue;</div><div class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.year);</div></pre></td></tr></table></figure>
<p>　　第一次访问book.year是写数据，调用setter方法，第二次访问book.year是读数据，调用getter方法。在Java里，getter和setter往往是针对私有属性的，用于向外界提供访问私有属性的一个公共接口，但访问器属性我觉得并不是为了这个目的而产生的。访问器属性，往往与一个数据属性相关联，例如这里的_year。这里_year前面的下划线是一种规范，用于表示与某个访问器属性相关联的数据属性。访问器属性是用于在设置一个属性的同时，导致其他属性的变化，这是它的最主要作用。至于私有公有属性的权限设定，则是由另外的技术实现的，这我也将会在后面几讲阐述。</p>
<h5 id="同时定义多个属性"><a href="#同时定义多个属性" class="headerlink" title="同时定义多个属性"></a>同时定义多个属性</h5><p>　　可以用Object.defineProperties()方法，这个方法接收两个对象参数，一个是要添加和修改其属性的对象，另一个对象包含多个对象属性，每个属性与要添加或修改的属性一一对应，这些对象属性里的属性则是要定义的属性特性。</p>
<h5 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h5><p>　　用Object.getOwnPropertyDescriptor()方法可以获取给定属性的描述符，这个描述符对象的属性则是相应属性的特性。这个方法接收两个参数，分别是属性所在的对象和其描述符的属性名称。</p>
<p>　　这个描述符对象的属性便是原对象对应属性的特性。
　　</p>
<h3 id="构造类"><a href="#构造类" class="headerlink" title="构造类"></a>构造类</h3><h4 id="简易生产对象——工厂模式"><a href="#简易生产对象——工厂模式" class="headerlink" title="简易生产对象——工厂模式"></a>简易生产对象——工厂模式</h4><p>　　如果按照上面创建对象的方法，那么每次创建具有相同属性和方法的对象，都需要手动写一遍重复的代码。我们希望像其他面向对象语言一样，有“类”的概念，可以通过一个封装好的方法，批量地生成同一类型的对象。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>　　creatPerson就是一个工厂方法，封装了创建对象的代码，使得批量生产对象变得十分简单。</p>
<p>　　但是，工厂模式存在两个主要的问题。第一个是虽然能够封装创建对象的代码，但是仍然不能将这个对象称为“类”，无法识别这些具有相同属性类型和方法的对象是属于同一个类的；第二个是，一般的面向对象语言，属于同一类的对象共享同一套方法，但属性则各有不同。具体到内存里，以java为例，它的类里的实例方法都是存储在代码区的，同一类的不同对象是共享代码区的相同方法的，而属性则存储在堆栈或堆里，各个对象不同。</p>
<p>　　JavaScript作为成熟的面向对象语言，这两个问题当然是可以解决的。下面我们分别来分析一下。</p>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>　　构造函数本身与普通函数是没有区别的。按照惯例，构造函数一般以大写字母开头，普通函数则以小写字母开头。如果不用new操作符，则调用构造函数与调用普通函数没有任何区别。如果调用了new操作符，且构造函数内部没有return，则会经历以下四个步骤：</p>
<ol>
<li>创建一个新对象。</li>
<li>将构造函数的作用域赋给新对象。（this指向新对象）</li>
<li>执行构造函数中的代码。</li>
<li>返回新对象</li>
</ol>
<p>　　<br>　　利用构造函数生成的对象，都有一个constructor属性，指向Person函数。我们可以用这个属性来作为类判别的依据。但更可靠的做法是用instanceof操作符，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></div><div class="line">alert(person1 <span class="keyword">instanceof</span> Person);  <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>　　由于Person类继承自Object类，因此person1既可以说是Object类的对象，也可以说是Person类的对象。</p>
<h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>　　每当创建一个新函数，该函数都自动获得一个prototype属性，该属性指向函数的原型对象。这个原型对象本身与普通的实例对象没有任何区别。通过构造函数创建的对象，都会含有一个内部属性[[prototype]]，这个内部属性不能直接访问，其指向构造函数的原型对象。显然，所有通过该构造函数创建的对象，都有这么一个指针指向同一个原型对象。我们访问实例对象的属性和方法，会先看看实例对象有没有相应的属性或方法，没有的话再从原型对象上找。因此，我们可以把类里的实例方法以及共有的属性都定义在原型对象上，而把每个实例对象都不同的属性定义在实例上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</div><div class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<p>　　sayName方法定义在原型对象上，其他属性则直接定义在实例对象上。为了更好地封装代码，动态原型模式把原型的属性和方法定义都包含在构造函数里，而没有放在构造函数外面进行。但这样存在一个问题，就是每创建一个实例，都会定义一个新的函数，因此我们需要通过一个判断语句，来判断sayName函数是否已被初始化。如果有多个函数定义在原型对象上，我们也只需要判断一个函数有没有被初始化就可以了，因为初始化都是一起进行的，一个函数初始化了说明其他函数也被初始化。</p>
<p>　　原型对象，实例对象，构造函数的关系：</p>
<p><img src="/img/prototype.jpg" alt="prototype"></p>
<p>　　由于访问对象的方法和属性时，是按照先实例对象再原型对象进行的，因此在实例对象上创建的同名属性或方法可以覆盖原型对象上的属性或方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　面向对象语言的最基本特点就是有对象，有类，类里面定义了属性和方法。这一讲简单地介绍了怎么创建对象，怎么构造类，以及引入了原型的概念，总结了怎么利用原型与构造函数来定义实例属性，实例方法和共享属性。关于JavaScript的面向对象设计部分，还有很多内容，欲知后事如何，请看下回分解。
　　
　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PostgreSQL MVCC机制浅析]]></title>
      <url>http://wjqwsp.github.io/2016/09/05/PostgreSQL-MVCC%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="从丢失更新说起"><a href="#从丢失更新说起" class="headerlink" title="从丢失更新说起"></a>从丢失更新说起</h3><p>　　上一讲提到了数据并发在数据库中的四大问题，其中一个便是丢失更新。丢失更新的产生是当两个事务同时读某一记录时，A事务先修改该记录，B事务再修改的时候把A的修改覆盖掉，导致A事务的更新丢失了。更具体的例子可以参考上一讲。数据库处理丢失更新有两种方法，分别是悲观锁方法与乐观锁方法。</p>
<h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p>　　对于某一特定的业务需求，如果实现该需求需要并发地更新数据库的同一记录，就有可能发生冲突。解决这种冲突可以选择两种办法，分别是悲观锁与乐观锁。<br><a id="more"></a></p>
<ol>
<li>悲观锁：悲观锁认为更新冲突是经常发生的，因此通过传统加锁的办法，让事务分别独占某一记录，解决并发的冲突。具体到丢失更新这一问题，悲观锁的解决方法有两个，第一是用select for update，手动加上排它锁，在整个事务周期内便不可能再允许其他事务修改或读取这一记录；第二是用Repeatable Read的事务隔离级别，让共享锁与排它锁的持有时间都是整个事务周期，便自然杜绝了并发更新的发生。</li>
<li>乐观锁：乐观锁认为更新冲突是几乎不会发生的，当发生冲突时便会阻碍，返回错误信息，让用户决定重新开启事务还是放弃。乐观锁的实现一般是应用程序级别的，数据库里很少提供这种实现。具体的方法是在所有元组后面都加上版本号属性，每次修改记录都会更新版本号。用户在读取记录的时候把版本号一同读出，在修改时候再判断版本号是否与原来的一致，一致则继续更新，否则说明有其他事务更新了该记录，返回错误。</li>
</ol>
<h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>　　MVCC，即多版本并发控制，是一种与传统锁机制有区别的一种控制并发的方法。从上一讲看到，事务隔离等级从低到高就是锁的不断增多的过程，必然导致性能的逐渐下降。而MVCC，则做到了读与读不冲突，读与写不冲突，只有写与写才需要锁去控制冲突。不同的读操作根据事务版本的不同，看到的视图是不一样的。因此即使事务A修改某一记录，事务B读到的记录是处于另一版本视图下的，与事务A的写操作自然隔离了，并不需要锁的控制。这种多版本控制读操作视图的方法，在PostgreSQL里实际上是采用了乐观锁来实现的。下面我将先阐述PostgreSQL里MVCC是如何与事务隔离等级结合起来的，然后再仔细分析MVCC的实现原理，由表到里地分析PostgreSQL里的MVCC机制。</p>
<h3 id="PostgreSQL-MVCC与事务隔离等级"><a href="#PostgreSQL-MVCC与事务隔离等级" class="headerlink" title="PostgreSQL MVCC与事务隔离等级"></a>PostgreSQL MVCC与事务隔离等级</h3><p>　　上一讲我们讲到了数据库的事务隔离等级要求，但这只是最低的要求，实际上具体数据库的实现可以更加严格，每个数据库的实现机制与锁控制方式也大相径庭。下面我们先来看看PostgreSQL的事务隔离等级是怎么样的：</p>
<table>
<thead>
<tr>
<th>Isolation Level</th>
<th>Dirty Read</th>
<th>Nonrepeatable Read</th>
<th>Phantom Read</th>
<th>Serialization Anomaly</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read uncommitted</td>
<td>Allowed, but not in PG</td>
<td>Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>Read committed</td>
<td>Not possible</td>
<td>Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>Repeatable read</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Allowed, but not in PG</td>
<td>Possible</td>
</tr>
<tr>
<td>Serializable</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Not possible</td>
</tr>
</tbody>
</table>
<p>　　从上表可以看到,PostgreSQL的事务隔离等级更加严格。它实际上只有3个隔离等级。如果选择了Read uncommited，相当于选择了Read commited，因为Read uncommited也是不允许脏读的。而Repeatable read级别在postgreSQL里也不存在幻读。除此以外，这里还引入了一个新的数据冲突问题：序列化异常。Serializable与Repeatable read在postgreSQL里是基本一样的，除了Serializable不允许序列化异常。关于不同事物隔离等级的具体细节，下面将一一介绍。</p>
<h4 id="Read-commited"><a href="#Read-commited" class="headerlink" title="Read commited"></a>Read commited</h4><p>　　主要看看Read commited是怎么解决脏读的。当事务处于这一隔离等级时，每次读写操作前都会对目前数据库拍一个快照，这个快照就是在当前读写操作发生前，所有已提交的事务对数据库做出的所有更改的结果。因此，在读操作进行时其他事务发生的更改都不会影响这个快照。而由于这个快照包含的是所有已提交的更改结果，因此其他未提交的事务作出的所有更改都不会被当前读操作看到，从而避免了脏读的发生。这就让读与写彻底分离开来，因为读写操作看到的数据库是不一样的。要注意的是，当前事务对数据库作出的修改会影响快照，可以被当前事务的读操作读到修改后的元组。</p>
<p>　　那么写与写冲突怎么办呢？</p>
<p>　　实际上，对某一记录的写操作在postgreSQL里仍然是加锁的，只是这个锁只阻塞写，不阻塞读。当事务A更改了某记录而未提交，事务B又要更改该记录时，事务B便会阻塞，直到事务A提交或回滚。如果事务A回滚，说明该记录的更新没有生效，则事务B继续正常更新该记录；如果事务A正常提交，事务B便需要判断原更新条件是否仍然生效，如果仍生效则继续B的更新，否则直接忽略B的更新。</p>
<p>　　然而对于某些较为复杂的查询，Read commited的级别是会产生一些问题的。下面我就分析一下官方文档给出的错误例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BEGIN</span>;</div><div class="line"><span class="keyword">UPDATE</span> website <span class="keyword">SET</span> hits = hits + <span class="number">1</span>;</div><div class="line"><span class="comment">-- run from another session:  DELETE FROM website WHERE hits = 10;</span></div><div class="line"><span class="keyword">COMMIT</span>;</div></pre></td></tr></table></figure>
<p>　　假设现在数据库有一个website表，该表有一个hit属性。目前数据库里该表只有两条记录，分别是hit=9与hit=10。现在又有两个事务，事务A进行update操作，事务B进行delete操作，如上面代码所示。update操作前会对数据库拍一个快照，此时快照里分别是hit=9和hit=10的两条记录，我们记为记录x与记录y，操作后记录x的hit=10，记录y的hit=11。delete操作前也会对数据库拍一个快照，因为快照仅包含已提交的事务产生的结果，因此此时快照里只有记录y（此时记录x的hit=9，记录y的hit=10）。由于存在并发更新，因此事务B的delete会阻塞。当事务A提交后，记录y的hit=11，已经不满足事务B的delete的条件，因此事务B的delete操作失败。而实际上，我们更希望事务B能把记录x（由于事务A的更新此时记录x的hit为10）删除，但由于事务B的快照里不包含记录x，因此会被忽略。</p>
<h4 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h4><p>　　postgreSQL的Repeatable read解决了重复读与幻读的问题。当事务处于这一隔离等级下时，每次事务开启后进行的第一个读写操作前拍摄快照，此后在整个事务周期沿用这个快照，而不是在每一条读写操作前拍摄快照。因此，当事务A开启后，即便事务B对事务A读取的记录作出更改并提交，也不会影响事务A的快照。事务A由始至终读取的结果都是一样的。这个过程完全不需要锁的控制，两个事务都是并发进行的，并且互不影响，因为两个事务都是对自己拍摄的数据库快照操作。与Read commited一样，当前事务作出的修改会影响快照。</p>
<p>　　写与写的冲突仍和Read commited一样，通过加锁阻塞控制的。Repeatable read对于并发更新冲突更加严格，仍以事务A与事务B为例，当事务A更改了某记录而未提交，事务B又要更改该记录时，事务B便会阻塞，直到事务A提交或回滚。如果事务A回滚，说明该记录的更新没有生效，则事务B继续正常更新该记录；如果事务A正常提交，无论事务B的更新条件是否仍然生效，都会直接抛出下面的异常：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR:  could not serialize access due to concurrent <span class="keyword">update</span></div></pre></td></tr></table></figure>
<p>　　用户捕捉到这种异常，可以自行选择是重新开启事务B还是放弃该事务操作。显然，这个就是典型的乐观锁控制并发的方法。</p>
<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>　　在postgreSQL里，这一隔离级别是伪串行化，并不是如上一讲所说的最强封锁协议，即什么都加锁，什么都真正串行处理。但是，postgreSQL这一隔离等级下它的功能表现得与真正的串行化别无二致，用户可以直接认为所有事务都是串行化执行。实际上它的隔离机制与Repeatable read相差无几，无论是快照拍摄的时机还是并发更新冲突的处理都是一样的。唯一的区别便在于前面提到的Serialization Anomaly这一问题。</p>
<p>　　我们知道Repeatable read在事务开启后的第一个读写操作前拍摄快照，因此在该事务操作里其他事务的结果对当前事务都是毫无影响的。然而，有些业务场景下，事务与事务之间有可能存在依赖关系，我们需要所有事务都是串行化执行的。下面就以官方文档的例子为例，分析一下Serializable在postgreSQL里究竟有何神奇之处：</p>
<p>　　假设数据库里有一个mytab表：</p>
<p><img src="/img/mytab.png" alt="mytab"></p>
<p>　　事务A：</p>
<p><img src="/img/transactionA.jpg" alt="transactionA"></p>
<p>　　事务B：</p>
<p><img src="/img/transactionB.jpg" alt="transactionB"></p>
<p>　　事务A提交：</p>
<p><img src="/img/transactionA-commit.jpg" alt="transactionA commit"></p>
<p>　　Serializable力图在众多并发事务中寻求一条串行关系，即虽然这些事务是并发执行的，但在所有事务提交以后，如果存在读写依赖关系，可以将它们按先后顺序排序，使得它们表现得宛如串行执行一般。如果这种先后顺序因为并发事务而变得自相矛盾，则会抛出异常。在上面的例子里，事务A对所有class=1的元组的value属性求和，得出30，并将其作为value=30,class=2的元组插入表中；此时，另一个并发事务B对所有class=2的元组的value属性求和，因为两个事务使用的是不同的快照，事务A的修改不会被事务B看到，因此得出300而不是330。这时候，数据库实际上作出了一个假设：即事务B发生在事务A之前，因为事务B读出的值表现得如同是事务A插入数据以前发生的，也即发生了写读依赖。然而，事务B后面再插入了一个value=300,class=1的元组并提交以后，问题就发生了。由于在事务A中对所有class=1的元组的value属性求和时，并没有看到事务B插入的元组，因此数据库作出了另一个假设：即事务B发生在事务A之后，因为事务A读出的值表现得如同是事务B插入数据以前发生，这又是一个写读依赖。</p>
<p>　　这两个前后的假设显然是矛盾的，所以事务A与事务B违反了串行化要求，所以后提交的事务会抛出异常，此时用户可以选择重启事务或者放弃该事务操作。</p>
<h4 id="MVCC在何处体现"><a href="#MVCC在何处体现" class="headerlink" title="MVCC在何处体现"></a>MVCC在何处体现</h4><p>　　看完上面postgreSQL里三个事务隔离等级的介绍，相信读者大致了解其特点与原理。那么，所谓的MVCC，即多版本并发控制，又是在何处体现呢？显然，就是前面说的“快照”。快照，其实就是相应的版本视图，不同的事务根据事务版本的不同，看到数据库的不同侧面，从而实现读写分离。postgreSQL里快照的抽取十分简单，关键在于两个系统属性：xmin和xmax。下面我将简单分析一下postgreSQL的MVCC实现机制。</p>
<h3 id="MVCC实现机制"><a href="#MVCC实现机制" class="headerlink" title="MVCC实现机制"></a>MVCC实现机制</h3><p>　　在PostgreSQL里，每一个表都默认附加上两个只读的系统属性，xmin和xmax，这两个属性的值共同成为多版本控制的判断条件，所谓快照，实际上就是xmin和xmax满足一定条件的元组集合。</p>
<h4 id="xmin"><a href="#xmin" class="headerlink" title="xmin"></a>xmin</h4><p>　　如果显示地声明了事务，那么每个事务会自动生成一个事务ID作为标识，即txid；如果没有显示声明，那么每一条独立的语句将生成一个事务ID。当进行insert操作时，插入表新增的元组会额外生成一个xmin属性，其值等于当前的事务ID。换言之，元组的xmin属性的值永远等于其插入表时的事务ID。</p>
<h4 id="xmax"><a href="#xmax" class="headerlink" title="xmax"></a>xmax</h4><p>　　当插入元组时，xmax属性默认为0，表示未定义。当对该元组进行update或delete操作时，当前事务ID的值会被赋给xmax。PostgreSQL删除元组不会真的从表里删除数据，而是用xmax&gt;0来标识该元组被删除。而更新元组也不会直接在原来的元组上进行修改，而分为两步进行：第一步是修改原元组的xmax为当前事务ID；第二步是插入一条新的元组，其所有属性值等于原来元组修改过后的值，xmin为当前事务ID，xmax初始化为0。</p>
<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>　　快照就是某时刻下数据库所有元组的xmin和xmax满足一定条件的值的集合。三个事务隔离等级拍摄快照的时机不同，但其判断条件都是一样的。</p>
<p>　　总结一下判断条件：</p>
<ol>
<li>若xmin等于当前事务ID，则包含所有xmax=0（未被删除）的元组。</li>
<li>若与xmin相等的事务ID对应的事务已经被提交，则包含所有xmax=0或xmax为当前事务ID的元组。</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>　　为了帮助读者理解，更好地阐述MVCC的机制，这里设计了一个实例。</p>
<h5 id="初始化准备"><a href="#初始化准备" class="headerlink" title="初始化准备"></a>初始化准备</h5><p>　　建立test表，插入几条数据，如图示：</p>
<p><img src="/img/test-init.png" alt="test init"></p>
<p>　　表中插入了两条数据，我们可以读出xmin与xmax的值，由于这两条记录是同一个事务插入的，所以xmin相等，等于该事务ID 332919，xmax为0，表示未定义。</p>
<h5 id="Read-commited事务隔离等级下测试"><a href="#Read-commited事务隔离等级下测试" class="headerlink" title="Read commited事务隔离等级下测试"></a>Read commited事务隔离等级下测试</h5><p>　　分别开启事务A，B，事务隔离等级取默认的Read commit。事务A向test表插入一条记录，事务A和事务B再分别读取test表，两事务均不提交。</p>
<p>　　事务A：</p>
<p><img src="/img/test-a-2-insert.jpg" alt="test A"></p>
<p>　　事务B：</p>
<p><img src="/img/test-b-2-insert.jpg" alt="test B"></p>
<p>　　事务A插入元组后，可以看到test表多了一条xmin为332919，xmax为0的新元组。事务B不能看到事务A插入的新元组。</p>
<p>　　事务A修改id=1的元组，事务A和B分别读取test表，两事务均不提交。</p>
<p>　　事务A：</p>
<p><img src="/img/test-a-2-update.jpg" alt="test A"></p>
<p>　　事务B：</p>
<p><img src="/img/test-b-2-update.jpg" alt="test B"></p>
<p>　　事务A可以看到id为1的元组被修改了，此时它的xmin已经不是332919而是332920；而事务B仍然只能看到id=1的元组的value为aaa，没有改变，只是xmax设为332920。说明事务A看到update操作后新增的那条元组，而看不到原来的那条元组；事务B只看到原来的那条元组，而看不到新增的那条元组。</p>
<p>　　由此可见，Read commited事务隔离等级下不存在脏读。</p>
<p>　　事务A提交，事务B再读取test表。</p>
<p>　　事务A：</p>
<p><img src="/img/test-a-2-commit.jpg" alt="test A"></p>
<p>　　事务B：</p>
<p><img src="/img/test-b-2-commit.jpg" alt="test B"></p>
<p>　　事务A提交以后，事务B读到了事务A新增以及修改的元组。由此可见，Read commited事务隔离等级下存在不可重复读。</p>
<h5 id="Repeatable-read事务隔离等级下测试"><a href="#Repeatable-read事务隔离等级下测试" class="headerlink" title="Repeatable read事务隔离等级下测试"></a>Repeatable read事务隔离等级下测试</h5><p>　　将事务A与事务B提交，重新开启两个事务，其事务隔离等级设为Repeatable read，记为事务C与事务D，分别读取test表。</p>
<p>　　事务C：</p>
<p><img src="/img/transaction-cd-begin.jpg" alt="test C"></p>
<p>　　事务D：</p>
<p><img src="/img/transaction-cd-begin.jpg" alt="test D"></p>
<p>　　事务C修改test表id=2的元组并提交。事务D读取test表。</p>
<p>　　事务C：</p>
<p><img src="/img/test-c.jpg" alt="test C"></p>
<p>　　事务D：</p>
<p><img src="/img/test-d.jpg" alt="test D"></p>
<p>　　即便事务C提交了，事务D仍然只看到原来未修改前的元组，只是其xmax由0变成332921，即事务C的ID。可见Repeatable read事务隔离等级下不存在不可重复读。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　PostgreSQL的MVCC的多版本并发控制技术，用无锁技术控制并发，很好地解决了并发与性能的矛盾，使系统既能够控制并发冲突，又不会因为频繁加锁导致性能恶化。它的快照技术，仅仅通过xmin与xmax两个系统属性简单的判断便可实现，快照的拍摄完全没有时间与空间的消耗。事务的回滚非常方便，仅仅需要修改xmin和xmax属性即可。</p>
<p>　　但是，这种机制仍然有它的缺点。由于删除并不会真的在表里删除记录，更新操作也是通过插入新记录实现，那么表里会存在许多废旧的记录，占据存储空间，影响查找性能。PostgreSQL里有垃圾清除策略，会维护一个进程专门定期地清理过期的记录，但这个清理周期是不确定的，因此无用的废旧记录仍然会影响数据库的性能。</p>
<p>　　以上只是PostgeSQL并发控制的一部分知识，关于PostgreSQL的锁机制还有相当多的内容，其MVCC机制里除了xmin与xmax还有cmin与cmax两个系统属性没有涉及。由于篇幅所限，我对这部分理解也不是很足，这里就先不介绍了。以后有机会，我再另外写文章进行讲述。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库事务隔离级别与锁机制实现（转载）]]></title>
      <url>http://wjqwsp.github.io/2016/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>　　数据库并发处理是一个非常重要的问题，其实现本质上同应用程序一级的并发控制原理是一致的，也是通过加锁解决。而事务隔离级别相当于一段独立的代码块，具有原子性、一致性、隔离性、持久性4个特征。本来想自己写一篇总结，但看到有一篇文章总结得非常好，就直接转载过来。</p>
<p>　　以下内容转载自：<a href="http://www.songjie.info/" title="宋杰的站点" target="_blank" rel="external">宋杰的站点</a> » <a href="http://www.songjie.info/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" title="【转载】数据库事务隔离级别和锁实现机制" target="_blank" rel="external">【转载】数据库事务隔离级别和锁实现机制</a></p>
<p>　　原文的版式我修改了一下，有些跟核心内容无关的我删去了，某一两处内容我觉得不对的在后面加了备注。<br><a id="more"></a></p>
<h3 id="数据库事务处理中出现的数据不一致的情况"><a href="#数据库事务处理中出现的数据不一致的情况" class="headerlink" title="数据库事务处理中出现的数据不一致的情况"></a>数据库事务处理中出现的数据不一致的情况</h3><p>在多个事务并发做数据库操作的时候，如果没有有效的避免机制，就会出现种种问题。大体上有四种问题，归结如下：</p>
<h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><p>如果两个事务都要更新数据库一个字段x，x=100</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取X＝100</td>
<td>读取X＝100</td>
</tr>
<tr>
<td>写入x＝X+100</td>
<td>写入x＝X+200</td>
</tr>
<tr>
<td>事务结束x=200</td>
<td>事务结束x=300</td>
</tr>
<tr>
<td></td>
<td>最后x=300</td>
</tr>
</tbody>
</table>
<p>最后x=300</p>
<p>两个不同事务同时获得相同数据，然后在各自事务中同时修改了该数据，那么先提交的事务更新会被后提交事务的更新给覆盖掉，这种情况事务A的更新就被覆盖掉了、丢失了。</p>
<h4 id="脏读（未提交读）"><a href="#脏读（未提交读）" class="headerlink" title="脏读（未提交读）"></a>脏读（未提交读）</h4><p>防止一个事务读到另一个事务还没有提交的记录。 如：</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>写入x＝X+100（x=200）</td>
</tr>
<tr>
<td>读取X＝200（读取了事务B未提交的数据）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>事务回滚x=100</td>
</tr>
<tr>
<td></td>
<td>事务结束x=100</td>
</tr>
<tr>
<td>事务结束</td>
</tr>
</tbody>
</table>
<p>事务读取了未提交的数据，事务B的回滚，导致了事务A的数据不一致，导致了事务A的脏读 ！</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次的结果应该是一致的；如果不一致，就说明为不可重复读。</p>
<p>还是用上面的例子</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取X＝100</td>
<td>读取X＝100</td>
</tr>
<tr>
<td>读取X＝100</td>
<td>写入x＝X+100</td>
</tr>
<tr>
<td></td>
<td>事务结束，x=200</td>
</tr>
<tr>
<td>读取X＝200（此时，在同一个事务A中，读取的X值发生了变化！）</td>
<td></td>
</tr>
<tr>
<td>事务结束</td>
</tr>
</tbody>
</table>
<p>这种情况事务A多次读取x的结果出现了不一致，即为不可重复读 。</p>
<h4 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h4><p>事务A读的时候读出了15条记录，事务B在事务A执行的过程中 增加 了1条，事务A再读的时候就变成了 16 条，这种情况就叫做幻影读。</p>
<p>不可重复读说明了做数据库读操作的时候可能会出现的问题。</p>
<h3 id="事务隔离级别通过锁的实现机制"><a href="#事务隔离级别通过锁的实现机制" class="headerlink" title="事务隔离级别通过锁的实现机制"></a>事务隔离级别通过锁的实现机制</h3><h4 id="两个锁："><a href="#两个锁：" class="headerlink" title="两个锁："></a>两个锁：</h4><ol>
<li>排他锁 被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其他锁，也不能读取和修改该对象</li>
<li>共享锁 被加锁的对象可以被持锁事务读取，但是不能被修改，其他事务也可以在上面再加共享锁。</li>
</ol>
<p>特别的，对共享锁： 如果两个事务对同一个资源上了共享锁，事务A 想更新该数据，那么它必须等待 事务B 释放其共享锁。</p>
<p>在运用 排他锁 和 共享锁 对数据对象加锁时，还需要约定一些规则，例如何时申请 排他锁 或 共享锁、持锁时间、何时释放等。称这些规则为封锁协议（Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p>
<h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><h5 id="一级封锁协议-对应-read-uncommited"><a href="#一级封锁协议-对应-read-uncommited" class="headerlink" title="一级封锁协议 (对应 read uncommited)"></a>一级封锁协议 (对应 read uncommited)</h5><p>一级封锁协议是：事务 在对需要修改的数据上面（就是在发生修改的瞬间） 对其加共享锁（其他事务不能更改，但是可以读取-导致“脏读”），直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</p>
<p>一级封锁协议不能避免 丢失更新，脏读，不可重复读，幻读！</p>
<h5 id="二级封锁协议-（对应read-commited"><a href="#二级封锁协议-（对应read-commited" class="headerlink" title="二级封锁协议 （对应read commited)"></a>二级封锁协议 （对应read commited)</h5><p>二级封锁协议是：1）事务 在对需要更新的数据 上（就是发生更新的瞬间） 加 排他锁 （直到事务结束） ， 防止其他事务读取未提交的数据，这样，也就避免了 “脏读” 的情况。2）事务 对当前被读取的数据 上面加共享锁（当读到时加上共享锁），一旦读完该行，立即 释放该 该行的共享锁 – 从数据库的底层实现更深入的来理解，既是，数据库会对游标当前的数据上加共享锁 ， 但是当游标离开当前行的时候，立即释放该行的共享锁。<br>二级封锁协议除防止了“脏读”数据，但是不能避免 丢失更新，不可重复读，幻读 。</p>
<p>但在二级封锁协议中，由于读完数据后立即 释放共享锁，所以它不能避免可重复读 ，同时它也不能避免 丢失更新 ，如果事务A、B同时获取资源X，然后事务A先发起更新记录X，那么 事务B 将等待事务 A 执行完成，然后获得记录X 的排他锁，进行更改。这样事务 A 的更新将会被丢失。 具体情况如下：</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取X=100（同时上共享锁）</td>
<td>读取X=100（同时上共享锁）</td>
</tr>
<tr>
<td>读取成功（释放共享锁）</td>
<td>读取成功（释放共享锁）</td>
</tr>
<tr>
<td>UPDATE X=X+100 （上排他锁）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>UPDATING A（等待事务A释放对X的排他锁）</td>
</tr>
<tr>
<td>事务成功（释放排他锁）X=200</td>
<td></td>
</tr>
<tr>
<td></td>
<td>UPDATE X=X+200（成功上排他锁）</td>
</tr>
<tr>
<td></td>
<td>事务成功（释放排他锁）X=300</td>
</tr>
</tbody>
</table>
<p>由此可以看到，事务A的提交被事务B覆盖了，所以不能防止 丢失更新。</p>
<p>如果要避免 丢失更新，我们需要额外的操作， 对凡是读到的数据加 共享锁 和排他锁 ，这个往往需要程序员自己编程实现，比如在Oracle 中，需要加 SELECT FOR UPDATE 语句，表明，凡是该事务读到的数据，额外的加上排他锁，防止其他数据同一时间获取相同数据，这样就防止了 丢失更新 ！</p>
<h5 id="三级封锁协议-（对应reapetable-read-）"><a href="#三级封锁协议-（对应reapetable-read-）" class="headerlink" title="三级封锁协议 （对应reapetable read ）"></a>三级封锁协议 （对应reapetable read ）</h5><p>三级封锁协议是：二级封锁协议加上事务 在读取数据的瞬间 必须先对其加 共享锁 ，但是 直到事务结束才释放 ，这样保证了可重复读（既是其他的事务职能读取该数据，但是不能更新该数据）。</p>
<p>三级封锁协议除防止了“脏”数据，不可重复读和丢失更新。但是这种情况不能避免 幻读。由于该封锁协议只是对某行数据加锁，因此在事务 A 没有完成之前，事务 B 可以新增数据（因为不是对锁住的这一行操作），那么 当事务 A 再次读取的时候，事务B 新增的数据会被读取到，这样，在该封锁协议下，幻读 就产生了。</p>
<p>注：原文说该封锁协议不能避免丢失更新，但我认为是可以避免的。因为无论共享锁还是排它锁，在该事务隔离等级下，其持有时间都是整个事务周期，所以无论读还是写某一行记录都是独占的，不可能存在事务A和B并发读取数据的情况，同时只有一个事务能读取并修改数据。因此应该不会造成丢失更新。</p>
<p>进阶：repeatable read 导致死锁的情况（即便是 不同的资源在相同的顺序下获取）。 比如 事务1 读取 A，同时 事务2 也读取 A，那么事务1和事务2 同时对 A 上了共享锁，然后事务1 要UPDATE A，而此时 事务2 也要 UPDATE A，这个时候 事务1 等待 事务2 释放其在 A 上的共享锁，然后 事务2 要等待 事务1 释放其在 A 上的共享锁，这样，事务1 和 事务2 相互等待，产生死锁！（SQL Server/DB2 里面有 UPDATE LOCK 可以解决这种情况，具体的思路是，在 repeatable read 的情况下，将读取的数据 上的 UPDATE 锁，介于 共享锁 和 排他锁之间的一种锁，该锁的作用是 当出现上面这种情况后，事务1 和 事务2 对 A 上的是 UPDATE 锁，那么谁先 要修改 A，那么该事务就会将 UPDATE 锁可以顺利升级为 排他锁对该数据进行修改！）</p>
<h5 id="最强封锁协议（对应Serialization"><a href="#最强封锁协议（对应Serialization" class="headerlink" title="最强封锁协议（对应Serialization)"></a>最强封锁协议（对应Serialization)</h5><p>四级封锁协议是对三级封锁协议的增强，其实现机制也最为简单，直接对 事务中 所 读取 或者 更改的数据所在的表加表锁，也就是说，其他事务不能 读写 该表中的任何数据。这样所有的 脏读，不可重复读，幻读 ，都得以避免！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从压力测试看数据库连接池配置]]></title>
      <url>http://wjqwsp.github.io/2016/08/31/%E4%BB%8E%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h3><p>　　写过后台的都知道，在操作数据库之前，先要获得数据库连接，然后用数据库连接去进行数据库的增删改查等操作。建立连接和销毁连接都是一笔很大的性能开销，因此产生了连接池的技术。连接池与线程池一样，都是一种资源池，专门用于处理共享资源的。它可以维护一定数量的连接不销毁，当有连接申请时，从池中取出供客户使用；使用完毕则释放归还池中；当池中连接的数量不足时，还可以创建一部分连接。</p>
<h3 id="使用连接池的优点"><a href="#使用连接池的优点" class="headerlink" title="使用连接池的优点"></a>使用连接池的优点</h3><ol>
<li>减少建立连接与销毁连接的性能开销，避免频繁进行连接的建立与销毁，提升系统性能。</li>
<li>限制客户端向数据库发起的数据库访问，避免系统宕机，也避免过多的连接被直接拒绝。</li>
</ol>
<h3 id="数据库连接池的配置"><a href="#数据库连接池的配置" class="headerlink" title="数据库连接池的配置"></a>数据库连接池的配置</h3><p>　　目前有很多连接池框架，使用这些框架非常简单，最主要就是对一些参数进行配置。这些参数包括最大连接数，最小连接数等，参数取值不同，对应用的性能与稳定性会造成不同的影响。下面我就以Tomcat自带的DHCP数据库连接池为例，通过对一个微博Web系统的同一条微博进行并发的疯狂评论操作作压力测试，去看看数据库连接池的参数配置对系统会产生什么样的影响。相信通过下面的压力测试分析，读者们可以体会到上述使用连接池的优点，同时也可以结合上一讲对压力测试的介绍，加深对压力测试的理解，了解到压力测试在系统优化中起到什么样的作用。<br><a id="more"></a></p>
<h3 id="测试前的配置与代码准备"><a href="#测试前的配置与代码准备" class="headerlink" title="测试前的配置与代码准备"></a>测试前的配置与代码准备</h3><h4 id="Tomcat的DHCP配置文件"><a href="#Tomcat的DHCP配置文件" class="headerlink" title="Tomcat的DHCP配置文件"></a>Tomcat的DHCP配置文件</h4><p>　　如果Web应用是部署在Tomcat上的，其参数配置全在context.xml文件里。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version='1.0' encoding='utf-8'?&gt;</div><div class="line"><span class="comment">&lt;!--</span></div><div class="line">  Licensed to the Apache Software Foundation (ASF) under one or more</div><div class="line">  contributor license agreements.  See the NOTICE file distributed with</div><div class="line">  this work for additional information regarding copyright ownership.</div><div class="line">  The ASF licenses this file to You under the Apache License, Version 2.0</div><div class="line">  (the "License"); you may not use this file except in compliance with</div><div class="line">  the License.  You may obtain a copy of the License at</div><div class="line"></div><div class="line">      http://www.apache.org/licenses/LICENSE-2.0</div><div class="line"></div><div class="line">  Unless required by applicable law or agreed to in writing, software</div><div class="line">  distributed under the License is distributed on an "AS IS" BASIS,</div><div class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div class="line">  See the License for the specific language governing permissions and</div><div class="line">  limitations under the License.</div><div class="line">--&gt;</div><div class="line"><span class="comment">&lt;!-- The contents of this file will be loaded for each web application --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Context</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Resource</span></span></div><div class="line">      <span class="attr">name</span>=<span class="string">"jdbc/drp"</span></div><div class="line">      <span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span></div><div class="line">      <span class="attr">driverClassName</span>=<span class="string">"org.postgresql.Driver"</span></div><div class="line">      <span class="attr">maxIdle</span>=<span class="string">"100"</span></div><div class="line">	  <span class="attr">minIdle</span>=<span class="string">"100"</span></div><div class="line">      <span class="attr">maxWait</span>=<span class="string">"-1"</span></div><div class="line">      <span class="attr">username</span>=<span class="string">"postgres"</span></div><div class="line">      <span class="attr">password</span>=<span class="string">"gdzqzxwjs95"</span></div><div class="line">      <span class="attr">url</span>=<span class="string">"jdbc:postgresql://localhost:5432/weibo"</span></div><div class="line">      <span class="attr">maxActive</span>=<span class="string">"100"</span>/&gt;</div><div class="line">    <span class="comment">&lt;!-- Default set of monitored resources --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">WatchedResource</span>&gt;</span>WEB-INF/web.xml<span class="tag">&lt;/<span class="name">WatchedResource</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- Uncomment this to disable session persistence across Tomcat restarts --&gt;</span></div><div class="line">    <span class="comment">&lt;!--</span></div><div class="line">    &lt;Manager pathname="" /&gt;</div><div class="line">    --&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- Uncomment this to enable Comet connection tacking (provides events</span></div><div class="line">         on session expiration as well as webapp lifecycle) --&gt;</div><div class="line">    <span class="comment">&lt;!--</span></div><div class="line">    &lt;Valve className="org.apache.catalina.valves.CometConnectionManagerValve" /&gt;</div><div class="line">    --&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>name是连接池的名称，后台调用数据库连接是需要引用这个名称。</li>
<li>type数据源类型，因为后台用java搭建，这里用java的数据源类。</li>
<li>driverClassName是数据库的驱动，这里用的是postgresql数据库。</li>
<li>maxIdle代表最大空闲连接数，0代表没有限制。</li>
<li>minIdle代表最小空闲连接数。</li>
<li>maxWait代表最大等待时间，-1代表没有限制。</li>
<li>username是数据库的用户名。</li>
<li>password是数据库的密码。</li>
<li>url用于定位数据库。</li>
<li>maxActive代表最大连接数，0代表没有限制。</li>
</ul>
<p>　　下面的测试，我们主要围绕maxIdle,minIdle,maxWait和maxAcitve展开。</p>
<p>　　minIdle是数据库能维持的最小的空闲连接，当Web应用启动时，会自动创建连接到minIdle这个数目，此后minIdle便没有意义。</p>
<p>　　maxIdle代表数据库能维持的最大空闲连接，当minIdle数目的连接不够用时，连接池会继续创建连接。当总连接没有超过maxIdle时，新创建的连接如果被释放不会被销毁，仍然归还池中；当总连接数超过maxIdle时，如果有连接被释放那么这些连接会被销毁，直到使连接池的连接数量达到maxIdle。此后，数据库的总连接数不会少于maxIdle。</p>
<p>　　maxActive代表数据库能维持的最大连接数。当maxIdle数目的数据库连接仍然不够用时，连接池会继续创建连接，直到连接数达到maxActive。这些新创建的连接被释放时直接销毁，不归还池中。如果数据库连接池的总连接数达到maxAcitve，但仍然有连接申请，则这些连接会等待。一般maxIdle与maxAcitve的值应尽量接近，可以取maxIdle=maxActive。这样可以避免高负荷系统频繁创建与销毁连接。</p>
<p>　　maxWait是最大等待时间。前面说过，当数据库连接数达到maxActive,其余的连接申请会等待，而等待的最大时间就是maxWait。当等待时间超过maxWait，但仍然没有连接被释放时，则这些等待中的连接会被拒绝。</p>
<h4 id="后台获取和释放数据库连接代码"><a href="#后台获取和释放数据库连接代码" class="headerlink" title="后台获取和释放数据库连接代码"></a>后台获取和释放数据库连接代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Context ctx=<span class="keyword">new</span> InitialContext();</div><div class="line">DataSource ds=(DataSource)ctx.lookup(<span class="string">"java:comp/env/jdbc/drp"</span>);</div><div class="line">Connection conn = ds.getConnection();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</div><div class="line">                    conn.close();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception err1)&#123;</div><div class="line">                err1.printStackTrace();</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>　　代码很简单，连接释放还是直接用close方法，底层会由连接池实现连接归还而不销毁。</p>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><h4 id="测试任务"><a href="#测试任务" class="headerlink" title="测试任务"></a>测试任务</h4><p>　　利用JMeter作测试工具，对同一条微博作高并发的疯狂评论，对数据库而言就是对评论表作高并发的插入操作，同时并发更新微博表同一条记录的评论数属性。</p>
<h4 id="不用连接池"><a href="#不用连接池" class="headerlink" title="不用连接池"></a>不用连接池</h4><h5 id="1秒内启100个线程"><a href="#1秒内启100个线程" class="headerlink" title="1秒内启100个线程"></a>1秒内启100个线程</h5><p><img src="/img/压力测试1秒100.png" alt="压力测试1秒100"></p>
<h5 id="1秒内启200个线程"><a href="#1秒内启200个线程" class="headerlink" title="1秒内启200个线程"></a>1秒内启200个线程</h5><p><img src="/img/压力测试1秒200.png" alt="压力测试1秒200"></p>
<h5 id="1秒内启250个线程"><a href="#1秒内启250个线程" class="headerlink" title="1秒内启250个线程"></a>1秒内启250个线程</h5><p><img src="/img/压力测试1秒250.png" alt="压力测试1秒250"></p>
<h5 id="1秒内启300个线程"><a href="#1秒内启300个线程" class="headerlink" title="1秒内启300个线程"></a>1秒内启300个线程</h5><p><img src="/img/压力测试1秒300.png" alt="压力测试1秒300"></p>
<h5 id="错误及分析"><a href="#错误及分析" class="headerlink" title="错误及分析"></a>错误及分析</h5><p><img src="/img/连接拒绝异常.png" alt="连接拒绝异常"></p>
<p>　　以上测试从1秒启100个线程开始，不断增加测试的线程数，直到1秒内启动250个线程的时候开始出错。且启动线程的密集程度越高，错误率越高。此时后台抛出连接拒绝异常。</p>
<p>　　产生此异常，是因为数据库允许的连接数往往是有限的。以postgresql数据库为例，默认的数据库最大允许连接数为100，当同时占用的连接数超过100个时，便会把超过的连接直接拒绝掉，同时抛出连接拒绝异常。之所以1秒产生250个线程才出错，是因为如果机器运行足够快，前面启动的一部分线程已经运行完了可以被释放，以供后续产生的线程使用。总之，只要同时占用的连接数不超过100个，就不会拒绝连接；反之多余的连接会被拒绝。</p>
<h4 id="使用连接池，且maxActive超过100"><a href="#使用连接池，且maxActive超过100" class="headerlink" title="使用连接池，且maxActive超过100"></a>使用连接池，且maxActive超过100</h4><h5 id="配置maxActive-maxIdle-200，maxWait-1，1秒内启200个线程。"><a href="#配置maxActive-maxIdle-200，maxWait-1，1秒内启200个线程。" class="headerlink" title="配置maxActive = maxIdle = 200，maxWait = -1，1秒内启200个线程。"></a>配置maxActive = maxIdle = 200，maxWait = -1，1秒内启200个线程。</h5><p> <img src="/img/压力测试1秒200-too-many.png" alt="压力测试1秒200_too_many"></p>
<h5 id="错误及分析-1"><a href="#错误及分析-1" class="headerlink" title="错误及分析"></a>错误及分析</h5><p> <img src="/img/too-many-clients.png" alt="too_many_clients"></p>
<p>　　postgresql里默认的最大连接数是100，如果连接池数目超过数据库的连接数限制，则会抛出上述异常。因此maxActive参数不能超过数据库的连接数限制。特别注意的是，即便maxActive设为100，但如果除了此程序还有其他程序访问同一数据库，那么其他程序也会占用数据库连接数，使数据库可用连接小于100，从而使此程序抛出上述异常！因此，准确来说，连接池的maxActive参数应该是不能大于数据库最大的可用连接数！</p>
<h4 id="使用连接池，maxActive-100，maxWait设为5秒"><a href="#使用连接池，maxActive-100，maxWait设为5秒" class="headerlink" title="使用连接池，maxActive=100，maxWait设为5秒"></a>使用连接池，maxActive=100，maxWait设为5秒</h4><h5 id="设置maxIdle-maxActive-100-maxWait-5000，1秒内启250个线程"><a href="#设置maxIdle-maxActive-100-maxWait-5000，1秒内启250个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启250个线程"></a>设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启250个线程</h5><p><img src="/img/压力测试1秒250-pool.png" alt="压力测试1秒250_pool"></p>
<h5 id="设置maxIdle-maxActive-100-maxWait-5000，1秒内启300个线程"><a href="#设置maxIdle-maxActive-100-maxWait-5000，1秒内启300个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启300个线程"></a>设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启300个线程</h5><p><img src="/img/压力测试1秒300-pool.png" alt="压力测试1秒300_pool"></p>
<h5 id="设置maxIdle-maxActive-100-maxWait-5000，1秒内启400个线程"><a href="#设置maxIdle-maxActive-100-maxWait-5000，1秒内启400个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启400个线程"></a>设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启400个线程</h5><p><img src="/img/压力测试1秒400-pool.png" alt="压力测试1秒400_pool"></p>
<h5 id="设置maxIdle-maxActive-100-maxWait-5000，1秒内启450个线程"><a href="#设置maxIdle-maxActive-100-maxWait-5000，1秒内启450个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启450个线程"></a>设置maxIdle = maxActive = 100,maxWait = 5000，1秒内启450个线程</h5><p><img src="/img/压力测试1秒450-pool.png" alt="压力测试1秒450_pool"></p>
<h5 id="错误及分析-2"><a href="#错误及分析-2" class="headerlink" title="错误及分析"></a>错误及分析</h5><p><img src="/img/timeout-wating-for-idle.png" alt="timeout_wating_for_idle"></p>
<p>　　当1秒启400个线程以上时，后台会抛出上述异常。</p>
<p>　　因为上面的测试maxWait设为5秒，当请求的连接数大于maxActive时，连接池不会再创建新的连接，而是等待已有的连接变为空闲。当等待的时间超过maxWait设定的时间，则会抛出上述异常。</p>
<h4 id="maxWait无限制"><a href="#maxWait无限制" class="headerlink" title="maxWait无限制"></a>maxWait无限制</h4><h5 id="设置maxIdle-maxActive-100，maxWait-1，1秒内启400个线程"><a href="#设置maxIdle-maxActive-100，maxWait-1，1秒内启400个线程" class="headerlink" title="设置maxIdle = maxActive = 100，maxWait = -1，1秒内启400个线程"></a>设置maxIdle = maxActive = 100，maxWait = -1，1秒内启400个线程</h5><p><img src="/img/1秒启400.png" alt="1秒启400"></p>
<h5 id="设置maxIdle-maxActive-100，maxWait-1，1秒内启500个线程"><a href="#设置maxIdle-maxActive-100，maxWait-1，1秒内启500个线程" class="headerlink" title="设置maxIdle = maxActive = 100，maxWait = -1，1秒内启500个线程"></a>设置maxIdle = maxActive = 100，maxWait = -1，1秒内启500个线程</h5><p><img src="/img/1秒启500.png" alt="1秒启500"></p>
<h5 id="设置maxIdle-maxActive-100-maxWait-1，1秒内启700个线程"><a href="#设置maxIdle-maxActive-100-maxWait-1，1秒内启700个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = -1，1秒内启700个线程"></a>设置maxIdle = maxActive = 100,maxWait = -1，1秒内启700个线程</h5><p><img src="/img/1秒启700.png" alt="1秒启700"></p>
<h5 id="设置maxIdle-maxActive-100-maxWait-1，1秒内启1000个线程"><a href="#设置maxIdle-maxActive-100-maxWait-1，1秒内启1000个线程" class="headerlink" title="设置maxIdle = maxActive = 100,maxWait = -1，1秒内启1000个线程"></a>设置maxIdle = maxActive = 100,maxWait = -1，1秒内启1000个线程</h5><p><img src="/img/1秒启1000.png" alt="1秒启1000"></p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>　　只要maxWait不加限制，且连接池设置的最大连接数不超过数据库允许的最大连接数，无论有多少的连接请求，都不会抛出异常，不会有错误。但是由于内存的限制，过多的请求必然导致响应时间变长，用户体验变差。为了测试方便，上面的压力测试我是没有用Duration Assertion的，只通过Response Assertion对http response的返回内容作断言判断是否正确返回。下面，我就对压力测试加上Duration Assertion，对登录响应限制为5秒，对评论微博的响应限制为10秒，继续进行测试。</p>
<h4 id="设置Duration-Assertion"><a href="#设置Duration-Assertion" class="headerlink" title="设置Duration Assertion"></a>设置Duration Assertion</h4><h5 id="设置maxIdle-maxActive-100，maxWait-1，1秒内启150个线程"><a href="#设置maxIdle-maxActive-100，maxWait-1，1秒内启150个线程" class="headerlink" title="设置maxIdle = maxActive = 100，maxWait = -1，1秒内启150个线程"></a>设置maxIdle = maxActive = 100，maxWait = -1，1秒内启150个线程</h5><p><img src="/img/1秒150-time.png" alt="1秒150_time"></p>
<h5 id="设置maxIdle-maxActive-100，maxWait-1，1秒内启200个线程"><a href="#设置maxIdle-maxActive-100，maxWait-1，1秒内启200个线程" class="headerlink" title="设置maxIdle = maxActive = 100，maxWait = -1，1秒内启200个线程"></a>设置maxIdle = maxActive = 100，maxWait = -1，1秒内启200个线程</h5><p><img src="/img/1秒200-time.png" alt="1秒200_time"></p>
<h5 id="设置maxIdle-maxActive-100，maxWait-1，1秒内启250个线程"><a href="#设置maxIdle-maxActive-100，maxWait-1，1秒内启250个线程" class="headerlink" title="设置maxIdle = maxActive = 100，maxWait = -1，1秒内启250个线程"></a>设置maxIdle = maxActive = 100，maxWait = -1，1秒内启250个线程</h5><p><img src="/img/1秒250-time.png" alt="1秒250_time"></p>
<h5 id="错误及分析-3"><a href="#错误及分析-3" class="headerlink" title="错误及分析"></a>错误及分析</h5><p>　　综上，只要将连接池的最大等待时间不加限制，无论有多大的并发访问都不会因为异常而使数据库操作失败，从而导致错误。主要的性能瓶颈来自于机器内存，过多的请求会使响应时间急剧恶化，严重降低用户体验。这也是根据压力测试的结果能作出的软件上的最大优化。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　建议所有后台的数据库连接都采用连接池技术。上面的压力测试暴露的问题全是出自数据库连接上，其实像疯狂评论这样的并发操作，特别容易产生数据库死锁或者序列化并发更新异常等更难解决的错误。后面我还会再对数据库的锁机制做一些总结，分析一下为什么上面的压力测试不会出现死锁等更严重的错误，以及这些错误是怎么产生的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMeter压力测试基础]]></title>
      <url>http://wjqwsp.github.io/2016/08/29/jmeter%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h3 id="什么是压力测试"><a href="#什么是压力测试" class="headerlink" title="什么是压力测试"></a>什么是压力测试</h3><p>　　当我们开发完一个Web系统，实现了需求中的所有功能，此时还不能马上将其上线。我们必须对这个系统进行充分的，全面的测试，最大程度地确保它不会出错。压力测试就是这些测试的一种。压力测试的目的是为系统模拟一个现实的访问场景，建立一堆线程去并发地访问系统，了解这个Web系统能支持多大的并发量，或者说支持多少用户同时在线而不会崩溃。我们通过调整并发的线程数，访问时间等参数，去了解在一定的硬件配置下，我们的系统能支持多少线程在多少时间内同时访问。在确定了这些测试数据以后，我们便对这个Web系统的性能有一个比较客观全面的了解，从而可以更好地寻求优化的方案。</p>
<h3 id="关于JMeter"><a href="#关于JMeter" class="headerlink" title="关于JMeter"></a>关于JMeter</h3><p>　　JMeter是用java实现的开源的压力测试工具，功能强大，使用简单，在压力测试中占据极其重要的地位。这一讲就以JMeter对一个简单的微博系统进行压力测试的实例入手，介绍一下JMeter最基本的一些知识，看看JMeter是怎么对HTTP request进行测试的。虽然是以实例的形式去介绍，但涉及的都是JMeter最基本的内容，更深入的学习还需不断参考JMeter官方文档。<br><a id="more"></a></p>
<h3 id="微博系统测试任务"><a href="#微博系统测试任务" class="headerlink" title="微博系统测试任务"></a>微博系统测试任务</h3><ol>
<li>登录</li>
<li>对某用户进行关注</li>
<li>对某用户取消关注</li>
<li>发一条微博</li>
<li>查找自己的微博列表</li>
<li>对刚刚发的微博添加一条评论</li>
<li>查找该微博的评论列表</li>
<li>删除刚刚添加的评论</li>
<li>删除刚刚发的微博</li>
<li>登出</li>
</ol>
<p>　　以上测试基本涵盖了我们这个微博系统的所有功能。我们这个微博系统是已经实现好的，后台采用简单的servlet实现。我们只需要根据这个微博系统不同servlet的输入参数和返回内容进行测试即可。其他任何Web系统的压力测试也可以套用或者参考。</p>
<h3 id="建立线程组"><a href="#建立线程组" class="headerlink" title="建立线程组"></a>建立线程组</h3><p>　　在官网上下载了JMeter以后，便可以运行jmeter.sh，打开JMeter的图形操作界面。此时，我们只看到一个空白的Test Plan，可以修改Test Plan的名字。</p>
<p><img src="/img/Test-Plan.jpg" alt="Test Plan"></p>
<p>　　右键点击左边栏的Test Plan，可以新建线程组。线程组就是我们配置线程，模拟并发访问的地方。</p>
<p><img src="/img/Thread-Group.jpg" alt="Thread Group"></p>
<ul>
<li>Number of Threads是一共要启的线程数。</li>
<li>Ramp-up Period是用多少时间启动线程组。假如Number of Threads我们填了10，Ramp-up Period填了100，那么每10秒会启动一个线程，100秒会启动完所有线程。</li>
<li>Loop Count是循环运行线程组的次数，默认运行一次，不循环。</li>
</ul>
<p>　　在测试过程中，我们要不断修改上面这3个参数，尤其是前两个。我们需要试出合适的参数，启动线程的频率不能太快也不能太慢，太慢往往所有线程都运行成功，且最后一个线程启动时前面的线程有些已经结束，达不到测试的效果，太快则产生一堆错误。使得系统刚好出错的参数配置，就是性能的临界点。</p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="HTTP-Request-Defaults"><a href="#HTTP-Request-Defaults" class="headerlink" title="HTTP Request Defaults"></a>HTTP Request Defaults</h4><p>　　在线程组下建立HTTP Request Defaults这个配置元素。由于我们需要测试的微博系统其域名或IP地址是固定的，访问的端口号也是固定的。我们进行的所有HTTP Request测试都要填写相同的IP和端口号，十分麻烦，修改也要全部修改。HTTP Request Defaults就是让我们在一个地方填写好基本配置信息，在同一作用域下的所有HTTP Request测试都能应用这个配置。假设我们的微博系统是建立在本机的，端口号采用Tomcat默认的8080,则配置如下：</p>
<p><img src="/img/http-request-defaults.jpg" alt="Http Request Defaults"></p>
<h4 id="HTTP-Cookie-Manager"><a href="#HTTP-Cookie-Manager" class="headerlink" title="HTTP Cookie Manager"></a>HTTP Cookie Manager</h4><p>　　很多网站需要用cookie记录用户的登录信息，在用户登录以后，之后的Http Request便带有登录过的cookie信息，进而访问网站资源。没有携带这些cookie数据的需要重新登录。在进行压力测试，模拟并发访问时，登录后的后续测试都需要携带相应的cookie才能正常进行测试。HTTP Cookie Manager便可以让我们的所有Http Request都共用同样的cookie。</p>
<p><img src="/img/http-cookie-manager.jpg" alt="Http Cookie Manager"></p>
<h4 id="Constant-Timer"><a href="#Constant-Timer" class="headerlink" title="Constant Timer"></a>Constant Timer</h4><p>　　用户在实际访问网站时，每一个操作之间往往有一定的时间间隔，不可能不间断地进行。为了真实地模拟用户行为，我们需要一个延时的功能，让每个线程启动之间有一定的时延。这个需求Constant Timer可以满足。</p>
<p><img src="/img/constant-timer.jpg" alt="Constant Timer"></p>
<p>　　如图所示，Thread Delay便是以毫秒为单位的固定时延数。除了固定时延，还有其他的计时器可以实现时延效果。</p>
<h3 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h3><p>　　我们可以用多种形式来呈现测试结果。下面介绍比较常用的两种，结果树和聚合报告。</p>
<h4 id="结果树"><a href="#结果树" class="headerlink" title="结果树"></a>结果树</h4><p>　　结果树能顺序地把每一个线程的每个测试的结果列出来，绿色代表成功，红色代表失败，并且可以查看每个测试的具体信息，例如request和response的具体内容，可以知道哪里出错。</p>
<p><img src="/img/view-results-tree.jpg" alt="View Results Tree"></p>
<h4 id="聚合报告"><a href="#聚合报告" class="headerlink" title="聚合报告"></a>聚合报告</h4><p>　　结果树能看到具体的测试信息，但缺乏整体的概览。我们希望知道进行了多少测试，失败率多少，平均耗时是多少，聚合报告便能很清晰地提供给我们这些信息。</p>
<p><img src="/img/aggregate-report.jpg" alt="Aggregate Report"></p>
<p>　　我们可以把结果树和聚合报告都添加进线程组内，结合两个测试报告去分析我们的结果。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>　　<br>　　断言用于定义一些判断测试请求是否正确的规则。</p>
<p>　　默认情况下，如果http response的状态码是200就表示测试正确。但实际情况要复杂很多，response返回200只能表示正常访问到资源，很有可能相应的业务逻辑不正确。下面介绍两种比较常用的判断请求是否正确的手段，都是用断言实现的，分别是Response Assertion和Duration Assertion。</p>
<h4 id="Response-Assertion"><a href="#Response-Assertion" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p>　　一般情况下，对于每一个http request，相同的输入参数应该会让http response返回相同的内容。这些内容可能是html页面，也可能是一些返回数据。通过添加Response Assertion到相应的测试Sampler上，如果response的返回包含某些内容就说明正确，不包含就说明失败。</p>
<p><img src="/img/login-response.jpg" alt="Response Assertion"></p>
<p>　　如果response返回含有”success”字段，就说明成功；否则失败。</p>
<p>　　下面进行的测试实例，全部使用Response Assertion。</p>
<h4 id="Duration-Assertion"><a href="#Duration-Assertion" class="headerlink" title="Duration Assertion"></a>Duration Assertion</h4><p>　　只是返回结果正确，也不能达到测试效果。在实际业务环境中，页面返回的快慢是影响用户体验的致命因素。当并发量大时，用户在进行页面操作时很容易会有时延。因此，在进行压力测试时，我们有理由定义一个延时范围，当超过这个时间还没有response返回说明失败；在延时范围内返回response说明成功。Duration Assetion就是完成这项工作的。</p>
<p><img src="/img/duration-assertion.jpg" alt="Duration Assertion"></p>
<p>　　上面就定义了延时范围为5000毫秒。超过5000毫秒还没返回http response视为失败；否则为成功。</p>
<p>　　下面进行的测试实例，全部使用Duration Assertion，且Duration in milliseconds全部设为5000毫秒，就不一一列举了，在分析时候只列出Response Assertion设置。</p>
<h3 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h3><h4 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h4><p>　　JMeter里对HTTP Request的测试是用Sampler里的HTTP Request进行的。我们可以在里面添加HTTP Request的Parameter，以及URI。</p>
<p>　　登录一般需要用户名和密码。为了测试方便，我预先在微博系统对应的数据库里添加好一定量的用户，他们的用户名与id相同，密码统一为gdzq。id按加一自增长的策略产生。下面是登录测试的配置：</p>
<p><img src="/img/login-test.jpg" alt="Login Test"></p>
<p>　　我们的登录功能是用LoginServlet这个serlvet实现的，它接收两个参数，一个是email,相当于用户名；一个是pwd，是密码。这些输入参数是有具体的Web系统确定的，我这个微博系统就是需要这两个。</p>
<p>　　由于要模拟多用户登录的场景，需要让每个线程的登录用户的不一样。按照上面的数据库里的测试用户的特点，在HTTP Request的参数里让密码固定为gdzq，用户名我们这里引入了一个变量User。</p>
<p>　　JMeter有很多途径产生变量，我们这里介绍一种很简单的，Counter。</p>
<p><img src="/img/counter.png" alt="Counter"></p>
<p>　　Start是变量的起始值，Increment是每次增加的值，Maximum是上限值，Reference Name是变量名。我们让User变量从134开始递增，每启动一个线程就会使用一次User变量，并把它增1，从而达到模拟不同用户访问系统的效果。</p>
<h4 id="Response-Assertion-1"><a href="#Response-Assertion-1" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/login-response.jpg" alt="Login Assertion"></p>
<h3 id="关注某个人"><a href="#关注某个人" class="headerlink" title="关注某个人"></a>关注某个人</h3><h4 id="测试配置-1"><a href="#测试配置-1" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/follow.jpg" alt="Follow"></p>
<p>　　两个参数，一个是关注者id，一个是被关注者id。被关注者我们固定为22，关注者按照登录测试的逻辑，用User变量表示，模拟多用户并发关注同一个用户的情景。</p>
<h4 id="Response-Assertion-2"><a href="#Response-Assertion-2" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/follow-response.jpg" alt="Follow Assertion"></p>
<h3 id="取消关注某个人"><a href="#取消关注某个人" class="headerlink" title="取消关注某个人"></a>取消关注某个人</h3><p>　　取消关注操作与关注操作的request参数和response返回都是一样的，就不另行分析了。</p>
<h3 id="发送微博"><a href="#发送微博" class="headerlink" title="发送微博"></a>发送微博</h3><h4 id="测试配置-2"><a href="#测试配置-2" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/send-message.jpg" alt="Send Message"></p>
<p>　　http request需要两个参数，id代表发送微博的用户的id，message代表微博内容。这里我们两个参数都使用User变量，每一个线程都代表不同的用户，不同的用户都发送一条微博，微博内容就是他们的用户id号。</p>
<h4 id="Response-Assertion-3"><a href="#Response-Assertion-3" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/send-message-response.jpg" alt="Send Message Response"></p>
<h3 id="查找微博列表"><a href="#查找微博列表" class="headerlink" title="查找微博列表"></a>查找微博列表</h3><h4 id="测试配置-3"><a href="#测试配置-3" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/search-message.jpg" alt="Search Message"></p>
<p>　　http request接收三个参数，id代表要查找哪个用户的微博列表，这里仍然使用User变量；因为微博可能很多，需要分页，page代表要查找的微博列表的页数，这里固定为第一页；type代表查找类型，我设计的这个微博系统允许三种类型的查找，分别是全部，个人和最热微博。全部就是查找用户自己发表的微博以及用户关注的人发表的所有微博；个人就只是用户自己发表的微博；最热微博则是查找全系统评论数最高的10条微博。这里type固定为”single”代表只查找用户自己发表的微博。由于我数据库用于测试的用户本身并没有微博数据，仅有的微博就是上一个操作发送的那条微博，因此查找结果应该只含一条微博。</p>
<h4 id="Response-Assertion-4"><a href="#Response-Assertion-4" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/search-message-response.jpg" alt="Search Message Response"></p>
<p>　　如果访问正确，应该返回m1id字段。我这个SearchMessageServlet的response返回的是微博列表，格式是json。json里包含着m1id字段，代表是查找出来的微博id。由于测试用户只有一条刚刚测试时发表的微博，所以只有一个m1id字段出现。</p>
<h4 id="Post-Processors中的正则表达式提取器"><a href="#Post-Processors中的正则表达式提取器" class="headerlink" title="Post-Processors中的正则表达式提取器"></a>Post-Processors中的正则表达式提取器</h4><p>　　Post-Processors是Sampler运行完后会触发的一项组件，一般用于提取Sampler返回的一些数据。类似的还有Pre-Processors，是Sampler运行之前会触发的一项组件。正则表达式提取器便是Post-Processors其中一种，用于按正则表达式的语法提取response里包含的一些数据。</p>
<p>　　由于我们的测试后续需要测试往微博添加评论，查找评论，删除评论以及删除微博这些功能，都需要刚刚测试时用户发表的微博的id作为http request的输入参数。因此我们在查找微博的Sampler上添加一个正则表达式提取器，提取查找出来的第一条微博的id。这条微博就是测试时发表的微博。</p>
<p><img src="/img/message-regular.jpg" alt="Message Regular"></p>
<p>　　我们用正则表达式提取器产生引用名为messageid的变量，用于后续测试引用。因为我们的返回是json格式的数据，所以正则表达式为(.<em>“m1id”:(.</em>?),)，提取json的key为m1id的数据。</p>
<p>　　Template代表我们希望提取第几个捕捉项，一般用括号括起来的作为一个捕捉项，上面的正则表达式只有一个。$1$代表提取第一个捕捉项。</p>
<p>　　Match No.代表我们希望提取第几个匹配组。由于我们在response里可能提取到一组满足正则表达式的匹配字符串，我们需要选一个或者几个出来作为我们的输出。0表示随机选择一个，-1表示选择全部。这里我们选1，代表提取第一个匹配到的匹配项。实际上，由于我们的测试用户只有一条微博数据，也只能匹配到一个。</p>
<h3 id="发表评论"><a href="#发表评论" class="headerlink" title="发表评论"></a>发表评论</h3><h4 id="测试配置-4"><a href="#测试配置-4" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/send-comment.jpg" alt="Send Comment"></p>
<p>　　http request接收3个参数，messageId代表发表评论在哪个微博上，这里用之前正则表达式提取器提取的messageid变量作为值；sendId代表发表评论的用户id，这里仍然用User变量；comment代表评论的内容，这里为了方便，直接用User变量作为评论的内容。</p>
<h4 id="Response-Assertion-5"><a href="#Response-Assertion-5" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/send-comment-response.jpg" alt="Send Comment Response"></p>
<h3 id="查找评论列表"><a href="#查找评论列表" class="headerlink" title="查找评论列表"></a>查找评论列表</h3><h4 id="测试配置-5"><a href="#测试配置-5" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/search-comment.jpg" alt="Search Comment"></p>
<p>　　http request接收2个参数，id代表查找哪个微博的评论，这里仍然用messageid变量；page代表页码，因为评论列表也是需要翻页的，这里固定为第一页。</p>
<h4 id="Response-Assertion-6"><a href="#Response-Assertion-6" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/search-comment-response.jpg" alt="Search Comment Response"></p>
<p>　　response会返回json格式的数据，comment_id是json里的key，代表对应的评论的id。通过判断response是否含有comment_id字段，可以判断测试是否正确。</p>
<h4 id="正则表达式提取器"><a href="#正则表达式提取器" class="headerlink" title="正则表达式提取器"></a>正则表达式提取器</h4><p><img src="/img/comment-regular.jpg" alt="Comment Regular"></p>
<p>　　与查找微博列表一样，查找评论列表也需要设置一个正则表达式提取器，提取返回的评论列表的第一条评论的id。由于测试用户只有一条微博一条评论，这条评论id就是刚刚发表的评论的id。这个id继续作为下面删除评论测试的输入参数。</p>
<h3 id="删除评论"><a href="#删除评论" class="headerlink" title="删除评论"></a>删除评论</h3><h4 id="测试配置-6"><a href="#测试配置-6" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/delete-comment.jpg" alt="Delete Comment"></p>
<p>　　http request接收1个参数，commentId就是上面正则表达式提取器产生的变量，代表评论id。只要把评论id作为DeleteCommentServlet的参数，就能实现删除评论的功能。</p>
<h4 id="Response-Assertion-7"><a href="#Response-Assertion-7" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/delete-comment-response.jpg" alt="Delete Comment Response"></p>
<h3 id="删除微博"><a href="#删除微博" class="headerlink" title="删除微博"></a>删除微博</h3><h4 id="测试配置-7"><a href="#测试配置-7" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/delete-message.jpg" alt="Delete Message"></p>
<p>　　http request接收1个参数，messageId就是上面正则表达式提取器产生的变量，代表微博id。只要把微博id作为DeleteMessageServlet的参数，就能实现删除微博的功能。</p>
<h4 id="Response-Assertion-8"><a href="#Response-Assertion-8" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/delete-message-response.jpg" alt="Delete Message Response"></p>
<h3 id="登出测试"><a href="#登出测试" class="headerlink" title="登出测试"></a>登出测试</h3><h4 id="测试配置-8"><a href="#测试配置-8" class="headerlink" title="测试配置"></a>测试配置</h4><p><img src="/img/logout.jpg" alt="Logout Test"></p>
<p>　　http request接收一个参数，id代表要登出的用户id，这里用User变量。</p>
<h4 id="Response-Assertion-9"><a href="#Response-Assertion-9" class="headerlink" title="Response Assertion"></a>Response Assertion</h4><p><img src="/img/logout-response.jpg" alt="Logout Response"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　上面的实例通过具体的微博系统的测试，引出了一些JMeter的一些最基本最常用的组件。学会使用这些组件，就能搭建一个基本的测试系统，完成基本的压力测试任务。上面的具体测试细节可以不用关注，但要关注从这些实例引申出来的Sampler,HTTP Request Defaults,HTTP Cookie Manager,Assertion,测试报告，断言，变量，正则表达式提取器以及Post-Processors和Pre-Processors等概念。</p>
<p>　　在完成了上述配置以后，只要不断地试验、修改启动的线程数，启动时间等参数，便可以得出Web系统在并发访问下的性能临界点，由此作出可行的优化。</p>
<p>　　</p>
<p>　　</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ORM in JaveEE——JPA]]></title>
      <url>http://wjqwsp.github.io/2016/08/26/ORM-in-JaveEE%E2%80%94%E2%80%94JPA/</url>
      <content type="html"><![CDATA[<h3 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h3><p>　　ORM,即Object Relation Mapping，对象关系映射。我们一般用数据库作数据的持久化存储，通过针对表，属性等进行各种sql的操作，来进行增删改查。但作为程序员，在面向对象思想大行其道的今天，我们更倾向于处理对象，而不是直接处理数据库里面的关系表。我们希望在程序的业务逻辑中，一切皆是对象，而不是表与表的关系，表之间的属性。于是一套从表到对象的映射技术，便应运而生。目前，很多框架都可以实现从关系型数据库到对象的映射，例如Hibernate,EclipseLink等。只需要编写一些配置文件，便可以轻松实现。</p>
<h3 id="什么是JPA"><a href="#什么是JPA" class="headerlink" title="什么是JPA"></a>什么是JPA</h3><p>　　由于市面上有很多框架都可以实现ORM，我们使用不同的框架，就需要一套不一样的配置文件，一套不一样的代码。换言之，我们的工程与这些框架是紧耦合的。如果我们想更换这些框架，那么改动就非常大了。JPA就实现了一套统一的接口标准，让我们可以自由选择不同供应商的不同ORM框架，实现与这些第三方框架的解耦合。并且，JPA广泛使用注解，代码简单，开发十分方便。</p>
<h3 id="JPA与RESTful-API"><a href="#JPA与RESTful-API" class="headerlink" title="JPA与RESTful API"></a>JPA与RESTful API</h3><p>　　前面我们提到RESTful API使用JAX-RS实现的。RESTful API与JPA没有直接的关系，但我们知道通过RESTful API我们实际上是把对对象的增删改查映射到HTTP方法上。而JPA相当于是处理下一层的工作，把对数据库表的增删改查映射到对象上。这样，经过JAX-RS到JPA再到数据库这么三层的处理，我们便可以利用RESTful API来实现我们的业务逻辑。<br><a id="more"></a></p>
<h3 id="BCE模型"><a href="#BCE模型" class="headerlink" title="BCE模型"></a>BCE模型</h3><p>  BCE模型，即Boundary-Controll-Entity，是Web应用系统的一种十分常见的结构。Boundary,即系统之间交互的边界，一般指一些涉及对Web应用的数据的输入输出的类，例如RESTful API直接访问的JAX-RS的Resource类。Control，一般是完成一些复杂的计算与业务逻辑的处理，是从Entity到Boundary的中间层。Entity，就是数据库表直接ORM转化的实体对象类。下面就从BCE模型入手，按Entity，Control，Boundary的顺序，围绕实例介绍一下JPA标准以及其与JAX-RS的结合。</p>
<h4 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h4><p>　　先来看看JPA的Entity类是什么样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="meta">@Table</span>(name = <span class="string">"commentary"</span>, catalog = <span class="string">"weibo"</span>, schema = <span class="string">"public"</span>)</div><div class="line"><span class="meta">@XmlRootElement</span></div><div class="line"><span class="meta">@NamedQueries</span>(&#123;</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"Commentary.findAll"</span>, query = <span class="string">"SELECT c FROM Commentary c"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"Commentary.findById"</span>, query = <span class="string">"SELECT c FROM Commentary c WHERE c.id = :id"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"Commentary.findByWord"</span>, query = <span class="string">"SELECT c FROM Commentary c WHERE c.word = :word"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"Commentary.findByCreateDate"</span>, query = <span class="string">"SELECT c FROM Commentary c WHERE c.createDate = :createDate"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"Commentary.findByIsDeleted"</span>, query = <span class="string">"SELECT c FROM Commentary c WHERE c.isDeleted = :isDeleted"</span>)&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Commentary</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</div><div class="line">    <span class="meta">@Basic</span>(optional = <span class="keyword">false</span>)</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="meta">@Basic</span>(optional = <span class="keyword">false</span>)</div><div class="line">    <span class="meta">@NotNull</span></div><div class="line">    <span class="meta">@Size</span>(min = <span class="number">1</span>, max = <span class="number">140</span>)</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"word"</span>)</div><div class="line">    <span class="keyword">private</span> String word;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"create_date"</span>)</div><div class="line">    <span class="meta">@Temporal</span>(TemporalType.TIMESTAMP)</div><div class="line">    <span class="keyword">private</span> Date createDate;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"is_deleted"</span>)</div><div class="line">    <span class="keyword">private</span> Boolean isDeleted;</div><div class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"reply_subscriber_id"</span>, referencedColumnName = <span class="string">"id"</span>)</div><div class="line">    <span class="meta">@ManyToOne</span></div><div class="line">    <span class="keyword">private</span> Subscriber replySubscriberId;</div><div class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"subscriber_id"</span>, referencedColumnName = <span class="string">"id"</span>)</div><div class="line">    <span class="meta">@ManyToOne</span></div><div class="line">    <span class="keyword">private</span> Subscriber subscriberId;</div><div class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"message_id"</span>, referencedColumnName = <span class="string">"id"</span>)</div><div class="line">    <span class="meta">@ManyToOne</span></div><div class="line">    <span class="keyword">private</span> Message messageId;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Commentary</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Commentary</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Commentary</span><span class="params">(Long id, String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.word = word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWord</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWord</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.word = word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getCreateDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> createDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreateDate</span><span class="params">(Date createDate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.createDate = createDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getIsDeleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> isDeleted;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsDeleted</span><span class="params">(Boolean isDeleted)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.isDeleted = isDeleted;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Subscriber <span class="title">getReplySubscriberId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> replySubscriberId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReplySubscriberId</span><span class="params">(Subscriber replySubscriberId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.replySubscriberId = replySubscriberId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Subscriber <span class="title">getSubscriberId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> subscriberId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubscriberId</span><span class="params">(Subscriber subscriberId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subscriberId = subscriberId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">getMessageId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messageId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageId</span><span class="params">(Message messageId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messageId = messageId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</div><div class="line">        hash += (id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> hash;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> Warning - this method won't work in the case the id fields are not set</span></div><div class="line">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Commentary)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Commentary other = (Commentary) object;</div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.id == <span class="keyword">null</span> &amp;&amp; other.id != <span class="keyword">null</span>) || (<span class="keyword">this</span>.id != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.id.equals(other.id))) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"sampleweb.message.entity.Commentary[ id="</span> + id + <span class="string">" ]"</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　简单分析一下，@Entity标注说明该类是JPA的实体类。@Table标注说明了该类对应的数据库，schema以及表名，由此使Entity与数据库的表建立一一对应的关系。</p>
<p>　　@Id标注说明了主键，@Column说明了表的列属性。@Basic(optional = false)与@NotNull都是表示该属性对应到数据库的列不能为空。@Size一般说明字符串类型的长度范围，对应数据库里的char或varchar等类型。@GeneratedValue(strategy = GenerationType.IDENTITY)说明主键的生成策略采用了数据库自身的自增长主键。</p>
<p>　　@ManyToOne和@OneToMany说明了该实体对应的表与实体对应的表的外键引用关系，通过这些关系可以比较方便的实现Entity的连接。类似的还有@OneToOne和@ManyToMany。</p>
<p>　　然后便是对每一个属性的getter和setter方法。Entity类必须含有一个空的构造方法。</p>
<p>　　该类实现了Serializable接口，并且打上了@XmlRootElement标注，表明该实体可以被序列化，直接作为数据进行输入输出。这时候它既属于Entity也属于Boundary，没有经过数据的再封装。只有需要不同的Entity的数据组合，或者需要多次查询多个实体的数据，则需要在Boundary下再定义一个专门用于数据传输的POJO类。</p>
<p>　　我们只要有一个大概的认识，了解一下实体是怎么与数据库的表映射在一起的。这里面广泛使用了注解，代码很少，配置简单。其实Entity类基本不用自己写的，IDE里只要连接了数据库，通常可以直接从数据库一键生成Entity类，根据数据库的结构自动地配置好所有标注与变量，我们只需把重点放在Boundary与Control部分即可。</p>
<p>　　这里有一点需要注意一下，从数据库的表一键生成Entity类时，我们需要指定一个数据库的表，作为Entity的基础，并且会自动把与其相关联的有外键引用关系的表一起生成为其他Entity。但是，其外键的引用关系只能是同一个schema里的，如果是不同schema之间的外键引用，则无法做到ORM。反正我的试验下是这样的，如果有正确的方法实现不同schema之间的ORM，希望不吝赐教~</p>
<h4 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h4><p>　　控制层是JPA的关键与重点，我们的绝大部分业务逻辑都集中在控制层内。下面我们从EJB，EntityManager以及Query API三个方面来介绍一下Control层。</p>
<h5 id="EJB"><a href="#EJB" class="headerlink" title="EJB"></a>EJB</h5><p>　　EJB,即EnterPrise JaveBean，是分离视图层与数据库访问的一层技术，是Control的核心，是数据库接口与业务逻辑的封装体。它有自己的生命周期管理机制，是一套跨application server的独立组件。它可以是有状态和无状态的。无状态的EJB说明其每次调用都是无记忆无状态的，是没有关联的。一般应尽量使用无状态的EJB，其能够具备最好的线程安全性与并发性。而且，我们绝大多数的应用场景用无状态的EJB便能满足，特别是基于http的RESTful API的实现。下面重点介绍一下无状态的EJB，即stateless EJB。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Stateless</span></div><div class="line"><span class="meta">@RolesAllowed</span>(&#123;<span class="string">"operator"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageService</span> </span>&#123;</div><div class="line">    <span class="meta">@PersistenceContext</span>(unitName = <span class="string">"com.hudoumiao_sampleweb_war_1.0-SNAPSHOTPU"</span>)</div><div class="line">    <span class="keyword">private</span> EntityManager em;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> List&lt;Object[]&gt; findDangerousMessages(<span class="keyword">int</span> page,<span class="keyword">int</span> perPage)&#123;</div><div class="line">        String sql = <span class="string">"(select message1.word,message1.comment_count,message1.transmission_count,message1.id,message1.publish_date,"</span> +</div><div class="line">                        <span class="string">"message2.word,message2.comment_count,message2.transmission_count,message2.id,message2.publish_date,"</span> +</div><div class="line">                        <span class="string">"subscriber1.username,subscriber2.username,subscriber1.id,subscriber2.id,manager.dangerous_message.managed_date,"</span> +</div><div class="line">                        <span class="string">"manager.action.action_name,account.auth_user.name from manager.dangerous_message left outer join "</span> +</div><div class="line">                        <span class="string">"message message1 on(manager.dangerous_message.message_id = message1.id) left outer join account.auth_user "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.manager_id = account.auth_user.id) left outer join manager.action "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.action_id = manager.action.id) left outer join message message2 on(message1.reference_id = message2.id)"</span> +</div><div class="line">                        <span class="string">"inner join subscriber subscriber1 on (message1.subscriber_id = subscriber1.id) left outer join subscriber subscriber2 on (message2.subscriber_id = subscriber2.id) "</span> +</div><div class="line">                        <span class="string">"where message1.is_deleted = false and message1.is_blocked = false and message1.is_removed = false)"</span> +                        </div><div class="line">                        <span class="string">"order by 2 desc,5 desc "</span> +</div><div class="line">                        <span class="string">"limit "</span> + perPage + <span class="string">"offset "</span> + (page - <span class="number">1</span>) * <span class="number">10</span>;</div><div class="line">        <span class="keyword">return</span> em.createNativeQuery(sql).getResultList();       </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countDangerousMessage</span><span class="params">()</span></span>&#123;</div><div class="line">        String sql = <span class="string">"select count(manager.dangerous_message.id) from manager.dangerous_message left outer join message "</span></div><div class="line">                + <span class="string">"on(manager.dangerous_message.message_id = message.id) where message.is_deleted = false and "</span></div><div class="line">                + <span class="string">"message.is_blocked = false and message.is_removed = false"</span>;</div><div class="line">        <span class="keyword">return</span> (Long)em.createNativeQuery(sql).getSingleResult();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSolvedMessages</span><span class="params">()</span></span>&#123;</div><div class="line">        String sql = <span class="string">"select count(manager.dangerous_message.id) from manager.dangerous_message left outer join message "</span></div><div class="line">                + <span class="string">"on(manager.dangerous_message.message_id = message.id) where message.is_deleted = false and "</span></div><div class="line">                + <span class="string">"(message.is_blocked = true or message.is_removed = true)"</span>;</div><div class="line">        <span class="keyword">return</span> (Long)em.createNativeQuery(sql).getSingleResult();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> List&lt;Object[]&gt; findSolvedMessages(<span class="keyword">int</span> page,<span class="keyword">int</span> perPage)&#123;</div><div class="line">        String sql = <span class="string">"(select message1.word,message1.comment_count,message1.transmission_count,message1.id,message1.publish_date,"</span> +</div><div class="line">                        <span class="string">"message2.word,message2.comment_count,message2.transmission_count,message2.id,message2.publish_date,"</span> +</div><div class="line">                        <span class="string">"subscriber1.username,subscriber2.username,subscriber1.id,subscriber2.id,message1.is_removed,message1.is_blocked,manager.dangerous_message.managed_date,"</span> +</div><div class="line">                        <span class="string">"manager.action.action_name,account.auth_user.name from manager.dangerous_message left outer join "</span> +</div><div class="line">                        <span class="string">"message message1 on(manager.dangerous_message.message_id = message1.id) left outer join account.auth_user "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.manager_id = account.auth_user.id) left outer join manager.action "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.action_id = manager.action.id) left outer join message message2 on(message1.reference_id = message2.id)"</span> +</div><div class="line">                        <span class="string">"inner join subscriber subscriber1 on (message1.subscriber_id = subscriber1.id) left outer join subscriber subscriber2 on (message2.subscriber_id = subscriber2.id) "</span> +</div><div class="line">                        <span class="string">"where message1.is_removed = true and message1.is_deleted = false)"</span> +  </div><div class="line">                     <span class="string">"union"</span> +</div><div class="line">                     <span class="string">"(select message1.word,message1.comment_count,message1.transmission_count,message1.id,message1.publish_date,"</span> +</div><div class="line">                        <span class="string">"message2.word,message2.comment_count,message2.transmission_count,message2.id,message2.publish_date,"</span> +</div><div class="line">                        <span class="string">"subscriber1.username,subscriber2.username,subscriber1.id,subscriber2.id,message1.is_removed,message1.is_blocked,manager.dangerous_message.managed_date,"</span> +</div><div class="line">                        <span class="string">"manager.action.action_name,account.auth_user.name from manager.dangerous_message left outer join "</span> +</div><div class="line">                        <span class="string">"message message1 on(manager.dangerous_message.message_id = message1.id) left outer join account.auth_user "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.manager_id = account.auth_user.id) left outer join manager.action "</span> +</div><div class="line">                        <span class="string">"on(manager.dangerous_message.action_id = manager.action.id) left outer join message message2 on(message1.reference_id = message2.id)"</span> +</div><div class="line">                        <span class="string">"inner join subscriber subscriber1 on (message1.subscriber_id = subscriber1.id) left outer join subscriber subscriber2 on (message2.subscriber_id = subscriber2.id) "</span> +</div><div class="line">                        <span class="string">"where message1.is_blocked = true and message1.is_deleted = false)"</span> +</div><div class="line">                        <span class="string">"order by 2 desc,5 desc "</span> +</div><div class="line">                        <span class="string">"limit "</span> + perPage + <span class="string">"offset "</span> + (page - <span class="number">1</span>) * <span class="number">10</span>;</div><div class="line">        <span class="keyword">return</span> em.createNativeQuery(sql).getResultList();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;SumItem&gt; <span class="title">sumMessage</span><span class="params">()</span></span>&#123;</div><div class="line">        String sql = <span class="string">"select count(to_char(publish_date,'yyyy-mm-dd')),to_char(publish_date,'yyyy-mm-dd') from message "</span> +</div><div class="line">                   <span class="string">"where publish_date &gt; current_date - interval '9 day' "</span> +</div><div class="line">                   <span class="string">"group by to_char(publish_date,'yyyy-mm-dd') order by to_char(publish_date,'yyyy-mm-dd')"</span>;</div><div class="line">        List&lt;Object[]&gt; results = em.createNativeQuery(sql).getResultList();</div><div class="line">        List&lt;SumItem&gt; messageSum = <span class="keyword">new</span> ArrayList();        </div><div class="line">        Calendar cal = Calendar.getInstance();</div><div class="line">        cal.add(Calendar.DAY_OF_MONTH, -<span class="number">9</span>);</div><div class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">        String start = sdf.format(cal.getTime());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;                      </div><div class="line">            SumItem sumItem = <span class="keyword">new</span> SumItem();</div><div class="line">            sumItem.setCount(<span class="number">0</span>);</div><div class="line">            sumItem.setDate(sdf.format(cal.getTime()));</div><div class="line">            messageSum.add(sumItem);</div><div class="line">            cal.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">        &#125;                </div><div class="line">        <span class="keyword">if</span>(!results.isEmpty())&#123;</div><div class="line">            <span class="keyword">for</span>(Object[] result : results)&#123;</div><div class="line">                String end = (String)result[<span class="number">1</span>];</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    <span class="keyword">int</span> interval = (<span class="keyword">int</span>)((sdf.parse(end).getTime() - sdf.parse(start).getTime()) / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>)); </div><div class="line">                    messageSum.get(interval).setCount(((Long)result[<span class="number">0</span>]).intValue());</div><div class="line">                &#125;<span class="keyword">catch</span>(ParseException e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> messageSum;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;SumItem&gt; <span class="title">sumComment</span><span class="params">()</span></span>&#123;</div><div class="line">        String sql = <span class="string">"select count(to_char(create_date,'yyyy-mm-dd')),to_char(create_date,'yyyy-mm-dd') from commentary "</span> +</div><div class="line">                   <span class="string">"where create_date &gt; current_date - interval '9 day' "</span> +</div><div class="line">                   <span class="string">"group by to_char(create_date,'yyyy-mm-dd') order by to_char(create_date,'yyyy-mm-dd')"</span>;</div><div class="line">        List&lt;Object[]&gt; results = em.createNativeQuery(sql).getResultList();</div><div class="line">        List&lt;SumItem&gt; commentSum = <span class="keyword">new</span> ArrayList();</div><div class="line">        Calendar cal = Calendar.getInstance();</div><div class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">        cal.add(Calendar.DAY_OF_MONTH, -<span class="number">9</span>);</div><div class="line">        String start = sdf.format(cal.getTime());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</div><div class="line">            SumItem sumItem = <span class="keyword">new</span> SumItem();</div><div class="line">            sumItem.setCount(<span class="number">0</span>);</div><div class="line">            sumItem.setDate(sdf.format(cal.getTime()));</div><div class="line">            commentSum.add(sumItem);</div><div class="line">            cal.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">if</span>(!results.isEmpty())&#123;</div><div class="line">            <span class="keyword">for</span>(Object[] result : results)&#123;</div><div class="line">                String end = (String)result[<span class="number">1</span>];</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    <span class="keyword">int</span> interval = (<span class="keyword">int</span>)((sdf.parse(end).getTime() - sdf.parse(start).getTime()) / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</div><div class="line">                    commentSum.get(interval).setCount(((Long)result[<span class="number">0</span>]).intValue());</div><div class="line">                &#125;<span class="keyword">catch</span>(ParseException e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> commentSum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Stateless</span></div><div class="line"><span class="meta">@RolesAllowed</span>(&#123;<span class="string">"operator"</span>&#125;)</div><div class="line"><span class="meta">@Path</span>(<span class="string">"message"</span>)</div><div class="line"><span class="meta">@Tracked</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFacadeREST</span> <span class="keyword">extends</span> <span class="title">AbstractFacade</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@PersistenceContext</span>(unitName = <span class="string">"com.hudoumiao_sampleweb_war_1.0-SNAPSHOTPU"</span>)</div><div class="line">    <span class="keyword">private</span> EntityManager em;</div><div class="line">    <span class="meta">@EJB</span></div><div class="line">    MessageService messageService;</div><div class="line">    <span class="meta">@EJB</span></div><div class="line">    CommentService commentService;</div></pre></td></tr></table></figure>
<p>　　第一段代码是EJB的定义类，@stateless标注说明是无状态的EJB。其必须含有无参的构造函数，这里用默认的无参构造函数。我们可以先忽略类里各方法的实现细节，但不难看出，每个方法都是对数据库的操作，以及获取数据后的一些处理。这就是我们的数据库访问与业务逻辑，全部封装在EJB里。</p>
<p>　　第二段代码是注入EJB到类变量里。这里的MessageFacadeRest是JAX-RS的Resource类，我们需要借助EJB来处理业务逻辑，然后返回处理过后的数据到Resource类的相应方法内以供RESTful API访问。@EJB就表示EJB实体对象。</p>
<p>　　我们每调用一次EJB的实体对象，都会经历一次EJB的生命周期，下面简单阐述一下其生命周期的流程。我们所用的application server container，例如GlassFish,Tomcat等，都会维护一个EJB pool，类似数据库连接池或者线程池，都是预先存放好一定数量的EJB实体对象，需要调用的时候从中抽取，调用完毕再由池回收。这整个过程application server container都会帮我们管理。</p>
<ol>
<li>首先，container会根据EJB的无参构造函数创建EJB。</li>
<li>EJB里的资源会根据注解注入，例如第一段代码的@EntityManager，这是数据库连接资源，后面再详细介绍。</li>
<li>建立EJB池，把建立好的EJB放入池中。</li>
<li>如果客户端有请求访问EJB，如果池中有空闲的EJB则会抽取出来给客户端使用，如果没有空闲的EJB，则会创建更多的EJB实体。</li>
<li>执行EJB业务逻辑。</li>
<li>业务逻辑执行完毕后，EJB归还池中。</li>
<li>根据需要移除EJB实体。</li>
</ol>
<p>　　EJB很好的封装了业务逻辑与数据库访问，把数据库与视图分离，且EJB pool很好地处理了线程安全与并发的问题。</p>
<h5 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h5><p>　　JPA关键在于实现ORM,前面我们介绍了Entity，但单靠创建Entity，我们是无法实现ORM的。要实现ORM，我们需要一个Persistence Unit，即持久化单元。我们依靠Persistence Unit去建立数据库连接。通过Persistent Unit，我们可以注入EntityManager，进而实现数据库业务逻辑的增删改查。</p>
<p>　　我们需要现在相应的第三方ORM框架的配置文件persistence.xml里定义Persistence Unit:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">version</span>=<span class="string">"2.1"</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/persistence"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">"com.hudoumiao_sampleweb_war_1.0-SNAPSHOTPU"</span> <span class="attr">transaction-type</span>=<span class="string">"JTA"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">jta-data-source</span>&gt;</span>jdbc/weibo<span class="tag">&lt;/<span class="name">jta-data-source</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">exclude-unlisted-classes</span>&gt;</span>false<span class="tag">&lt;/<span class="name">exclude-unlisted-classes</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></div></pre></td></tr></table></figure>
<p>　　比较重要的是name属性，这个属性是我们在EJB里引用persistence unit所需要的。上面介绍EJB代码里已有相关示例。当我们要把项目部署到application server container里，我们需要使用transaction-type=”JTA”。在这种transaction-type下，我们不需要罗列需要引入的entity class，只需在jta-data-source里指定数据库就行。并且数据库的详细配置我们不需要再persistence.xml里写，只需在application server container的配置文件里配置好就行。例如，如果用GlassFish作为application server container,则配置文件glassfish-resources.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">jdbc-connection-pool</span> <span class="attr">allow-non-component-callers</span>=<span class="string">"false"</span> <span class="attr">associate-with-thread</span>=<span class="string">"false"</span> <span class="attr">connection-creation-retry-attempts</span>=<span class="string">"0"</span> <span class="attr">connection-creation-retry-interval-in-seconds</span>=<span class="string">"10"</span> <span class="attr">connection-leak-reclaim</span>=<span class="string">"false"</span> <span class="attr">connection-leak-timeout-in-seconds</span>=<span class="string">"0"</span> <span class="attr">connection-validation-method</span>=<span class="string">"auto-commit"</span> <span class="attr">datasource-classname</span>=<span class="string">"org.postgresql.ds.PGSimpleDataSource"</span> <span class="attr">fail-all-connections</span>=<span class="string">"false"</span> <span class="attr">idle-timeout-in-seconds</span>=<span class="string">"300"</span> <span class="attr">is-connection-validation-required</span>=<span class="string">"false"</span> <span class="attr">is-isolation-level-guaranteed</span>=<span class="string">"true"</span> <span class="attr">lazy-connection-association</span>=<span class="string">"false"</span> <span class="attr">lazy-connection-enlistment</span>=<span class="string">"false"</span> <span class="attr">match-connections</span>=<span class="string">"false"</span> <span class="attr">max-connection-usage-count</span>=<span class="string">"0"</span> <span class="attr">max-pool-size</span>=<span class="string">"32"</span> <span class="attr">max-wait-time-in-millis</span>=<span class="string">"60000"</span> <span class="attr">name</span>=<span class="string">"post-gre-sql_weibo_postgresPool"</span> <span class="attr">non-transactional-connections</span>=<span class="string">"false"</span> <span class="attr">pool-resize-quantity</span>=<span class="string">"2"</span> <span class="attr">res-type</span>=<span class="string">"javax.sql.DataSource"</span> <span class="attr">statement-timeout-in-seconds</span>=<span class="string">"-1"</span> <span class="attr">steady-pool-size</span>=<span class="string">"8"</span> <span class="attr">validate-atmost-once-period-in-seconds</span>=<span class="string">"0"</span> <span class="attr">wrap-jdbc-objects</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serverName"</span> <span class="attr">value</span>=<span class="string">"localhost"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"portNumber"</span> <span class="attr">value</span>=<span class="string">"5432"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"databaseName"</span> <span class="attr">value</span>=<span class="string">"weibo"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">value</span>=<span class="string">"postgres"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Password"</span> <span class="attr">value</span>=<span class="string">"gdzqzxwjs95"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"URL"</span> <span class="attr">value</span>=<span class="string">"jdbc:postgresql://localhost:5432/weibo"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"org.postgresql.Driver"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">jdbc-connection-pool</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">jdbc-resource</span> <span class="attr">enabled</span>=<span class="string">"true"</span> <span class="attr">jndi-name</span>=<span class="string">"jdbc/weibo"</span> <span class="attr">object-type</span>=<span class="string">"user"</span> <span class="attr">pool-name</span>=<span class="string">"post-gre-sql_weibo_postgresPool"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>　　上面的定义的jndi-name就是persistence.xml引用的数据库凭据。</p>
<p>　　持久化单元(persist unit)就是关于一组Entity的命名配置。持久化单元是一个静态概念。</p>
<p>　　持久化上下文(Persist Context)就是一个受管的Entity实例的集合。每一个持久化上下文都关联一个持久化单元，持久化上下文不可能脱离持久化单元独立存在。持久化上下文是一个动态概念。</p>
<p>　　尽管持久化上下文非常重要，但是开发者不直接与之打交道，持久化上下文在程序中是透明的，我们通过EntityManager间接管理它。</p>
<p>　　利用EntityManager我们便能够完成数据库的增删改查。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFacade</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> Class&lt;T&gt; entityClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractFacade</span><span class="params">(Class&lt;T&gt; entityClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.entityClass = entityClass;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> EntityManager <span class="title">getEntityManager</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(T entity)</span> </span>&#123;</div><div class="line">        getEntityManager().persist(entity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(T entity)</span> </span>&#123;</div><div class="line">        getEntityManager().merge(entity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T entity)</span> </span>&#123;</div><div class="line">        getEntityManager().remove(getEntityManager().merge(entity));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">find</span><span class="params">(Object id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getEntityManager().find(entityClass, id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</div><div class="line">        javax.persistence.criteria.CriteriaQuery cq = getEntityManager().getCriteriaBuilder().createQuery();</div><div class="line">        cq.select(cq.from(entityClass));</div><div class="line">        <span class="keyword">return</span> getEntityManager().createQuery(cq).getResultList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">findRange</span><span class="params">(<span class="keyword">int</span>[] range)</span> </span>&#123;</div><div class="line">        javax.persistence.criteria.CriteriaQuery cq = getEntityManager().getCriteriaBuilder().createQuery();</div><div class="line">        cq.select(cq.from(entityClass));</div><div class="line">        javax.persistence.Query q = getEntityManager().createQuery(cq);</div><div class="line">        q.setMaxResults(range[<span class="number">1</span>] - range[<span class="number">0</span>] + <span class="number">1</span>);</div><div class="line">        q.setFirstResult(range[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">return</span> q.getResultList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">        javax.persistence.criteria.CriteriaQuery cq = getEntityManager().getCriteriaBuilder().createQuery();</div><div class="line">        javax.persistence.criteria.Root&lt;T&gt; rt = cq.from(entityClass);</div><div class="line">        cq.select(getEntityManager().getCriteriaBuilder().count(rt));</div><div class="line">        javax.persistence.Query q = getEntityManager().createQuery(cq);</div><div class="line">        <span class="keyword">return</span> ((Long) q.getSingleResult()).intValue();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这是一个通用的jax-rs资源类模板，通过继承这一个类，我们能够实现最基本的增删改查，分别对应EntityManager.persist()，EntityManager.remove()，EntityManager.merge()，EntityManager.find()。其中find方法一般只能根据id查找单个实体，如果需要做更复杂的查询还需要用到Query API,后面一节会详细介绍。这里，我们先简单介绍一下EntityManager的状态。</p>
<p>　　EntityManager管理的实体有4个状态，new,managed,detached,removed。</p>
<p>　　当我们通过构造函数新创建一个entity对象时，它属于new状态，此时它的数据与数据库是不同步的，是不在persistence context里的。当我们调用persist方法后，它将获得自己的主键，与数据库同步，转化为managed状态，进入persistence context。</p>
<p>　　如果我们remove某个处于merged状态的entity，则它将变为removed状态。凡是被查找出来的实体，其状态都为managed，其变化与数据库同步，处于persistence context。</p>
<p>　　所有处于detached状态的entity都游离于persistence context之外。如果我们对某个处于detached状态的实体调用merge方法，则会变成managed状态，其实体里的数据将同步到数据库。</p>
<p>　　只要实体与数据库同步，我们便真正地实现了ORM。</p>
<h5 id="Query-API"><a href="#Query-API" class="headerlink" title="Query API"></a>Query API</h5><h6 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h6><p>　　我们知道，EntityManager的find方法只能查询某id的一个实体，如果要做复杂的查询则必须用到JPA的Query API。下面先以一段代码来认识一下Query API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;Object[]&gt; findDangerousMessages(<span class="keyword">int</span> page,<span class="keyword">int</span> perPage)&#123;</div><div class="line">       String sql = <span class="string">"(select message1.word,message1.comment_count,message1.transmission_count,message1.id,message1.publish_date,"</span> +</div><div class="line">                       <span class="string">"message2.word,message2.comment_count,message2.transmission_count,message2.id,message2.publish_date,"</span> +</div><div class="line">                       <span class="string">"subscriber1.username,subscriber2.username,subscriber1.id,subscriber2.id,manager.dangerous_message.managed_date,"</span> +</div><div class="line">                       <span class="string">"manager.action.action_name,account.auth_user.name from manager.dangerous_message left outer join "</span> +</div><div class="line">                       <span class="string">"message message1 on(manager.dangerous_message.message_id = message1.id) left outer join account.auth_user "</span> +</div><div class="line">                       <span class="string">"on(manager.dangerous_message.manager_id = account.auth_user.id) left outer join manager.action "</span> +</div><div class="line">                       <span class="string">"on(manager.dangerous_message.action_id = manager.action.id) left outer join message message2 on(message1.reference_id = message2.id)"</span> +</div><div class="line">                       <span class="string">"inner join subscriber subscriber1 on (message1.subscriber_id = subscriber1.id) left outer join subscriber subscriber2 on (message2.subscriber_id = subscriber2.id) "</span> +</div><div class="line">                       <span class="string">"where message1.is_deleted = false and message1.is_blocked = false and message1.is_removed = false)"</span> +                        </div><div class="line">                       <span class="string">"order by 2 desc,5 desc "</span> +</div><div class="line">                       <span class="string">"limit "</span> + perPage + <span class="string">"offset "</span> + (page - <span class="number">1</span>) * <span class="number">10</span>;</div><div class="line">       <span class="keyword">return</span> em.createNativeQuery(sql).getResultList();       </div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countDangerousMessage</span><span class="params">()</span></span>&#123;</div><div class="line">       String sql = <span class="string">"select count(manager.dangerous_message.id) from manager.dangerous_message left outer join message "</span></div><div class="line">               + <span class="string">"on(manager.dangerous_message.message_id = message.id) where message.is_deleted = false and "</span></div><div class="line">               + <span class="string">"message.is_blocked = false and message.is_removed = false"</span>;</div><div class="line">       <span class="keyword">return</span> (Long)em.createNativeQuery(sql).getSingleResult();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>　　由上面代码看到，我们定义了一段sql的字符串，然后调用EntityManager的createNativeQuery方法，便可以进行数据库查询。如果要返回多个属性或多条记录，可以用getResultList方法来返回;如果只返回一个属性值，可以用getSingleResult方法。这是最基本的Query API与数据库访问方法，非常简单，只要有sql与数据库基础便可以轻松开发。</p>
<p>　　除了用传统的sql语言作查询外，Query API还有一种面向对象的数据库查询语言JPQL，其语法与sql很相似，它的查询是针对ORM后的Entity class的。以字符串形式存储相应的jpql语句，然后调用createQuery方法进行查询，仍然可以用getResultList以及getSingleResult的方法返回结果。</p>
<p>　　Query API的更多方法以及JPQL的具体语法可以自行查阅资料，网上资源也很多，这里就不展开赘述了。在开发的时候查查就行，用多了就熟练了，就像sql语言一样。一般大部分sql操作都能用JPQL实现。</p>
<p>　　我们还能用@NameQuery的形式预先定义好查询语句，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="meta">@Table</span>(name = <span class="string">"dangerous_message"</span>, catalog = <span class="string">"weibo"</span>, schema = <span class="string">"manager"</span>)</div><div class="line"><span class="meta">@XmlRootElement</span></div><div class="line"><span class="meta">@NamedQueries</span>(&#123;</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"DangerousMessage.findAll"</span>, query = <span class="string">"SELECT d FROM DangerousMessage d"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"DangerousMessage.findById"</span>, query = <span class="string">"SELECT d FROM DangerousMessage d WHERE d.id = :id"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"DangerousMessage.findByMessageId"</span>, query = <span class="string">"SELECT d FROM DangerousMessage d WHERE d.messageId = :messageId"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"DangerousMessage.findByManagerId"</span>, query = <span class="string">"SELECT d FROM DangerousMessage d WHERE d.managerId = :managerId"</span>),</div><div class="line">    <span class="meta">@NamedQuery</span>(name = <span class="string">"DangerousMessage.findByManagedDate"</span>, query = <span class="string">"SELECT d FROM DangerousMessage d WHERE d.managedDate = :managedDate"</span>)&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DangerousMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div></pre></td></tr></table></figure></p>
<p>　　上面就是用jpql语法预先定义好一些常用的查询语句。类似的，用sql也可以预先定义查询，此时的标注是@NameNativeQuery。如果在类名前用@NameQuery注解定义好一些查询语句，在代码里需要进行查询时候只需要用name作标识就可以，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DangerousMessage dangerousMessage = (DangerousMessage)em.createNamedQuery(<span class="string">"DangerousMessage.findByMessageId"</span>).setParameter(<span class="string">"messageId"</span>,id).getSingleResult();</div></pre></td></tr></table></figure></p>
<h6 id="查询方式的选择"><a href="#查询方式的选择" class="headerlink" title="查询方式的选择"></a>查询方式的选择</h6><p>　　总而言之，我们可以选择sql语句或者jpql语句作为Query API的参数进行数据库查询；确定了语言后我们还可以选择是用标准的查询形式还是预先定义的查询。如果进行复杂的数据库查询，或者一些jpql无法实现的查询，我们优先选择用sql语言实现。而在一般情况下，我们推荐使用JPQL，因为它更贴近面向对象的思想，且其实现与底层的数据库是无关的。换言之，我们可以用一套jpql语法来处理不同数据库的查询工作，如果更换数据库，我们的代码仍然能正常运行，而不用像sql语言一样每个数据库都有自己的一套语法。</p>
<p>　　如果查询语句是动态变化，不固定的，那么只能用标准的查询方式。否则，推荐采用预先定义的查询。预先定义的查询语句存放在固定的地方，并且有更好的性能。只要进行了一次预定义查询，后面进行的查询就不用再编译，而是运行之前编译好的缓存的查询语句。</p>
<h4 id="Boundary"><a href="#Boundary" class="headerlink" title="Boundary"></a>Boundary</h4><p>　　JAX-RS的Resource组件类通常便是我们所说的Boudary。我们在Resource里调用Control层的EJB来进行业务逻辑的运算与数据库访问，然后在Boudary层组装查询的结果。如果查询结果正好是Entity对象，则直接将其序列化传输就行；如果需要另外组合，则定义一个POJO类做为数据传输类(DTO)，将其序列化传输。下面是微博评论系统的结构设计：</p>
<p><img src="/img/system-structure.png" alt="BCE模型结构"></p>
<p>　　类名里含DTO的都是新定义的作数据传输的POJO类，MessageFacadeREST是Resource组件类，它继承了AbstractFacaceREST。MessageService是EJB类，封装了大部分的数据库访问与业务逻辑。Entity包里都是ORM后的实体对象。</p>
<p>　　其实，MessageFacadeREST也是EJB实体，因为重组数据也是业务逻辑之一。所以，EJB不一定只属于Control层，Boundary层也是需要的，只是我们为了介绍方便放在Control层里讲述而已。Control层的EJB主要用于数据库访问与一些业务逻辑的运算，我们希望尽可能把JPA标准里绝大多数的业务逻辑都放到Control层内。Boundary层的EJB对象则主要处理数据的再封装，以及一些JAX-RS里对于http response的header与body的一些处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　这一次主要以BCE模型结构入手，讲述了JPA标准的基本知识，以及其与JAX-RS是怎么联合起来实现一套RESTful API的后台系统的。如果业务逻辑比较简单，我们也可以不严格按照BCE模型，省略了Control层，而把所有业务逻辑以及数据库访问都放在Boundary层的EJB内。如果系统较大，建议尽量用BCE的结构。</p>
<p>　　</p>
<p>　　
　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RESTful API规范补充以及JAX-RS传递参数的方法]]></title>
      <url>http://wjqwsp.github.io/2016/08/23/RESTful-API%E8%A7%84%E8%8C%83%E8%A1%A5%E5%85%85/</url>
      <content type="html"><![CDATA[<h3 id="搜索的过滤与排序"><a href="#搜索的过滤与排序" class="headerlink" title="搜索的过滤与排序"></a>搜索的过滤与排序</h3><p>　　搜索在RESTful API里是用GET方法实现的，URI一般是某个对象，可以是单个也可以是列表。以微博搜索为例，如果不加任何条件，其URI一般是这样的：</p>
<pre><code>/api/weibo</code></pre>
<pre><code>/api/weibo/6</code></pre>

<p>　　但往往还需要限制一下搜索条件，例如评论数大于某个数，或者含有什么关键字，如果是搜索微博列表，也可能加上对日期作升序或降序排序的要求。这些附加条件，是作为query param附加在http请求里的。例如：<br><a id="more"></a></p>
<ul>
<li>GET /weibo?deleted=true - 得到所有标记为删除的微博</li>
<li>GET /weibo?sort=-create-date - 按照创建日期反序排序得到微博列表</li>
<li>GET /weibo?sort=comment-count,-create-date - 先按微博评论数再按创建日期反序排序得到微博列表</li>
<li>GET /weibo?keyword=xxx - 得到包含关键字xxx的微博列表</li>
<li>GET /weibo?keyword=xxx&amp;deleted=true&amp;sort=comment-count,-create-date - 搜索关键字包含xxx的标记为删除的微博，按照评论数再按创建日期反序排序得到微博列表</li>
</ul>
<p>　　确定了搜索对象，例如weibo，那么在服务器端我们就知道需要查找哪个表，或者需要连接哪几个表。where后面的条件则根据附上的参数动态选择。order by后面的属性则根据sort后面的参数添加，带-号的代表降序，很容易翻译成sql语言。</p>
<p>　　我们还可以选择返回哪些属性，或者不返回哪些属性。例如：</p>
<ul>
<li>GET /weibo?fields=id,subject - 得到微博列表，每个微博里的字段只有id和subject两个，其他的都排除了。</li>
<li>GET /weibo?fields-exclude=id,subject - 得到微博列表，每个微博里的id和subject被排除了，输出其他的字段。</li>
</ul>
<p>　　这些参数就是select后面的列信息。</p>
<p>　　由于RESTful API的资源是面向对象的，我们往往是对某一个对象作查找，如果在查找里需要附带其他资源对象的信息，也可以在query param里添加，用embed字段作为key。例如：</p>
<ul>
<li>GET /weibo?embed=owner.id,owner.name - 得到微博列表，每个微博里的信息里加入这个微博的所有者的id和name两个属性。</li>
</ul>
<p>　　这些属性也是跟在select后面的，只要参数名与数据库的表名能一一对应即可。由于存在嵌入的对象属性，在数据库查找上往往便需要多表连接。</p>
<p>　　上一讲说的翻页的页数和每页的数据项数也是作为query param传给服务器的。</p>
<h3 id="常用的查询"><a href="#常用的查询" class="headerlink" title="常用的查询"></a>常用的查询</h3><p>　　上面说的对搜索的过滤和排序是通用的，根据传入的参数而动态构造sql语句。而对于某些特别常用的查询，例如新浪微博里的最热微博top10，则可以用专用的名字代替，例如：</p>
<ul>
<li>GET /weibo/top10</li>
</ul>
<h3 id="不太能归类的操作"><a href="#不太能归类的操作" class="headerlink" title="不太能归类的操作"></a>不太能归类的操作</h3><p>　　http是面向资源的，RESTful API是基于http的，其操作也是针对某个资源对象进行的，操作的类型则用http方法表达，例如PUT,POST,PATCH,DELETE,GET。然而，有些操作不是那么容易归类为上述的http方法，例如给微博点赞。我们可以把点赞操作理解成修改微博对象，按照这个定义是应该用PUT或PATCH方法。但是一般意义上我们说的对微博的修改是指编辑微博的文本内容。因此，有必要把点赞这个操作独立出来，会更加方便，意义也更加清晰。例如：</p>
<ul>
<li>PUT /weibo/12/like - 给某个微博点赞</li>
<li>DELETE /weibo/12/like - 删除某个微博的赞</li>
</ul>
<h3 id="常用的status-code"><a href="#常用的status-code" class="headerlink" title="常用的status code"></a>常用的status code</h3><ul>
<li>200 OK - 正常返回，用于GET, PUT, PATCH的这些正常操作。</li>
<li>201 Created - 用于POST创建对象正常返回。</li>
<li>204 No Content - 用于DELETE，成功操作但没啥返回的。</li>
<li>304 Not Modified - 有Cache，表示没改过。</li>
<li>400 Bad Request - 指请求里面有些参数不对。</li>
<li>401 Unauthorized - 没有登录</li>
<li>403 Forbidden - 登录了但是没有授权访问某个资源</li>
<li>404 Not Found - 资源不存在</li>
<li>405 Method Not Allowed - 登录了但是不允许做某个操作</li>
<li>410 Gone - 表示资源不再提供了，用来做老版本提示用的</li>
<li>415 Unsupported Media Type - 請求的Centent Type不對</li>
<li>422 Unprocessable Entity - 一般用于validation校验</li>
<li>429 Too Many Requests - 请求太快太多，达到限制</li>
</ul>
<p>　　http提供了很多的status code。但在RESTful API里常用的就这几个。我们可以根据业务需求对不同的request返回相匹配的状态码。方法就是上一讲提到的构造Response对象返回以及异常处理。</p>
<h3 id="JAX-RS怎样接收客户端的参数"><a href="#JAX-RS怎样接收客户端的参数" class="headerlink" title="JAX-RS怎样接收客户端的参数"></a>JAX-RS怎样接收客户端的参数</h3><p>　　RESTful API的核心是URI，HTTP方法以及数据传输格式，在第一讲详细讲过。http header也十分重要，在第二讲讲过。除此之外，服务器与客户端的交互往往需要传递一些参数，例如对象id，需要更新的整个对象以及上面提到的query param等。这些参数的传递都是通过注解实现的。下面介绍一下常用的参数注解。</p>
<h5 id="PathParam"><a href="#PathParam" class="headerlink" title="PathParam"></a>PathParam</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PATCH</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"&#123;id&#125;/remove"</span>)</div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(@PathParam(<span class="string">"id"</span>)</span> Long id,@Context HttpServletRequest request) </span>&#123;</div></pre></td></tr></table></figure>
<p>　　需要删除某条微博，此时URI里必定含有该微博的id信息，可以用@PathParam注解从URI里提取参数。</p>
<h5 id="QueryParam"><a href="#QueryParam" class="headerlink" title="QueryParam"></a>QueryParam</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"danger-unsolved"</span>)</div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json;charset=UTF-8"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">findUnSolved</span><span class="params">(@QueryParam(<span class="string">"page"</span>)</span> <span class="keyword">int</span> page,@<span class="title">QueryParam</span><span class="params">(<span class="string">"per-page"</span>)</span> <span class="keyword">int</span> perPage,@Context HttpServletResponse response) </span>&#123;</div></pre></td></tr></table></figure>
<p>　　翻页信息用query param传递，用@QueryParam注解可以提取。</p>
<h5 id="FormParam"><a href="#FormParam" class="headerlink" title="FormParam"></a>FormParam</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@POST</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"login"</span>)</div><div class="line"><span class="meta">@PermitAll</span></div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/x-www-form-urlencoded"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">login</span><span class="params">(@Context HttpServletRequest request,</span></span></div><div class="line">        @Context HttpServletResponse response,</div><div class="line">        @FormParam(<span class="string">"username"</span>) String username,</div><div class="line">        @<span class="title">FormParam</span><span class="params">(<span class="string">"password"</span>)</span> String password,</div><div class="line">        @<span class="title">FormParam</span><span class="params">(<span class="string">"remember_me"</span>)</span> String rememberMe) &#123;</div></pre></td></tr></table></figure>
<p>　　用POST请求提交的表格，其表单内容可以用@FormParam获取。</p>
<h5 id="MatrixParam"><a href="#MatrixParam" class="headerlink" title="MatrixParam"></a>MatrixParam</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Path</span>(<span class="string">"/books"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@GET</span></div><div class="line">	<span class="meta">@Path</span>(<span class="string">"&#123;year&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Response <span class="title">getBooks</span><span class="params">(@PathParam(<span class="string">"year"</span>)</span> String year,</span></div><div class="line">			@<span class="title">MatrixParam</span><span class="params">(<span class="string">"author"</span>)</span> String author,</div><div class="line">			@<span class="title">MatrixParam</span><span class="params">(<span class="string">"country"</span>)</span> String country) &#123;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> Response</div><div class="line">			.status(<span class="number">200</span>)</div><div class="line">			.entity(<span class="string">"getBooks is called, year : "</span> + year</div><div class="line">				+ <span class="string">", author : "</span> + author + <span class="string">", country : "</span> + country)</div><div class="line">			.build();</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　上述的request请求URI是/books/2011;author=mkyong;country=malaysia。@MatirxParam可以提取用；分隔的一组key/value对。</p>
<h5 id="HeaderParam和CookieParam"><a href="#HeaderParam和CookieParam" class="headerlink" title="HeaderParam和CookieParam"></a>HeaderParam和CookieParam</h5><p>　　@HeaderParam和@CookieParam注解都是提取header或者cookie里某个key的value。像@HeaderParam(“Referer”)和@CookieParam(“customerId”)等，非常简单。</p>
<h5 id="获取HttpServletRequest和HttpServletResponse"><a href="#获取HttpServletRequest和HttpServletResponse" class="headerlink" title="获取HttpServletRequest和HttpServletResponse"></a>获取HttpServletRequest和HttpServletResponse</h5><p>　　JAX-RS是基于servlet实现的。其每个资源方法都可以提取相应请求的HttpServletRequest和HttpServletResponse对象。利用这两个对象，我们可以在资源方法内构造Response对象，也可以修改header和cookie。这两个对象都可以用@Context注解获取。上面的一些例子也有体现。</p>
<h5 id="payload对象"><a href="#payload对象" class="headerlink" title="payload对象"></a>payload对象</h5><p>　　http request的payload对象在网络中是以json或xml的格式传输的，只要JAX-RS里能保证其反序列化，那么在参数列表里直接用相应的POJO对象类名和实体名表示即可。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PATCH</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"&#123;id&#125;/block"</span>)</div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> MessageDTO <span class="title">block</span><span class="params">(@PathParam(<span class="string">"id"</span>)</span> Long id,@Context HttpServletRequest request,MessageDTO messageDTO) </span>&#123;</div></pre></td></tr></table></figure>
<p>　　上面的MessageDTO对象便是http request的payload对象。</p>
<p>　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RESTful API 入门二(JAX-RS实现)]]></title>
      <url>http://wjqwsp.github.io/2016/08/22/RESTful-API-%E5%85%A5%E9%97%A8%E4%BA%8C-JAX-RS%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="为什么要用Provider"><a href="#为什么要用Provider" class="headerlink" title="为什么要用Provider"></a>为什么要用Provider</h3><p>　　provider是在程序运行时自动调用的一些类，起到配置与修改http请求与回应的作用，是JAX-RS里不可或缺的一项组件。从上一讲可以看到，Resource组件已经能够完全实现RESTful API，在JAX-RS标准里无非就是添加一些注解的事。然而，实现功能只是最基本的要求，要做出企业级的应用，必须符合一些标准和规范，才能最大程度地提高团队的开发效率，并从最佳实践的角度去吻合市场的需求。RESTful API的一些设计规范，就必须要使用到provider去做配置。</p>
<h3 id="几种provider的介绍"><a href="#几种provider的介绍" class="headerlink" title="几种provider的介绍"></a>几种provider的介绍</h3><p>　　所有类名上添加了@provider注解的类，都属于provider组件。下面将介绍一下常用的provider。<br><a id="more"></a></p>
<h5 id="ContainerRequestFilter-ContainerResponseFilter"><a href="#ContainerRequestFilter-ContainerResponseFilter" class="headerlink" title="ContainerRequestFilter,ContainerResponseFilter"></a>ContainerRequestFilter,ContainerResponseFilter</h5><p>　　过滤器，顾名思义，是对进入服务器与从服务器输出的数据进行过滤。由于RESTful API实际上是操作http协议，那么过滤器便是对http request或http response的header或body进行过滤，作出一些修改，或判断是否拒绝该http request或http response。</p>
<p>　　containerRequestFilter的核心是filter方法，接收ContainerRequestContext对象，这个对象封装了http request。一般在这个方法里对header进行操作。ContainerResponseFilter的核心也是filter方法，接收ContainerResponseContext和ContainerResponseContext对象，这个对象封装的则是http response，也主要针对其heaer操作。</p>
<p>　　下面从两个主要的设计规范点出发，看看怎么用JAX-RS的过滤器来实现。</p>
<ul>
<li>HTTP方法重载。上一讲提到，RESTful API涉及的HTTP方法有GET，POST,PUT,PATCH,DELETE这几种，而有些http proxy只能用GET和POST方法。一般的解决方法是将PUT，PATCH和DELETE请求也用POST方法发出，但在header里添加X-HTTP-Method-Override这个key，来存储真正的方法名。那么服务器端怎么利用http header，来进行方法重新匹配的呢？这就需要用到ContainerRequestFilter了。下面请看代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="meta">@PreMatching</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpMethodOverrideEnabler</span> <span class="keyword">implements</span> <span class="title">ContainerRequestFilter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(ContainerRequestContext requestContext)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        String override = requestContext.getHeaders()</div><div class="line">                .getFirst(<span class="string">"X-HTTP-Method-Override"</span>);</div><div class="line">        <span class="keyword">if</span> (override != <span class="keyword">null</span>) &#123;</div><div class="line">            requestContext.setMethod(override);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　　先来看@PreMatching注解。所有的provider都对应特定的资源类或者资源方法，当http request到达，会首先根据其URI和HTTP方法类型去匹配相应的Resource组件类的某个方法，这在上一讲已经讲过。一般情况下所有ContainerRequestFilter的执行时机是在方法匹配之后，但是我们的需求是在方法匹配之前对方法进行重载，根据X-HTTP-Method-Override里的方法名进行重匹配。这就需要用到@PreMatching注解了，它能把过滤器的执行时机提前到方法匹配之前。filter方法里代码也很简单，就是从requestContext里提取header里的X-HTTP-Method-Override字段，如果不为空则用setMethod方法进行重匹配。</p>
<ul>
<li>对访问频率进行限制。我们提供的RESTful API服务允许开发者访问，但必须设置一定的安全措施，防止被滥用，被过度调用，被恶意攻击，因此必须对资源的访问频率进行限制。在限制的同时，我们也应该提供给调用者一些信息，让他们获知每周期的调用限制数，每周期内的剩余次数，以及到下一个周期的剩余时间。这些的实现同样可以用过滤器以及header来实现。请看代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpLimitRequestFilter</span> <span class="keyword">implements</span> <span class="title">ContainerRequestFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(ContainerRequestContext requestContext)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (requestContext.getCookies().get(<span class="string">"reset"</span>) != <span class="keyword">null</span> &amp;&amp; requestContext.getCookies().get(<span class="string">"timeout"</span>) != <span class="keyword">null</span>) &#123;</div><div class="line">            String timeOut = requestContext.getCookies().get(<span class="string">"timeout"</span>).getValue();</div><div class="line">            String reset = requestContext.getCookies().get(<span class="string">"reset"</span>).getValue();</div><div class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Date timeOutDate = sdf.parse(timeOut);</div><div class="line">                <span class="keyword">if</span> (timeOutDate.after(<span class="keyword">new</span> Date()) &amp;&amp; Integer.parseInt(reset) &lt;= <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> WebApplicationException(Response.status(<span class="number">429</span>).build());</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="meta">@Tracked</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpLimitResponseFilter</span> <span class="keyword">implements</span> <span class="title">ContainerResponseFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LIMIT = <span class="number">100</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TERM = <span class="number">60</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(ContainerRequestContext requestContext, ContainerResponseContext responseContext)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (requestContext.getCookies().get(<span class="string">"reset"</span>) == <span class="keyword">null</span> || requestContext.getCookies().get(<span class="string">"timeout"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">            addOrReplaceCookies(responseContext);</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            String timeOut = requestContext.getCookies().get(<span class="string">"timeout"</span>).getValue();</div><div class="line">            String reset = requestContext.getCookies().get(<span class="string">"reset"</span>).getValue();</div><div class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Date timeOutDate = sdf.parse(timeOut);</div><div class="line">                Date now  = <span class="keyword">new</span> Date();</div><div class="line">                <span class="keyword">if</span> (timeOutDate.before(now)) &#123;</div><div class="line">                    addOrReplaceCookies(responseContext);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">long</span> interval = (timeOutDate.getTime() - now.getTime())/<span class="number">1000</span>;</div><div class="line">                    <span class="keyword">if</span>(Integer.parseInt(reset) &gt; <span class="number">0</span>)&#123;</div><div class="line">                        NewCookie cookie = <span class="keyword">new</span> NewCookie(<span class="string">"reset"</span>, String.valueOf(Integer.parseInt(reset) - <span class="number">1</span>), <span class="string">"/sampleweb"</span>, <span class="string">""</span>, <span class="string">"comment"</span>, <span class="number">100</span>, <span class="keyword">false</span>);</div><div class="line">                        responseContext.getHeaders().add(<span class="string">"Set-Cookie"</span>, cookie);</div><div class="line">                        responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Remaining"</span>, Integer.parseInt(reset) - <span class="number">1</span>);</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        NewCookie cookie = <span class="keyword">new</span> NewCookie(<span class="string">"reset"</span>, String.valueOf(<span class="number">0</span>), <span class="string">"/sampleweb"</span>, <span class="string">""</span>, <span class="string">"comment"</span>, <span class="number">100</span>, <span class="keyword">false</span>);</div><div class="line">                        responseContext.getHeaders().add(<span class="string">"Set-Cookie"</span>, cookie);</div><div class="line">                        responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Remaining"</span>, <span class="number">0</span>);</div><div class="line">                    &#125;                    </div><div class="line">                    responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Limit"</span>, LIMIT);</div><div class="line">                    responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Reset"</span>, (<span class="keyword">int</span>)interval);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOrReplaceCookies</span><span class="params">(ContainerResponseContext responseContext)</span> </span>&#123;</div><div class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">        Calendar cal = Calendar.getInstance();</div><div class="line">        cal.add(Calendar.MINUTE, <span class="number">1</span>);        </div><div class="line">        NewCookie reset = <span class="keyword">new</span> NewCookie(<span class="string">"reset"</span>, String.valueOf(LIMIT - <span class="number">1</span>), <span class="string">"/sampleweb"</span>, <span class="string">""</span>, <span class="string">"comment"</span>, <span class="number">100</span>, <span class="keyword">false</span>);</div><div class="line">        NewCookie remain = <span class="keyword">new</span> NewCookie(<span class="string">"timeout"</span>, sdf.format(cal.getTime()), <span class="string">"/sampleweb"</span>, <span class="string">""</span>, <span class="string">"comment"</span>, <span class="number">100</span>, <span class="keyword">false</span>);</div><div class="line">        responseContext.getHeaders().add(<span class="string">"Set-Cookie"</span>, remain);</div><div class="line">        responseContext.getHeaders().add(<span class="string">"Set-Cookie"</span>, reset);</div><div class="line">        responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Limit"</span>, LIMIT);</div><div class="line">        responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Remaining"</span>, LIMIT - <span class="number">1</span>);</div><div class="line">        responseContext.getHeaders().add(<span class="string">"X-Rate-Limit-Reset"</span>, TERM);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　由于http协议是无状态的，而用户的访问频率是需要保存的状态，因此需用cookie来实现。cookie主要存储两个值，一个是本周期内还可以访问的次数，一个是本周期结束的时间。利用这两个值，在ContainerRequestFilter内判断是否接受这次请求，并在ContainerResponseFilter内更新每次请求过后cookie的值。这里有一个坑需要特别注意，ContainerResponseContext用getCookies()方法获取的cookie是只读的，不能修改，如果要更新cookie必须直接在http response的header里写入Set-Cookie字段。这也是http response携带cookie的规范做法。并且，NewCookie对象在创建时候必须指定路径。因为相同路径和域名的cookie是保存在同一个文件夹里的，一般是取工程路径，以表示相同工程内使用的cookie，不然在添加cookie的时候即便key一样也会插入新数据，而不会覆盖原来的cookie，达不到更新的效果。</p>
<p>　　反馈给用户的信息是保存在response的header里的，X-Rate-Limit-Limit表示每个累计周期内的访问次数最大是多少；X-Rate-Limit-Remaining表示目前的累计周期内还剩余多少次可以用；X-Rate-Limit-Reset表示还有多少秒钟累计周期就到期了，可以开始下一个周期了。这些header信息都是RESTful API的设计规范里包含的。</p>
<p>　　如果用户访问频率超出限制，需要抛出error code为429的http response，429在http标准里是表示Too Many Requests。这也是RESTful API的规范之一。充分利用错误码来表达操作的结果，设计RESTful API的时候对每一条http response都必须返回相应的错误码，不得有误。更详细的error code规范会在后面介绍，这里先提一下。</p>
<h5 id="MessageBodyWriter和MessageBodyReader"><a href="#MessageBodyWriter和MessageBodyReader" class="headerlink" title="MessageBodyWriter和MessageBodyReader"></a>MessageBodyWriter和MessageBodyReader</h5><p>　　这两类是进行对象的序列化与反序列化的。在基本的RESTful API开发中并不常用，因为如上一讲所说，利用@XmlRootElement这个JAXB注解便可轻松解决xml与json的序列化与反序列化，只有更高层次的要求才需要自己实现这两个类。我也并没有怎么使用过，对这两个类的认识也仅停留在官方文档的介绍，日后如果有机会实践过后，有更深入的理解再行补充。</p>
<h5 id="ContextResolver"><a href="#ContextResolver" class="headerlink" title="ContextResolver"></a>ContextResolver</h5><p>　　前面说过，RESTful API规范里数据传输的格式是json，而JAX-RS序列化后的json格式往往是没有缩进和换行的，这就使得json文本不方便阅读。RESTful API规范要求json必须按照pretty print的方式输出。实现pretty print一种比较简单的方法是使用Jackson框架，利用ObjectMapper类将对象映射成相应的json文本，并且其pretty print模式。下面请看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="meta">@Produces</span>(MediaType.APPLICATION_JSON)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonContextResolver</span> <span class="keyword">implements</span> <span class="title">ContextResolver</span>&lt;<span class="title">ObjectMapper</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JacksonContextResolver</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">this</span>.objectMapper = <span class="keyword">new</span> ObjectMapper();</div><div class="line">        <span class="keyword">this</span>.objectMapper</div><div class="line">                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>)</div><div class="line">                .configure(SerializationFeature.INDENT_OUTPUT, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">getContext</span><span class="params">(Class&lt;?&gt; objectType)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> objectMapper;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　其中objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true)便是让输出使用pretty print。注意的是，使用Jackson框架必须要在Application的实现类里注册相应资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClasses() &#123;</div><div class="line">        Set&lt;Class&lt;?&gt;&gt; resources = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</div><div class="line">        addRestResourceClasses(resources); </div><div class="line">        resources.add(JacksonFeature.class);    </div><div class="line">        <span class="keyword">return</span> resources;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>　　resources.add(JacksonFeature.class)这一句是不能省的。</p>
<h5 id="WriteInterceptor-ReadInterceptor"><a href="#WriteInterceptor-ReadInterceptor" class="headerlink" title="WriteInterceptor,ReadInterceptor"></a>WriteInterceptor,ReadInterceptor</h5><p>　　拦截器，与过滤器的作用有很多相似的地方。不同之处在于，过滤器一般用来处理header，拦截器则用来处理http request与response的body里的entity的输入输出流。可以利用拦截器对输入流进行统一的解码或解压缩，或者对输出流进行统一的编码或压缩。</p>
<p>　　RESTful API规范里要求对response同一使用GZIP压缩，把pretty print处理后的json文本压缩处理，节省带宽，节约流量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPWriterInterceptor</span> <span class="keyword">implements</span> <span class="title">WriterInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundWriteTo</span><span class="params">(WriterInterceptorContext context)</span></span></div><div class="line">                    <span class="keyword">throws</span> IOException, WebApplicationException &#123;</div><div class="line"></div><div class="line">    	MultivaluedMap&lt;String,Object&gt; headers = context.getHeaders();</div><div class="line">    	headers.add(<span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</div><div class="line">        <span class="keyword">final</span> OutputStream outputStream = context.getOutputStream();</div><div class="line">        context.setOutputStream(<span class="keyword">new</span> GZIPOutputStream(outputStream));</div><div class="line">        context.proceed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　上面的代码是利用WriteInterceptor进行GZIP压缩的示例，十分简单，ReadInterceptor类似，只是换成操作输入流。只需要在输出流外再包装一层GZIPOutputStream的包装流便可。注意必须在header里添加Content-Encoding字段，这样浏览器才知道怎么解压缩。</p>
<p>　　上面最值得一提的是context.proceed()这个方法。所有拦截器必须调用这个方法，调用这个方法后会自动调用下一个拦截器，直到到达拦截器链末端的最后一个拦截器，此时该拦截器调用proceed()方法后会调用MessageBodyWriter或MessageBodyReader去进行序列化或反序列化。</p>
<p>　　拦截器以及MessageBodyWriter和MessageBodyReader都是在entity不为空的情况下才会调用的，若response不返回数据或者request的body不携带数据，则这些类都不会被使用。</p>
<h5 id="provider的调用顺序"><a href="#provider的调用顺序" class="headerlink" title="provider的调用顺序"></a>provider的调用顺序</h5><ol>
<li>pre-matching ContainerRequestFilters</li>
<li>post-matching ContainerRequestFilters</li>
<li>ReaderInterceptor</li>
<li>MessageBodyReader</li>
<li>ContainerResponseFilters</li>
<li>WriterInterceptor</li>
<li>MessageBodyWriter</li>
</ol>
<h5 id="资源绑定"><a href="#资源绑定" class="headerlink" title="资源绑定"></a>资源绑定</h5><p>　默认情况下所有的http请求的到来都会让所有provider类自动运行相应的方法，但我们可以通过资源绑定的方式，让某些provider只会被某些request触发。主要有两种方式：Name binding和Dynamic binding</p>
<ol>
<li>Name binding</li>
</ol>
<p>通过@NameBinding注解实现：</p>
<ul>
<li>定义注解，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NameBinding</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Tracked &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>为provider添加该注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="meta">@Tracked</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpLimitResponseFilter</span> <span class="keyword">implements</span> <span class="title">ContainerResponseFilter</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>为相应的资源方法或资源类添加该注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"current_user"</span>)</div><div class="line"><span class="meta">@PermitAll</span></div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Tracked</span></div><div class="line"><span class="function"><span class="keyword">public</span> JsonObject <span class="title">getCurrentUserInfo</span><span class="params">(@Context HttpServletRequest request)</span> </span>&#123;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Stateless</span></div><div class="line"><span class="meta">@RolesAllowed</span>(&#123;<span class="string">"operator"</span>&#125;)</div><div class="line"><span class="meta">@Path</span>(<span class="string">"message"</span>)</div><div class="line"><span class="meta">@Tracked</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFacadeREST</span> <span class="keyword">extends</span> <span class="title">AbstractFacade</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</div></pre></td></tr></table></figure>
<p>　　当访问带有@Tracked注解的方法或类时，带有@Tracked的provider便会在相应的资源方法调用前后自动触发。从而实现资源绑定。</p>
<ol>
<li>Dynamic binding</li>
</ol>
<p>　　动态绑定是通过DynamicFeature接口实现的，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressionDynamicBinding</span> <span class="keyword">implements</span> <span class="title">DynamicFeature</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceInfo resourceInfo, FeatureContext context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (HelloWorldResource.class.equals(resourceInfo.getResourceClass())</div><div class="line">                &amp;&amp; resourceInfo.getResourceMethod()</div><div class="line">                    .getName().contains(<span class="string">"VeryLongString"</span>)) &#123;</div><div class="line">            context.register(GZIPWriterInterceptor.class);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　configure()方法里接收两个参数，ResourceInfo对象用来对request要访问的资源进行过滤，FeatureContext对象用来对相应的provider进行动态注册。</p>
<h3 id="异常处理以及返回Response对象"><a href="#异常处理以及返回Response对象" class="headerlink" title="异常处理以及返回Response对象"></a>异常处理以及返回Response对象</h3><p>　　如果没有错误正常返回，一般直接返回结果对象或者什么也不返回即可，这时不需要额外配置response的header或status code。但是，若抛出异常或者结果不正确，则需要返回相应的status code。这时候便需要我们构造Response对象返回。</p>
<p>　　JAX-RS的异常处理建议统一使用WebApplicationException类或者使用ExceptionMapper类来实现。</p>
<h5 id="WebApplicationException"><a href="#WebApplicationException" class="headerlink" title="WebApplicationException"></a>WebApplicationException</h5><p>　　直接抛出WebApplicationException:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> WebApplicationException(Response.status(<span class="number">429</span>).build());</div></pre></td></tr></table></figure>
<p>　　接收的参数可以是用相应status code构造的Response对象，也可以直接用status code作为参数。此时JAX-RS便会构造出相应status code的http response报文。</p>
<h5 id="ExceptionMapper"><a href="#ExceptionMapper" class="headerlink" title="ExceptionMapper"></a>ExceptionMapper</h5><p>　　如果在程序运行期间抛出异常，导致不能返回正确结果，可以用ExceptionMapper的实现类来捕捉特定的异常。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provider</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessLocalExceptionMapper</span> <span class="keyword">implements</span> <span class="title">ExceptionMapper</span>&lt;<span class="title">AccessLocalException</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">toResponse</span><span class="params">(AccessLocalException exception)</span> </span>&#123;        </div><div class="line">        <span class="keyword">return</span> Response.status(Response.Status.UNAUTHORIZED).build();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　ExceptionMapper可以定义成任何异常类的处理类，在toResponse()方法里进行异常处理，并构造Response对象返回。有这么一个机制来统一进行异常处理，使得代码管理十分清晰，行文十分优雅。</p>
<h5 id="正常返回Response对象"><a href="#正常返回Response对象" class="headerlink" title="正常返回Response对象"></a>正常返回Response对象</h5><p>　　即便是在资源方法里正常返回，但如果除了传输数据外，还需要携带header,cookie等信息，则也需要构造Response对象返回，正常数据则作为Response对象里的GenericEntity对象保存。</p>
<p>　　在正常的业务逻辑里，我们读取一些数据的时候往往需要翻页信息，页数以及每页的数据项数在RESTful API规范里往往是作为http request的query params传输的，而相应的http response也通常会在header里返回上一页，下一页，第一页以及最后一页数据的URI，方便用户继续访问。下面就以这一个规范点作为需求，看看代码里怎么构造翻页信息的Response对象的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GenericEntity entity = <span class="keyword">new</span> GenericEntity&lt;List&lt;MessageDTO&gt;&gt;(messageRepo)&#123;&#125;;</div><div class="line"><span class="keyword">double</span> count = (<span class="keyword">double</span>)messageService.countDangerousMessage();</div><div class="line">response.setHeader(<span class="string">"next"</span>, <span class="string">"https://localhost:8080/sampleweb/api/message/danger-unsolved?page="</span> + (page + <span class="number">1</span>));</div><div class="line">response.setHeader(<span class="string">"prev"</span>, <span class="string">"https://localhost:8080/sampleweb/api/message/danger-unsolved?page="</span> + (page - <span class="number">1</span>));</div><div class="line">response.setHeader(<span class="string">"first"</span>, <span class="string">"https://localhost:8080/sampleweb/api/message/danger-unsolved?page=1"</span>); </div><div class="line">response.setHeader(<span class="string">"last"</span>, <span class="string">"https://localhost:8080/sampleweb/api/message/danger-unsolved?page="</span> + (<span class="keyword">int</span>)Math.ceil(count / perPage));</div><div class="line">response.setHeader(<span class="string">"X-Total-Count"</span>,String.valueOf((<span class="keyword">int</span>)count));</div><div class="line"><span class="keyword">return</span> Response.ok(entity).build();</div></pre></td></tr></table></figure>
<p>　　GenericEntity保存需要返回的body里的数据。在header里添加上相应页面资源的URI，并且让X-Total-Count返回总的数据项数。这些信息都是提供给用户的。Response的ok()方法接收entity参数，并且构造status code为200的http response返回给用户。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　这一讲主要讲的是JAX-RS的provider组件，并涉及了一些异常处理和构造Response对象的内容，其实主要就是围绕http request和http response展开的。希望读者能够体会到，RESTful API归根结底就是http报文，http报文又可以分为header和body。对header和body，RESTful API都有一定的规范对其进行限制，而实现这些规范的手段便是provider，异常处理以及Response对象。RESTful API必须对每一个接口的request和response的header和body有清楚的定义。手段方法是其次，RESTful API的思想与规范才是根本。下一讲会把一些还没涉及的设计规范讲一下，但用到的技术基本就是这一讲和上一讲Resource和Provider组件的内容了。       </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RESTful API 入门一(JAX-RS实现)]]></title>
      <url>http://wjqwsp.github.io/2016/08/21/RESTful-API-%E5%85%A5%E9%97%A8-JAX-RS%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　关于RESTful API的概念网上已经说过很多，可以用很多语言与框架实现，其规范也十分详尽。我这篇入门教程尽量用自己的理解去总结RESTful API的一些要点，并以JaveEE规范的JAX-RS框架为例，以实战的形式去讲述怎么搭建一套RESTful API，并在实践过程中体现RESTful API的设计规范。</p>
<h3 id="什么是RESTful-API"><a href="#什么是RESTful-API" class="headerlink" title="什么是RESTful API"></a>什么是RESTful API</h3><ol>
<li>服务器端提供给开发者的一套接口，开发者通过调用这些接口，访问服务器的资源。这些资源通常是数据库的表抽象出来的对象，程序员通过获取这些对象，把对这些对象的增删改查映射到数据库，从而实现自己前后端的其他业务逻辑。目前移动端很多都是使用RESTful API来访问后台，受移动端影响，浏览器端也越来越多地使用这种规范。</li>
<li>本质就是http协议。RESTful API的所有操作无非是CRUD，全部映射成http的POST,GET,PUT,PATCH,DELETE等方法，操作RESTful API实际上就是操作http报文，其只是在http协议外面再封装一层。因此操作十分简洁，直观，代码优雅。</li>
<li>用URI定位所有资源。服务器端把所有供开发者访问的资源都以特定的URI表示。URI与http方法(上述的POST，GET等)组合，便可以实现对所有资源的所有操作。以微博和评论为例，假如新浪微博开放了所有微博和评论允许开发者访问。那么所有微博的URI可能是：<a id="more"></a>
<pre><code>api/weibo</code></pre><br>　　id为30691的微博URI可能是：<br><pre><code>api/weibo/30691</code></pre><br>　　id为30691的微博所有评论的URI可能是：<br><pre><code>api/weibo/30691/comment</code></pre><br>　　id为30691的微博对应的评论id为2589的评论的URI可能是：<br><pre><code>api/weibo/30691/comment/2589</code></pre><br>　　出于面向对象的思想，一般每个资源都对应一个对象，应该用名词表示，且倾向于单数。资源之间的依赖关系可以参照上述的weibo与comment。由于评论必定对应于某一条微博，所以可以用类似weibo/30691/comment的形式表示这种依赖。</li>
</ol>
<p>　　显而易见，这种目录式的URI定位十分直观，简单。</p>
<h3 id="搭建基本JAX-RS环境"><a href="#搭建基本JAX-RS环境" class="headerlink" title="搭建基本JAX-RS环境"></a>搭建基本JAX-RS环境</h3><p>　　JAX-RS是JaveEE框架里专门用来实现RESTful API的技术。搭建十分简单，且大都用注解注入的形式实现，使代码结构十分清晰，代码量很少。除了依赖的包以及一些xml配置文件以外，代码里只需要自己继承实现javax.ws.rs.core.Application类便可以完成最基本的配置。依赖的包和xml配置可自行上网搜索，不是我这篇教程的重点，这里将主要介绍代码里如何实现RESTful API</p>
<h5 id="Application类"><a href="#Application类" class="headerlink" title="Application类"></a>Application类</h5><p>　　必须创建一个类继承Application类。JAX-RS里我们用到的组件主要有两类，分别是Resource和Provider。Resource就是上述的URI对应的可供用户访问的资源。Provider是运行时自行调用的一些类，起到配置作用，这在下一讲再详细介绍。这两类组件都必须在Application类的实现类的Set<class<?>&gt; getClasses()方法里进行注册。以下是官网文档的示例：</class<?></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClasses() &#123;</div><div class="line">        Set&lt;Class&lt;?&gt;&gt; s = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</div><div class="line">        s.add(HelloWorldResource.class);</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　HelloWorldResource就是Resource组件的其中一个类，如果RESTful API需要访问这个资源类，则需要用上述的语法实现注册，是不是很简单。</p>
<h5 id="ResourceConfig类"><a href="#ResourceConfig类" class="headerlink" title="ResourceConfig类"></a>ResourceConfig类</h5><p>　　ResourceConfig是JAX-RS里提供的一个Application的实现类，通过继承这个类并且在其派生类的构造方法里对组件进行注册，可以简化注册的过程。除了对需要使用的Resource和Provider组件进行register以外，还可以通过提供要注册组件所在的包，而自动将包内所有这两类组件注册。以下是示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyApplication</span><span class="params">()</span> </span>&#123;</div><div class="line">        packages(<span class="string">"org.foo.rest;org.bar.rest"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRESTExampleApplication</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRESTExampleApplication</span><span class="params">()</span> </span>&#123;</div><div class="line">         packages(<span class="string">"com.carano.fleet4all.restExample"</span>);</div><div class="line">         register(JacksonFeature.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ApplicationPath注解"><a href="#ApplicationPath注解" class="headerlink" title="ApplicationPath注解"></a>ApplicationPath注解</h5><p>　　可以为Application的实现类添加@javax.ws.rs.ApplicationPath注解，那么所有RESTful API的URI资源都将包含该注解提供的名字作为前缀。以下是示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@javax</span>.ws.rs.ApplicationPath(<span class="string">"api"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClasses() &#123;</div><div class="line">        Set&lt;Class&lt;?&gt;&gt; resources = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</div><div class="line">        addRestResourceClasses(resources); </div><div class="line">        resources.add(JacksonFeature.class);    </div><div class="line">        <span class="keyword">return</span> resources;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　在这里注册的所有资源，其URI定位都必然是/api/…</p>
<h3 id="Resource组件"><a href="#Resource组件" class="headerlink" title="Resource组件"></a>Resource组件</h3><p>　　搭建了基本的JAX-RS环境，便可以进行真正的业务逻辑的实现了。所谓的业务逻辑，无非对特定URI资源的增删改查操作。这些都是在Resource组件方法里通过特定的注解实现操作和资源的匹配的。所有在类名上面添加了@path注解的，都被认为是Resource组件。这些类方法上添加的@path注解，将与类的@path注解提供的名字以及ApplicationPath注解提供的名字组合在一起，作为其URI。</p>
<p>　　以下是Resource组件类示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Path</span>(<span class="string">"message"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFacadeREST</span> <span class="keyword">extends</span> <span class="title">AbstractFacade</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</div></pre></td></tr></table></figure></p>
<p>　　以下是某资源方法示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"danger-unsolved"</span>)</div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json;charset=UTF-8"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">findUnSolved</span><span class="params">(@QueryParam(<span class="string">"page"</span>)</span> <span class="keyword">int</span> page,@<span class="title">QueryParam</span><span class="params">(<span class="string">"per-page"</span>)</span> <span class="keyword">int</span> perPage,@Context HttpServletResponse response) </span>&#123;</div></pre></td></tr></table></figure></p>
<p>　　先忽略掉无关的代码，只看@GET和@Path标注。@GET很容易猜到是用http的GET方法。@Path便是该资源的URI的一部分。如果findUnSolved方法是类MessageFacadeREST里的方法，且MessageFacadeREST在ApplicationConfig类里注册，那么findUnSolved方法便可以通过/api/message/danger-unsolved这个URI访问。如果加上@GET方法，那么就是对/api/message/danger-unsolved这个资源用http的GET方法访问，实际上便是调用对应的findUnSolved方法。</p>
<h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>　　RESTful API里涉及的HTTP方法一般是GET,POST,PUT,PATCH,DELETE。这些HTTP方法都是用注解形式添加在相应的Resource组件类的方法上。</p>
<ol>
<li>GET方法：用于对资源的读取，一般返回单个对象或者对象列表。</li>
<li>POST方法：用于创建新对象，需要在客户端传送一个完整对象给服务器，然后将整个对象写入数据库。一般需返回创建好的对象。</li>
<li>PUT方法：用于创建或替换已有对象，需要在客户端传送一个完整对象给服务器，如果数据库没有对应数据，则插入新数据；如果已有旧记录，则用新对象更新。一般需返回创建或更新的对象。</li>
<li>PATCH方法：用于修改某已有对象的部分属性。如果确保对象记录已经在服务器存在，且只需要修改很少的属性，那么推荐用PATCH方法去代替PUT方法。PATCH方法不需要传送整个对象，只需要传送对象id以及需要修改的属性即可。一般需返回更新的对象。</li>
<li>DELETE方法：删除相应对象记录。无返回。</li>
</ol>
<p>　　有一些HTTP proxy只支持GET和POST方法，而不支持其他方法。这种情况在规范里一般在http header里加入X-HTTP-Method-Override的key，里面保存真正的http方法，例如”PUT”或”PATCH”，而请求一律通过POST方法发送到服务器端。具体的代码实现将会在下一讲介绍。</p>
<h3 id="数据传输及序列化与反序列化"><a href="#数据传输及序列化与反序列化" class="headerlink" title="数据传输及序列化与反序列化"></a>数据传输及序列化与反序列化</h3><p>　　在RESTful API操作的是对象，传出与接收一般是实体的POJO对象。而对象如果传出，需要先进行序列化，以xml或json的形式传送。对象如果接收，则要进行反序列化，把json或xml的数据转换成实体的POJO对象。序列化或进行反序列化的数据类型一般用@Produces和@Consumes注解来实现。下面给出一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PUT</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"&#123;id&#125;/block"</span>)</div><div class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> MessageDTO <span class="title">block</span><span class="params">(@PathParam(<span class="string">"id"</span>)</span> Long id,@Context HttpServletRequest request,MessageDTO messageDTO) </span>&#123;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@XmlRootElement</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageDTO</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Long message1Id;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String message1Word;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> message1CommentCount;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> message1TransmissionCount;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String message1UserName;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Timestamp message1Date;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Long message1OwnerId;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> referenced;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Long message2Id;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String message2Word;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> message2CommentCount;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> message2TransmissionCount;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String message2UserName;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Timestamp message2Date;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Long message2OwnerId;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> blocked;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> deleted;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Timestamp managedDate;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String action;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String operator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Timestamp <span class="title">getManagedDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> managedDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setManagedDate</span><span class="params">(Timestamp managedDate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.managedDate = managedDate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAction</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> action;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAction</span><span class="params">(String action)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.action = action;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOperator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> operator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOperator</span><span class="params">(String operator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.operator = operator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlocked</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> blocked;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlocked</span><span class="params">(<span class="keyword">boolean</span> blocked)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.blocked = blocked;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDeleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> deleted;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeleted</span><span class="params">(<span class="keyword">boolean</span> deleted)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.deleted = deleted;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageDTO</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getMessage1Id</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1Id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1Id</span><span class="params">(Long message1Id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1Id = message1Id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage1Word</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1Word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1Word</span><span class="params">(String message1Word)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1Word = message1Word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessage1CommentCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1CommentCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1CommentCount</span><span class="params">(<span class="keyword">int</span> message1CommentCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1CommentCount = message1CommentCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessage1TransmissionCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1TransmissionCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1TransmissionCount</span><span class="params">(<span class="keyword">int</span> message1TransmissionCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1TransmissionCount = message1TransmissionCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage1UserName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1UserName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1UserName</span><span class="params">(String message1UserName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1UserName = message1UserName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Timestamp <span class="title">getMessage1Date</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1Date;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1Date</span><span class="params">(Timestamp message1Date)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1Date = message1Date;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getMessage1OwnerId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message1OwnerId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage1OwnerId</span><span class="params">(Long message1OwnerId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message1OwnerId = message1OwnerId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReferenced</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> referenced;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReferenced</span><span class="params">(<span class="keyword">boolean</span> referenced)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.referenced = referenced;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getMessage2Id</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2Id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2Id</span><span class="params">(Long message2Id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2Id = message2Id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage2Word</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2Word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2Word</span><span class="params">(String message2Word)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2Word = message2Word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessage2CommentCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2CommentCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2CommentCount</span><span class="params">(<span class="keyword">int</span> message2CommentCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2CommentCount = message2CommentCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessage2TransmissionCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2TransmissionCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2TransmissionCount</span><span class="params">(<span class="keyword">int</span> message2TransmissionCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2TransmissionCount = message2TransmissionCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage2UserName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2UserName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2UserName</span><span class="params">(String message2UserName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2UserName = message2UserName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Timestamp <span class="title">getMessage2Date</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2Date;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2Date</span><span class="params">(Timestamp message2Date)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2Date = message2Date;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getMessage2OwnerId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message2OwnerId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage2OwnerId</span><span class="params">(Long message2OwnerId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message2OwnerId = message2OwnerId;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　方法block是通过http的PUT方法访问的，需要传入一个MessageDTO对象，并返回一个MessageDTO对象。@Produces定义了返回对象将序列化成为json格式；@Cosumes定义了接收的对象是json格式的，将对其进行反序列化。JAX-RS里本身没有实现对特定对象自动进行序列化与反序列化。一般需实现MessageBodyWriter或MessageBodyReader这两个类，在这两个类里自行进行序列化与反序列化的处理。这两个类都属于Provider，将在下一讲介绍。但实际上，如果只是简单的进行json或xml的转换是非常简单的，并不需要另外实现Provider，只有对具体的格式有要求或者需要进行更多的配置才有必要实现。一般如果进行xml转换，只需要修改@Produces和@Consumes为对应格式，并且在需要进行序列化与反序列化的POJO类上加上@XmlRootElement注解，便可实现。这种做法实际上是JAX-RS后台调用JAXB实现，@XmlRootElement是JAXB注解，而JAXB是专门用于进行xml和JAVA对象转换的技术。如果需要用json格式，同样可以通过JAXB的@XmlRootElement注解实现，只需把@Provider或@Consumes修改为application/json即可。实际上如果你是用glassfish 4以上作为application server container的，如果以json格式进行传输不需要任何其他Provider或@XmlRootElement，只需要修改@Provider或@Consumes即可。因为glassfish 4已经配置了MOXy作为Default JSON-Binding Provider。MOXy是json的一个框架，它可以在Application里自动注册，不需要显示地手动注册资源。</p>
<p>　　目前，RESTful API规范建议一律采用json作为数据传输的格式，而不要使用xml。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　这篇教程主要针对JAX-RS的Resource组件的基础知识，介绍了RESTful API的概念，以及HTTP方法，URI资源定位和数据传输格式这三个最核心的内容，并涉及了一些RESTful API的设计规范。更多的设计规范以及关于Provider的知识，将再后面一一介绍。</p>
]]></content>
    </entry>
    
  
  
</search>
